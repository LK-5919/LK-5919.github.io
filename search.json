[{"title":"jQuery学习第二天","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/12/jQuery学习第二天/","content":"jQuery操作class1.给元素添加类名：addClass(类名)\n$(\"#addClass\").click(function()&#123;\n    //给id名为box1的元素添加black类\n    $(\"#box1\").addClass(\"black\");\n&#125;);\n\n注意方法addClass()中可传入多个类 需要使用空格间隔开；\n $('#div1').addClass('fontSize30 width200');\n2.判断元素是否存在指定类名：hasClass(类名)\nconsole.log($('#div1').hasClass('fontSize30'));\n//如果元素存在类名fontSize30返回true，否则返回false；\n3.给元素移除类名：removeClass(类名)\n $(\"#removeClass\").click(function()&#123;\n        if($(\".box1\").hasClass(\"black\"))&#123;\n            //移除单个类\n            $(\".box1\").removeClass(\"black\");\n        &#125;\n    &#125;);\n\n //移除多个类\n$('#div1').removeClass('fontSize30 width200');\n\n注意：使用removeClass()不传入参数时默认移除当前元素的所有类；\n $('#div1').removeClass();\n4.给元素切换类（若存在指定类则删除否则添加指定类）：toggleClass()\n$(\"#toggleClass\").click(function()&#123;\n       $(\".box1\").toggleClass(\"black\");\n   &#125;);\njQuery动画1.显式与隐藏，切换1.显示 --- show()，可传入两个参数\n第一个参数：表示动画的执行时长（毫秒数），也可以是规定的字符串（fast:200ms,normal:400ms,slow:600ms），当传入的字符串单词不正确时默认使用normal，如果不传入参数，那就不显示动画效果；\n\n第二个参数：动画执行完毕以后执行的回调函数\n\n$(\"#box1\").show();  //显示但没有动画\n$(\"#box1\").show(2000); //指定动画执行的时间为2000ms\n$(\"#box1\").show(\"fast\"); //指定动画的执行时间为200ms\n$(\"#box1\").show(\"fat\");  //单词错误，使用normal值---400ms\n$(\"#box1\").show(2000,function()&#123;\n    console.log(\"显示动画执行完毕！\");\n&#125;);   //指定的显示动画执行完毕以后控制台输出语句\n\n\n2.隐藏 --- hide()，可传入两个参数，同show()方法一致；\n\n3.切换 --- toggle()，可传入两个参数，同show()方法一致；（当前状态为show时执行hide方法，否则执行show方法）\n\n注意：显示与隐藏修改的是元素的width，height，opacity（不透明度）\n2.滑入与滑出，切换1.滑入 --- slideDown(参数1，参数2)\n\t参数1：动画执行的时长 -- 可以使用数值（ms）或者字符串单词（同show()方法一致）\n     参数2：动画执行完毕以后的回调函数\n     注意：如果不传入第一个参数默认使用normal（400ms）\n \n $('#div1').slideDown(2000);  //指定动画的滑入执行时常为2000ms\n\n2.滑出 --- slideUp(参数1，参数2) --- 参数与slideDown()方法一致\n$('#div1').slideUp(2000, function () &#123;\n         alert('滑出做完了...');\n       &#125;);\n3.滑入滑动切换 --- slideToggle(参数1，参数2) --- 参数与slideDown()方法一致\n $('#div1').slideToggle(1000);\n\n注意：滑入与滑出修改的是元素的height；\n3.动画队列与stop()方法在使用jQuery提供的滑入滑出方法实现鼠标移入显示下拉菜单时可以发现存在以下现象：\n\t现象描述：鼠标疯狂快速移入移出下拉菜单后再将鼠标移走到此处的空白处，可以发现此时下拉菜单的滑入滑出动画仍然在执行；\n    原因分析：在给下拉菜单绑定鼠标移入移出事件后，使用鼠标疯狂移入移出下拉菜单就会触发到鼠标事件的\n    回调，而在鼠标事件的回调中需要执行滑入滑出动画（每个滑入滑出事件都具有动画时长，滑入滑出动画执\n    行时都是存放在一个动画队列中），一旦鼠标事件触发，就会往回调队列中按触发顺序添加鼠标回调事件并\n    按添加顺序执行回调事件，在执行回调事件时，又会往动画队列中添加当前的滑入滑出动画事件，在动画队\n    列中也将按添加顺序执行动画；所以在鼠标疯狂移入移出触发回调事件后，就会不断地往动画队列中添加动\n    画事件，此时即使鼠标移到空白处，但是动画队列中事件还没执行完就会产生上述地现象；\n    \n    解决方案：使用stop()方法 ---- 停止动画，该方法可以传入两个参数\n    \t第一个参数：是否清除动画队列中当前元素产生的动画（不包括当前正在执行的动画）（true/false）\n\t\t第二个参数：是否跳转到最终效果（当前执行的动画）（true/false）\n$('div').stop(true,true);  //清除当前div添加到动画队列中但还未执行的动画，\n\t\t\t\t\t\t//并直接跳转到当前执行动画的最终效果\n4.淡入淡出与切换1.淡入 --- fadeIn(参数1，参数2)\n\t参数1：动画执行的时长，可传入数值（ms）或者字符串（同show()方法）\n    参数2：动画执行完后的回调\n$('#div1').fadeIn(); //不给参数相当于给了一个默认的动画时长,mormal400毫秒\n$('#div1').fadeIn(2000, function () &#123;\n         alert('淡入完成了...');\n       &#125;);\n\n2.淡出 --- fadeOut(参数1，参数2) --- 用法和fadeIn()方法一致\n$('#div1').fadeOut(1000);\n\n3.淡入淡出切换 --- fadeToggle(参数1，参数2) --- 用法和fadaIn()方法一致\n $('#fadeToggle').click(function () &#123;\n      $('#div1').fadeToggle(1000);\n    &#125;);\n\n注意：淡入淡出都是设置元素的opacity；\n\n4.淡入到那里 --- fadeTo(参数1，参数2)\n\t参数1：执行时长\n    参数2：淡入动画结束时的opacity\n    $('#fadeTo').click(function () &#123;\n      $('#div1').fadeTo(1000,0.5);\n    &#125;); \n5.自定义动画animate() --- 可传入四个参数\n\t参数1：必选，需要传入一个动画属性的对象\n    参数2：可选，动画执行时长\n    参数3：可选，easing（表示动画执行的速度，linear（匀速）/swing（缓动，默认值））\n    参数4：可选，动画执行完毕以后的回调函数\n    \n      $('#div1').animate(&#123;\n        left:800,\n        width:200,\n        height:200,\n        opacity:0.5\n      &#125;,2000,'linear', function () &#123;\n        //既然这里是一个函数,那就可以写任意的代码,那就可以在这里让div1做动画.\n        $('#div1').animate(&#123;\n          left:400,\n          width:300,\n          height:300,\n          top:150,\n          opacity:1\n        &#125;,2000);\n      &#125;);\n\n\n动画会在元素原有的css样式的基础上变化到animate传入的动画属性对象；\n可以在当前动画执行完后继续出传入一个自定义的动画回调函数，来完成一系列的动画效果；\njQuery操作元素节点动态创建节点原生js中创建元素节点的方法：\n\t1.document.write();\n\t2.innerHTML;\n\t3.document.createElement();\n\njQuery中创建元素节点\n\t1.html();\n\t2.$();\n\nhtml() --- 不传入参数时，可用来获取当前dom对象的内容，会包括标签\n$('#div1').html(); \n\n当传入的参数字符串中包含了标签时，是会把标签解析出来的 -- text()方法就不会；\n $('#div1').html('我是设置的内容&lt;a href=\"https://www.baidu.com\">百度一下&lt;/a>');\n注意！！使用html()方法设置内容时会把原来已有的内容覆盖！\n\n$() --- 这个方法创建的元素节点只存在于内存中，需要手动追加到页面的元素身上；\nvar $link = $('&lt;a href=\"http:www.baidu.com\">点我百度一下&lt;/a>');\n$(\"#box1\").append($link);\njQuery添加节点的方法1.append() --- 父元素添加子元素，作为父元素的最后一个子元素添加；\n\t当插入的子元素是新创建的节点时，只会影响到当前被插入的父元素；\n    但是当插入的子元素是dom树中已经存在的节点是，append()方法是会将该元素从dom树中的位置剪切下来插入到指定的父元素中（会改变子元素原来在文档流的位置，类似于文件剪切而不是文件复制）；\n    \n   //1.1 新创建一个li标签,添加到ul1中的去.\n      var $liNew = $(\"&lt;li>我是新创建的li标签&lt;/li>\");\n      $('#ul1').append($liNew); \n\n//1.2 把ul1中已经存在的li标签添加到ul中去. 剪切后作为最后一个子元素添加.\n      var $li3 = $('#li3');  //这里的$li3是对原有dom对像的地址引用而不是值引用；\n      $('#ul1').append($li3);\n\n2.prepend() --- 父元素添加子元素，作为父元素的第一个子元素添加；\n\t当插入的子元素是已经在dom树中存在的对象时，原理和append()方法一致；\n    \n    //2.1 新建一个li标签,添加到ul1中去.\n      var $liNew = $(\"&lt;li>我是新创建的li标签&lt;/li>\");\n      $('#ul1').prepend($liNew);\n    \n\t//2.1 把ul1中已经存在的li标签添加到ul1中去. 剪切后作为第一个子元素添加.\n       var $li3 = $('#li3');\n       $('#ul1').prepend($li3);\n\n3.before() --- 添加兄弟元素，$A.before($B) ，把B元素插入到A元素的前面，作为兄弟元素添加\n\n//新建一个div\n      var $divNew = $('&lt;div>我是新建的div&lt;/div>');\n      $('#ul1').before($divNew);\n\n4.after() --- 添加兄弟元素，$A.before($B) ，把B元素插入到A元素的后面，作为兄弟元素添加\n\n //新建一个div\n      var $divNew = $('&lt;div>我是新建的div&lt;/div>');\n      $('#ul1').after($divNew);\n\n5.appendTo() --- 添加到父元素中 ，子元素.appendTo(父元素)，把子元素作为父元素的最后一个子元素添加\n\n //5.1 新建一个li标签,添加到ul1中去.\n      var $liNew = $(\"&lt;li>我是新创建的li标签&lt;/li>\");\n      $liNew.appendTo($('#ul1'));\njQuery清空节点与移除节点1.empty() --- 清空元素，或清空当前元素下的所有子元素，不包括当前自身元素节点\n\t$('#ul1').empty();  //清空ul1下的所有子元素\n\n2.remove() --- 移除当前元素（相当于自杀）,会清空当前元素自身和其身上的所有子元素\n\t $(\"#ul1\").remove();\n\n注意：使用html(\"\")方法也可以移除元素，但是不推荐使用，这个方法可能会造成内存泄漏，不安全；\njQuery克隆节点clone() --- 克隆的节点只存在内存，需要手动追加到页面的dom树中；\n\t可以传入一个参数（true/false）\n\t参数是true表示会把事件一起克隆到. 参数如果是false就不会克隆事件. 不给参数默认是false.\n    \n   //给id为div1的这个元素添加一个点击事件.\n    $('#div1').click(function () &#123;\n      alert('哈哈,我被点击了...');\n    &#125;);\n   var $cloneDiv = $('#div1').clone(true);\n      //修改克隆节点的id\n      $cloneDiv.attr('id','div2');\n \t  $('body').append($cloneDiv);\n\njQuery获取value或设置value原生js是通过value属性来获取或者设置表单元素的值.\n\njQuery中通过val()来获取value值；\n\nval() --- 获取或设置表单元素的值，可以传入一个参数\n\t不传入参数时，为获取当前元素的value值\n    传入参数时，为设置当前元素的value值\n    \n    //1.val()方法,不给参数就是获取\n   console.log($('#txt').val()); \n\n\t//2.val()方法,给参数就是设置\n     $('#txt').val('我是设置的值');","categories":["jQuery"],"tags":["WEB前端"]},{"title":"jQuery学习第一天","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/10/jQuery学习第一天/","content":"jQuery介绍原生的JS存在一些缺点：\n​    1.不能添加多个入口函数，如果添加了多个后面的会覆盖前面的入口函数；\n​    2.原生JS的API名字太长；\n​    3.原生JS的有些API存在浏览器兼容问题；\n​    4.原生JS容错率较低，前面的代码出现了问题后面的代码就不会执行；\njQuery是什么：jQuery其实就是对原生JS的API进行了封装，是一个封装了很多原生JS方法的库；\njQuery的优势：\n​    1.可以添加多个入口函数；\n​    2.jQuery的API名字语义化程度高，便以理解和记忆；\n​    3.jQuery代码存在隐式迭代（遍历）和链式编程；\n​    4.jQuery代码容错率较高，前面的代码执行出错后续的代码依旧会执行；\njQuery版本1.x版本 – 兼容性最高，支持IE678，已经停止更新；\n2.x版本 – 不支持IE678，已经停止更新；\n3.x版本 – 不支持IE678，还在更新\n理解$和jQuery在引入jQuery文件以后，我们可以在全局作用域（window）上使用$；那么这个$是什么？\n先来查看jQuery文件的结构\n(function()&#123;\n    ...\n    window.jQuery = window.$ = jQuery;\n&#125;());\n\n上面的代码是jQuery文件的整体结构，可以看出jQuery文件里面是一个匿名自调用函数，而我们在网页中引入这个文件是就会执行一次这个文件（也就是执行了这个匿名自调用函数）；\n\n在这个函数的最后，可以看出执行了给全局window添加了一个$属性和jQuery属性，而他们的值都是jQuery文件中定义的一个函数；\n\n\nconsole.log(window.jQuery === window.$);//true\nconsole.log(Object.prototype.toString.call($));//'[object Function]'\n既然jQuery是一个函数，那么window.$对应的也是一个函数，所以我们在使用全局$属性是，需要传入参数使用；传入的参数不一样，函数执行的效果也不同；\n​    1.传入一个匿名函数时，将成为一个入口函数 $(function(){})\n​    2传入一个字符串，此时的效果可能是选择器或者创建一个标签：\n​        $(“div”)  — 选择所有的div元素\n​        $(‘我是一个div‘)；   //生成一个div标签；\n​    3.传入一个DOM对象，此时会将DOM对象转换成jQuery对象；\n​        var $jquery对象 = $(DOM对象);\nDOM对象和jQuery对象DOM对象 — 使用原生JS获取到的对象；该对象只能调用dom方法或属性；\njQuery对象 — 使用jQuery选择器获取的对象；该对象只能调用jQuery对象的方法或属性；\nDOM对象就是浏览器中的真实节点（元素节点，文本节点等）；\n\njQuery对象其实是一个伪数组（使用index表示key，具有length属性，可遍历），数组里面的value值就是DOM对象；\n\ndom对象转换成jQuery对象 ： var $one = $(one); //这里的one是dom对象，默认使用$开头来表示jQuery对象；\njQuery对象转换成dom对象：\n​    1.使用数组下标index  var div1 = $divs[0];  //这里表示从jQuery对象中取出第一个dom对象；\n​    2.使用jQuery.get() 方法：var div1 = $divs.get(0); //get()方法需要传入一个index；\njQuery入口函数jQuery入口函数有两种写法：\n//注意要先引入jQuery文件\n\n//方法1\n$(document).ready(function()&#123;\n    //...在这里书写脚本\n&#125;);\n\n//方法2\n$(function()&#123;\n    //...Code\n&#125;)\n\n//原生的入口函数\nwindow.onload = function()&#123;\n    ...code\n&#125;\n\n一个文件中可以同时存在jQuery入口函数和原生入口函数\n注意jQuery的入口函数与window.onload()入口函数的区别：\n​    1.jQuery入口函数可以书写对个，而原生的入口函数只能有一个；\n​    2.jQuery的入口函数执行时机早于原生的入口函数：jQuery入口函数在页面的DOM树加载完成后执行（页面上的DOM元素全部加载完成），而原生的入口函数需要等待页面的所有资源加载完成后才执行（包含DOM树，外部css，js链接图片等）；\njQuery点击事件jQuery的点击事件是一个函数，需要传入一个回调函数；\n\n//首先获取jQuery对象；\n\nvar $btn = $(\"#btn\");\n//给jQuery对象绑定点击事件，原生的点击事件使用on开头，而jQuery点击事件不需要；\n$btn.click (&#123;\n    console.log(\"触发按钮\");\n&#125;);\n\n注意，点击事件里面的this指向当前被触发的对象；\njQuery设置，获取文本内容使用text() 方法来设置/获取元素样式\n\n//首先获取jQuery对象\nvar $getBtn = $(\"#btn1\");\n//给jQuery对象绑定点击事件\n$getBtn.click(&#123;\n    //点击按钮时，输出div的文本，使用text()方法\n    //获取id名为box1的标签的文本\n    var text = $(\"#box1\").text();\n    //这里的text包含box1及其它的后代的文本\n&#125;);\n\n注意！！如果这里获取到的jQuery对象中包含多个dom对象，text()方法会依次获取这些dom对象的文本；\n\n$(\"#btn2\").click(function()&#123;\n    //给id名为box2的标签设置文本\n    $(\"#box2\").text(\"我是设置的文本\");\n&#125;);\n\n注意：text()方法不传入参数是为获取文本，一旦该方法传入字符串参数，该字符串将成为jQuery对象中所有dom对象的文本（如果原来存在文本也将会被替换），但是传入的字符串参数即使携带有html标签，也不会被解析成网页标签；\n所以可知text()方法类似原生js中的innerText属性；\njQuery设置，获取元素样式使用 css() 方法来设置/获取元素样式\n\nconsole.log($('#div1').css('width'));  //获取id名为div1的元素的宽\nconsole.log($('#div1').css('background-color')); //获取元素的背景\nconsole.log($('#div1').css('border'));  //获取元素的边框\n\n注意！ 在ie浏览器中，获取边框的样式需要指定具体的边框（top，right，bottom，left）\nconsole.log($('#div1').css('border-top-width'));\n\n注意！如果jQuery对象中包含多个dom对象，获取样式时，只会获取第一个dom对象的样式；\n\n给jQuery对象设置样式时，有以下两种方法：\n1.设置单样式  css(样式名，样式值);  样式名使用驼峰命名法或者-连接；样式值为不书写px时可以填数值而不是字符串\n$('#div1').css('width','300px');\n$('#div1').css('height',300);\n$('#div1').css('backgroundColor','red');\n$('#div1').css('border','10px solid green');\n\n2.设置多样式 css(&#123;\n    样式名:样式值;\n    ...\n&#125;);\n$('div').css(&#123;\n        width: 300,\n        'height': '300px',\n        'background-color': 'green',\n        'border': '10px solid red',\n        marginTop:10\n      &#125;);\n\n这设置样式display时，可以直接调用show()或者hide()方法，此时方法的返回值是当前设置样式的dom对象；\n$(this).children('ul').show();//show()方法本质上还是更新display属性为block.\n$(this).children('ul').hide(); //hide()方法本质上还是更新display属性为none\njQuery基本选择器// 基本选择器   和css里面的选择器是一样的\n   //  id选择器            $('#id')\n   //  类选择器            $(\".类名\")\n   //  标签选择器          $(\"标签名\")\n   //  并集选择器          $('.box,.box2')\n   //  交集选择器          $('li.current')\njQuery层次选择器\n\n\n名称\n用法\n描述\n\n\n\n子代选择器\n$(“ul&gt;li”);\n使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素\n\n\n后代选择器\n$(“ul li”);\n使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等\n\n\n获取id为father这个元素的所有子div.\nconsole.log($('#father > div'));\n\n获取id为father这个元素的所有子div以及所有子元素p.\nconsole.log($('#father>div , #father>p'));\n\n获取id为father这个div的所有后代div.\nconsole.log($('#father div'));\n\n获取id为father这个div的所有后代div,以及id为father这个div的所有后代span.\n console.log($('#fahter div , #father span'));\njQuery过滤选择器\n\n\n名称\n用法\n描述\n\n\n\n:eq（index）\n$(“li:eq(2)”).css(“color”, ”red”);\n获取到的li元素中，选择索引号为2的元素，索引号index从0开始。\n\n\n:odd\n$(“li:odd”).css(“color”, ”red”);\n获取到的li元素中，选择索引号为奇数的元素\n\n\n:even\n$(“li:even”).css(“color”, ”red”);\n获取到的li元素中，选择索引号为偶数的元素\n\n\njQuery筛选选择器\n\n\n名称\n用法\n描述\n\n\n\nchildren(selector)\n$(“ul”).children(“li”)\n相当于$(“ul&gt;li”)，子类选择器\n\n\nfind(selector)\n$(“ul”).find(“li”);\n相当于$(“ul li”),后代选择器\n\n\nsiblings(selector)\n$(“#first”).siblings(“li”);\n查找兄弟节点，不包括自己本身。\n\n\nparent()\n$(“#first”).parent();\n查找父亲\n\n\neq(index)\n$(“li”).eq(2);\n相当于$(“li:eq(2)”),index从0开始\n\n\nnext()\n$(“li”).next()\n找下一个兄弟\n\n\nprev()\n$(“li”).prev()\n找上一次兄弟\n\n\njQuery鼠标事件1.不推荐使用：\n​    mouseover()  — 鼠标移入事件，需要传入一个回调函数\n​    mouseleave() — 鼠标离开事件，需要传入一个回调函数\n2.推荐使用：\n​    mouseenter() — 鼠标移入事件，需要传入一个回调函数\n​    mouseout() — 鼠标离开事件，需要传入一个回调函数\n以上鼠标事件方法的区别：mouseover在从目标元素进入目标元素的子元素时依旧会再次触发鼠标移入事件，而mouseenter只要是在目标元素内就只会触发一次，不管是否进入目标元素的子元素；\nmouseleave()和mouseout()和各自对应的鼠标移入方法（mouseover()和mouseenter()）效果一致；\n$('.wrap>ul>li').mouseover(function () &#123;\n      //console.log(this);//谁触发了鼠标移入事件,那这个this就是谁,this还是一个dom对象.\n      // $(this).children('ul').css('display','block');//显示就是更改display属性为block.\n      $(this).children('ul').show();//show()方法本质上还是更新display属性为block.\n    &#125;);\n\n    //2.给一级菜单li设置鼠标离开事件，二级菜单隐藏。\n    $('.wrap>ul>li').mouseout(function () &#123;\n      $(this).children('ul').hide(); //hide()方法本质上还是更新display属性为none\n    &#125;);\n\nmouseover  事件在鼠标移动到选取的元素及其子元素上时触发 。\nmouseenter 事件只在鼠标移动到选取的元素上时触发。\n\n建议使用mouseenter()和mouseout()方法来实现自定义鼠标事件\n\n $('.wrap>ul>li').mouseenter(function () &#123;\n      i++;\n      console.log(i);\n      $(this).children('ul').show();\n    &#125;);\n\n    //2.给一级菜单li设置鼠标离开事件，二级菜单隐藏。\n    $('.wrap>ul>li').mouseleave(function () &#123;\n       $(this).children('ul').hide();\n    &#125;);\n获取当前被触发元素的索引 var idx = $(this).index();//索引:表示的是这个元素在他兄弟元素间的排行.\n","categories":["jQuery"],"tags":["WEB前端"]},{"title":"async函数","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/10/async函数/","content":"介绍在ES2017中引入async函数，能够使得异步操作变得更加简单方便。\n本质上async函数就是Generator函数（生成器函数）的简化。\n//下面有一个Generator函数，依次读取两个文件\nconst fs = require('fs');\n\nconst readFile = function (fileName) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    fs.readFile(fileName, function(error, data) &#123;\n      if (error) return reject(error);\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;;\n\nconst gen = function* () &#123;\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n\n//将上面的Generator函数gen()修改成async函数：\nconst asyncReadFile = async function () &#123;\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n可以看出，async函数就是将Generator函数的标志 * 替换成 关键字async，将Generator函数里的关键字yield替换成关键字await，其他的作用是一致的。\nasync函数对比Generator函数的改进1.内置执行器：Generator函数的执行需要靠执行器，而async函数自带执行器，async函数一旦调用就会自动执行，并输出最后的结果（而Generator函数调用后只是返回遍历器对象，需要使用遍历器对象的next(）来是函数执行）；\n2.更好的语义：async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n3.适用性更广：yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n4.返回值是Promise：async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\nfunction timeout(ms) &#123;\n  return new Promise((resolve) => &#123;\n    setTimeout(resolve, ms);\n  &#125;);\n&#125;\n\nasync function asyncPrint(value, ms) &#123;\n  await timeout(ms);\n  console.log(value);  //该语句会在await timeout执行后才输出\n&#125;\n\nasyncPrint('hello world', 50);\n//上面代码指定 50 毫秒以后，输出hello world。\n语法async函数内部return语句返回的值，会成为then方法回调函数的参数。\nasync function f() &#123;\n  return 'hello world';\n&#125;\n\nf().then(v => console.log(v))\n// \"hello world\"\n\n上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。\n\nasync函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。\n抛出的错误对象会被catch方法回调函数接收到。\n\nasync function f() &#123;\n  throw new Error('出错了');\n&#125;\n\nf().then(\n  v => console.log('resolve', v),\n  e => console.log('reject', e)\n)\n//reject Error: 出错了\nPromise对象的状态变化async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\nawait命令await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。\nasync function f() &#123;\n  // 等同于\n  // return 123;\n  return await 123;  // await命令后返回的结果不是一个 Promise 类型的对象, \n                     //返回的结果就是一个成功 Promise 对象\n&#125;\n\nf().then(v => console.log(v))\n// 123\nawait命令后面是一个thenable对象（即定义了then方法的对象），那么await会将其等同于 Promise 对象。\nawait命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\nasync function f() &#123;\n  await Promise.reject('出错了');\n&#125;\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n\n任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。\n\nasync function f() &#123;\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n&#125;\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。\n这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，\n第二个await都会执行。\n防止出错的方法，也是将其放在try…catch代码块之中。\nasync function f() &#123;\n  try &#123;\n    await new Promise(function (resolve, reject) &#123;\n      throw new Error('出错了');\n    &#125;);\n  &#125; catch(e) &#123;\n  &#125;\n  return await('hello world');\n&#125;\n\n如果有多个await命令，可以统一放在try...catch结构中。\nasync function main() &#123;\n  try &#123;\n    const val1 = await firstStep();\n    const val2 = await secondStep(val1);\n    const val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  &#125;\n  catch (err) &#123;\n    console.error(err);\n  &#125;\n&#125;\n\n总结：await命令后面的Promise对象，运行结果可能是rejected，\n\t所以最好把await命令放在try...catch代码块中。\n多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\nlet foo = await getFoo();\nlet bar = await getBar();\n\n上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。\n这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。\nawait命令只能用在async函数之中，如果用在普通函数，就会报错。\nasync function dbFuc(db) &#123;\n  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];\n\n  // 报错\n  docs.forEach(function (doc) &#123;\n    await db.post(doc);\n  &#125;);\n&#125;\n注意：async函数内部不一定需要使用await关键字，但是如果使用了await关键字那这个函数必须是async函数。\nasync函数封装AJAX请求//定义一个发送AJAX请求的函数，规定其返回结果是一个Promise对象\nfunction sendAJAX(url)&#123;\n    return new Promise(function(resolve,reject)&#123; \n    //先创建一个XMLHttpRequest对象\n    const ajax = new XMLHttpRequest();\n    \n    //初始化AJAX对象\n    ajax.open('GET',url);\n    \n    //发送ajax请求\n    ajax.send();\n    \n    //事件绑定 -- 监听ajax的请求状态\n    ajax.onreadystatechange = function()&#123;\n        if(ajax.readyState === 4)&#123;\n            if(ajax.status >= 200 &amp;&amp; ajax.status &lt; 300)&#123;\n                resolve(ajax.response);\n            &#125;else&#123;\n                reject(ajax.status);\n            &#125;\n        &#125;\n      &#125;\n   &#125;)\n&#125;\n                       \n//定义一个包含异步请求的async函数\nasync function getData(url)&#123;\n        try&#123;\n            let result = await sendAJAX(url);\n            //await能自动获取成功的Promise的value值\n            rrtuen result;\n        &#125;\n        catch(e)&#123;\n            return new Promise(new Error(\"error\"));\n        &#125;\n    &#125;\nlet data = getData(\"https://v1.hitokoto.cn\");\ndata.then((value) => &#123;\n    console.log(JSON.parse(value));\n&#125;,(reason) => &#123;\n    console.error(reason);\n&#125;);","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"Module语法","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/10/Module语法/","content":"ES6之前，JS一直没有模块（module）体系，之前社区制定的模块化加载方案主要是CommonJS和AMD；前者用于服务器，后者用于浏览器。\n\nES6在语言标准层面上实现了模块化，完全可以取代 CommonJS 和 AMD 规范，\n成为浏览器和服务器通用的模块解决方案。\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，\n以及输入和输出的变量。\n\nES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\n// ES6模块\nimport &#123; stat, exists, readFile &#125; from 'fs';\n\n上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者\n静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当\n然，这也导致了没法引用 ES6 模块本身，因为它不是对象。\n\n目前并不是所有浏览器都支持ES6模块格式，但是我们在生产开发时仍然可以使用该语法，在项目上线发布时可以通过其他的工具库，入Babel和webpack等将ES6语法转换成浏览器支持的ES5语法；\nexport命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。\n// profile.js\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n\n上面的profile文件被ES6视为一个模块，里面使用export命令对外部输出了三个变量。\n\n也还可以采用下面这种方法对外部输出（推荐使用，能比较直观的看到该模块输出了哪些变量）：\n// profile.js\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport &#123; firstName, lastName, year &#125;;\nexport命令除了输出变量，还可以输出函数或类（class）；\nexport function fun()&#123;\n    console.log(\"hello\");\n&#125;\n\n一般情况下export输出的变量就是在模块中定义的名字，但也可以使用as关键字重命名\nfunction v1() &#123; ... &#125;\nfunction v2() &#123; ... &#125;\n\nexport &#123;\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n&#125;;\n上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，\nv2可以用不同的名字输出两次。\n！！！需要注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一对一的关系；下面的代码这样使用就会报错：\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n\n第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，\n不是接口。正确的写法是下面这样。\n\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport &#123;m&#125;;\n\n// 写法三\nvar n = 1;\nexport &#123;n as m&#125;;\n\n总结：对外export应该是一个接口，不能直接export一个值或者一个变量（需要使用&#123;变量&#125;）\n\n同样的，function和class的输出，也必须遵守这样的写法。\nexport语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，\n可以取到模块内部实时的值。这一点与 CommonJS 规范完全不同。CommonJS 模块\n输出的是值的缓存，不存在动态更新；\n注意！！！export命令和import命令不能出现在块级作用域内，该命令只能出现在当前模块文件的顶层作用域（最外层），至于在顶层作用域的哪个位置都可以；\nimport命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。\n// main.js\nimport &#123; firstName, lastName, year &#125; from './profile.js';\n\nfunction setName(element) &#123;\n  element.textContent = firstName + ' ' + lastName;\n&#125;\n\n上面代码的import命令，用于加载profile.js文件，并从中输入变量。\nimport命令接受一对大括号，里面指定要从其他模块导入的变量名。\n大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。\n\n如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。\nimport &#123; lastName as surname &#125; from './profile.js';\n\nimport命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，\n不允许在加载模块的脚本里面，改写接口。\nimport &#123;person&#125; from './xxx.js';\nperson = &#123;&#125;;  //报错 在这里试图修改接口但是import的接口是只读的不允许修改\n\n上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。\n但是，如果a是一个对象，改写a的属性是允许的。\nimport &#123;a&#125; from './xxx.js'\n\na.foo = 'hello'; // 合法操作\n\na的属性可以成功改写，并且其他模块也可以读到改写后的值（！！！）。\n不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。\nimport后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。\n注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。（本质是import命令是编译阶段执行的，在代码运行之前。）\nimport是静态执行，所以不能使用表达式和变量（因为import命令是在编译阶段，变量和表达式需要在代码执行阶段，所以不能正确获得值）\nimport语句会执行所加载的模块，因此可以有下面的写法\nimport 'lodash';\n\n上面代码仅仅执行lodash模块，但是不输入任何值。（在这里相当于在当前文件执行前先执行了一遍lodash文件，但是lodash文件执行后的结果不会影响当前文件）\n\n如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\n\nimport &#123; foo &#125; from 'my_module';\nimport &#123; bar &#125; from 'my_module';\n\n// 等同于\nimport &#123; foo, bar &#125; from 'my_module';\n\n上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module模块。\n也就是说，import语句是 Singleton 模式。\n\n模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，\n所有输出值都加载在这个对象上面。\n// circle.js  分别export当前模块的两个方法\n\nexport function area(radius) &#123;\n  return Math.PI * radius * radius;\n&#125;\n\nexport function circumference(radius) &#123;\n  return 2 * Math.PI * radius;\n&#125;\n\n//加载模块\n\n// main.js  --- 分别加载\n\nimport &#123; area, circumference &#125; from './circle';\n\nconsole.log('圆面积：' + area(4));\nconsole.log('圆周长：' + circumference(14));\n\n//上面的代码可以修改成整体加载\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n\n注意整体加载的对象应该是静态分析，不允许运行时改变：\nimport * as circle from './circle';\n\n// 下面两行都是不允许的\ncircle.foo = 'hello';\ncircle.area = function () &#123;&#125;;\nexport default命令为了给用户提供方便，可以使用export default命令为模块指定默认输出；\n// export-default.js\nexport default function () &#123;\n  console.log('foo');\n&#125;\n\n上面代码是一个模块文件export-default.js，它的默认输出是一个函数。\n其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n\n需要注意的是，这时import命令后面，不使用大括号（默认暴露不需要&#123;&#125;）。\n\nexport default命令用在非匿名函数前，也是可以的。然而在模块外部是无效的。\n加载的时候，视同匿名函数加载。\n\nexport default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此\nexport default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一\n对应export default命令。\n\n本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意\n名字。\n\n正是因为export default命令其实只是输出一个叫做default的变量，\n所以它后面不能跟变量声明语句。\n\n// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n\n同样地，因为export default命令的本质是将后面的值，赋给default变量，\n所以可以直接将一个值写在export default之后。\n\n// 正确\nexport default 42;\n\n// 报错\nexport 42;\n上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为default。\n\n注意！！在一个模块中可以有一个默认暴露和多个分别暴露\n//lodash.js\nexport default function (obj) &#123;\n  // ···\n&#125;\n\nexport function each(obj, iterator, context) &#123;\n  // ···\n&#125;\n\nexport &#123; each as forEach &#125;;\n//main.js -- 加载默认暴露和分别暴露\nimport _, &#123; each, forEach &#125; from 'lodash';\n\n在上面的代码中，分别暴露forEach和each指向同一个方法。\n\nexport default也可以用来输出类。\n// MyClass.js\nexport default class &#123; ... &#125;\n\n// main.js\nimport MyClass from 'MyClass';\nlet o = new MyClass();\n跨模块常量const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。\n// constants.js 模块\nexport const A = 1;\nexport const B = 3;\nexport const C = 4;\n\n// test1.js 模块\nimport * as constants from './constants';\nconsole.log(constants.A); // 1\nconsole.log(constants.B); // 3\n\n// test2.js 模块\nimport &#123;A, B&#125; from './constants';\nconsole.log(A); // 1\nconsole.log(B); // 3\nimport()函数处理import语句是在编译时，而不是在分析或执行语句时。导致了无法在运行时加载模块；\nES2020引入import()函数，支持动态加载模块；\nimport(specifier)\n\n上面代码中，import函数的参数specifier，指定所要加载的模块的位置。\nimport命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。\n\nimport()返回一个 Promise 对象\nconst main = document.querySelector('main');\n\nimport(`./section-modules/$&#123;someVariable&#125;.js`)\n  .then(module => &#123;\n    module.loadPageInto(main);\n  &#125;)\n  .catch(err => &#123;\n    main.textContent = err.message;\n  &#125;);\n\nimport()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，\n也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，\n这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。\n浏览器加载脚本传统方法HTML 网页中，浏览器通过标签加载 JavaScript 脚本。\n默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。\n如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。\n&lt;script src=\"path/to/myModule.js\" defer>&lt;/script>\n&lt;script src=\"path/to/myModule.js\" async>&lt;/script>\n\n上面代码中，&lt;script>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，\n就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。\n\ndefer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），\n才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。\n一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，\n会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。\n浏览器加载ES6模块浏览器加载 ES6 模块，也使用标签，但是要加入type=\"module\"属性。\n&lt;script type=\"module\" src=\"./foo.js\">&lt;/script>\n\n浏览器对于带有type=\"module\"的&lt;script>，都是异步加载，不会造成堵塞浏览器，\n即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script>标签的defer属性。\n    \n&lt;script type=\"module\" src=\"./foo.js\">&lt;/script>\n&lt;!-- 等同于 -->\n&lt;script type=\"module\" src=\"./foo.js\" defer>&lt;/script>\n\nES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。\n&lt;script type=\"module\">\n  import utils from \"./utils.js\";\n\n  // other code\n&lt;/script>\nES6模块与CommonJS模块之间的差异CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。\nCommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\nES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\nES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。\n由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。\n简易使用Babel和browserify工具安装：npm i babel-cli babel-preset-env browserify -D\n1.不是所有的浏览器都支持ES6语法，所以我们需要使用Babel来将使用ES6语法文件转换成浏览器支持的ES5语法文件；\n\n​    编译 npx babel src/js -d dist/js –presets=babel-preset-env（该命令将src/js文件夹下的所有ES6模块文件转换成ES5语法表示的模块化文件，并存放到文件夹dist/js目录下）\n注意！以后每次修改了使用ES6语法的文件都需要重新使用Babel转换生成对应的ES5语法文件；\n2.一般在开发时为了实现代码的复用，都会将每个模块独立成一个文件，在app.js文件中import已经开发好的Module文件，但是ES6中的import语法并不是所有浏览器都兼容，所以需要是使用browserify工具将主文件app.js转换成ES5语法的app.js;（也就是说我们在HTML的script标签中直接引入Babel生成的app.js文件时，浏览器也是无法解析该JS脚本的，因为里面包含CommonJS规范，所以需要browserify将该文件编译成浏览器可用的模块）\n\n也就是使用ES5语法中require等语法编写的脚本仍然无法直接被浏览器所使用。\n\n 转换命令： npx browserify dist/js/app.js -o dist/bundle.js\n编译好的bundle.js文件就可以直接在html网页中引用；\n","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"Class类","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/08/Class类/","content":"类的介绍在JS中，生成实例对象的传统方法是通过构造函数，如下：\nfunction Person(name,age)&#123;\n    this.name = name;\n    this.age = age;\n&#125;\nPerson.prototype.hello = function()&#123;\n    console.log(\"hello\");\n&#125;\n\nconst person = new Person(\"LK\",20);\nconsole.log(person.name);  //LK\nperson.hello(); // hello\n在ES6中提供了更接近传统语言的写法，引入了Class（类）的概念，作为对象的模板。可以通过class关键字定义一个类。\nclass Person &#123;\n    //构造类，名字是固定的，用户使用new关键字调用class时会自动执行该函数\n    constructor(name,age)&#123;\n        //constructor里的this指向新建的实例对象\n        this.name = name;\n        this.age = age;\n    &#125;\n    \n    //ES6中规定class中的方法必须这样书写，不能采用键值对的方法。\n    //这里定义的方法，可以在实例的原型对象身上找到\n    //方法与方法之间不能添加逗号间隔开\n    hello()&#123;\n        console.log(\"hello\");\n    &#125;\n    \n    //构造函数的prototype属性，在 ES6 的“类”上面继续存在。\n    //事实上，类的所有方法都定义在类的prototype属性上面。\n&#125;\n\n//使用class创建实例时，也是使用new关键字，用法和构造函数一致\nconst person = new Person(\"LK\",20);\nconsole.log(person);\nperson.hello();\n\n//因此，在类的实例上面调用方法，其实就是调用原型上的方法。\n/*\n在上面代码中，person是Person类的实例，person实例的constructor方法就是Perosn类原型的constructor方法，这一点和以前ES5中，实例对象的constructor方法指向构造函数一致；\n*/\n\n另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\nclass Point &#123;\n  constructor(x, y) &#123;\n    // ...\n  &#125;\n\n  toString() &#123;\n    // ...\n  &#125;\n&#125;\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n\n上面代码中，toString()方法是Point类内部定义的方法，它是不可枚举的。\n这一点与 ES5 的行为不一致。\nvar Point = function (x, y) &#123;\n  // ...\n&#125;;\n\nPoint.prototype.toString = function () &#123;\n  // ...\n&#125;;\n\nObject.keys(Point.prototype)\n// [\"toString\"]\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n\n\n注意：class和构造函数不同的是在定义class是不能使用()接受参数，接受参数应该是class的constructor方法；\nconstructor方法constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。\n一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。\n\nclass Point &#123;\n&#125;\n\n// 等同于\nclass Point &#123;\n  constructor() &#123;&#125;\n&#125;\n\nconstructor()方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\n\nclass Foo &#123;\n  constructor() &#123;\n    return Object.create(null);\n  &#125;\n&#125;\n\nnew Foo() instanceof Foo  // false\n\n类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\n类的实例生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。\n与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）\nclass Person&#123;\n    constructor(name,age)&#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n    \n    hello()&#123;\n        console.log(\"Hello\")\n    &#125;\n&#125;\n\nconst person = new Person(\"LK\",20);\nconsole.log(person.hasOwnProperty(\"name\")); // true\nconsole.log(person.hasOwnProperty(\"hello\"));  // false\nconsole.log(person.__proto__.hasOwnProperty(\"hello\")); //true\n\n与 ES5 一样，类的所有实例共享一个原型对象。\n\nconst person2 = new Person(\"ZK\",20);\n\nconsole.log(person.__proto__ === person2.__proto__);  // true\n\n这也意味着，可以通过实例的__proto__属性为“类”添加方法。\n\n__proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，\n虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，\n避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法\n来获取实例对象的原型，然后再来为原型添加方法/属性。\n取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，\n拦截该属性的存取行为。\n\nclass Person &#123;\n    constructor(name,age)&#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n    \n    get name()&#123;\n        console.log(\"拦截到获取name属性\");\n        //return this.name;\n    &#125;\n    \n    set name(value)&#123;\n        console.log(\"拦截到正在修改name属性值\");\n        // this.name = value;\n    &#125;\n&#125;\n\nconst person = new Person(\"LK\",20);\nconsole.log(person.name);\nperson.name = \"ZK\";\nconsole.log(person.name);\n\n//在上面的代码中，name属性有对应的getter和setter，因此赋值和读取行为都会触发用户自定义的函数；\n在上面的代码中，constructor方法中给class天添加属性值时也会触发到用户相对应的自定义setter；\n但是如果在getter和setter中使用 this.name 是就会报错！！！原因如下：\n\n/**\n* 　　这是因为，在构造函数中执行this.name=name的时候，就会去调用set name，\n* 　　在set name方法中，我们又执行this.name = name，进行无限递归，\n* 　　最后导致栈溢出(RangeError)。\n* */\n\n我们可以采取下面的方法解决：\n\nclass Person&#123;\n    constructor(name,age)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    \n    set name(value)&#123;\n        console.log(\"拦截到设置name属性\");\n        this._name = value; //关键点在这里，构造函数在设置name属性值时，其实设置的是_name属性\n    &#125;\n    \n    get name()&#123;\n        console.log(\"拦截到获取name属性\");\n        return this._name;  //获取的实际是对象身上的_name属性值\n    &#125;\n&#125;\n\nconst person = new Person(\"LK\",20);\nconsole.log(person);\nconsole.log(person.name);\nperson.name = \"ZK\";\nconsole.log(person.name);\n\n可以看到此时是可以正常运行的；\n\n/**\n* 总结：\n* 　　当一个属性只有getter没有setter的时候，我们是无法进行赋值操作的（第一次初始化也不行），\n\t\t这一点需要注意\n* 　　当没有getter和setter时，就可以正常读写属性\n* */\n\nclass Person&#123;\n    constructor(name,age)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    \n    get name()&#123;\n        console.log(\"拦截到获取name属性\");\n        return this._name;  //获取的实际是对象身上的_name属性值\n    &#125;\n&#125;\n\nconst person = new Person(\"LK\",20);  //报错\n\n属性表达式类的属性名，可以采用表达式。\nlet methodName = 'getArea';\n\nclass Square &#123;\n  constructor(length) &#123;\n    // ...\n  &#125;\n\n  [methodName]() &#123;\n    // ...\n  &#125;\n&#125;\n上面代码中，Square类的方法名getArea，是从表达式得到的。\nclass表达式与函数一样，类也可以使用表达式的形式定义。\nconst MyClass = class Me &#123;\n  getClassName() &#123;\n    return Me.name;\n  &#125;\n&#125;;\n\nconst my = new MyClass();\nconsole.log(my);  /*   Me &#123;&#125;\n                          [[Prototype]]: Object\n                    */\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，\n指代当前类。在 Class 外部，这个类只能用MyClass引用。\n注意点1.类不存在变量提升（hoist），这一点与 ES5 完全不同。（构造函数使用Function关键字会变量提升）\n\n2.由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。\nclass Point &#123;&#125;\nPoint.name // \"Point\"\nname属性总是返回紧跟在class关键字后面的类名。\n\n3.this 的指向：类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，\n一旦单独使用该方法，很可能报错。\n静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\nclass Person&#123;\n    static hello()&#123;\n        console.log(\"hello\");\n    &#125;\n&#125;\n\nconst person = new Person();\nPerson.hello();  // hello\nconsole.log(person);  // Person(Object)\nperson.hello();  // 报错 Uncaught TypeError: person.hello is not a function\n\n\n在上面的代码中，Person类的hello方法前使用static 关键字，表明这个方法是一个静态方法，只能通过Person类来调用，不能通过Person的实例对象来调用。\n\n注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。\nclass Foo &#123;\n  static bar() &#123;\n    this.baz();  //这里在静态方法中使用this，此时this指的应该是Foo类，而不是Foo的实例\n  &#125;\n  static baz() &#123;\n    console.log('hello');\n  &#125;\n  baz() &#123;\n    console.log('world');\n  &#125;\n&#125;\n\nFoo.bar() // hello\n\n上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\n父类的静态方法，可以被子类继承。\nclass Foo &#123;\n  static classMethod() &#123;\n    return 'hello';\n  &#125;\n&#125;\n\nclass Bar extends Foo &#123;\n&#125;\n\nBar.classMethod() // 'hello'\n实例属性的新写法属性也可以定义在类的最顶层，其他都不变。\nclass IncreasingCounter &#123;\n  _count = 0;\n  get value() &#123;\n    console.log('Getting the current value!');\n    return this._count;\n  &#125;\n  increment() &#123;\n    this._count++;\n  &#125;\n&#125;\nconst my = new IncreasingCounter();\nconsole.log(my);\nconsole.log(my.hasOwnProperty(\"_count\")); // true\n\n上面代码中，实例属性_count与取值函数value()和increment()方法，处于同一个层级。\n这时，不需要在实例属性前面加上this。\n \n定义在constructor顶层的属性将成为实例对象自身的属性，而在类中定义的普通方法是在\n该实例对像的原型对象身上的。\n静态属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。\nclass Foo &#123;\n&#125;\n\nFoo.prop = 1;  // 旧的写法，类的静态属性定义在类的外部\nFoo.prop // 1\n\n\nclass MyClass &#123;\n  static myStaticProp = 42;  // 新的写法 在实例属性的前面，加上static关键字。\n\n  constructor() &#123;\n    console.log(MyClass.myStaticProp); // 42\n  &#125;\n&#125;\n私有属性有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。\nclass IncreasingCounter &#123;\n  #count = 0;\n  get value() &#123;\n    console.log('Getting the current value!');\n    return this.#count;\n  &#125;\n  increment() &#123;\n    this.#count++;\n  &#125;\n&#125;\n\nconsole.log(IncreasingCounter.#count);  // 报错  Private field '#count' must be declared in an enclosing class\nconst counter = new IncreasingCounter();\ncounter.#count // 报错\ncounter.#count = 42 // 报错\n\n上面代码中，#count就是私有属性，只能在类的内部使用（this.#count）。\n如果在类的外部使用，就会报错。\n\n只要在类的外部，读取私有属性，就会报错。即使是通过class类来访问；\n\n虽然实例不能在外部访问私有属性，但是类的私有属性也会被添加到实例对象的身上；\nin运算符in运算符判断当前类A的实例，是否有私有属性#foo，如果有返回true，否则返回false。\nclass A &#123;\n    #foo = 0;\n  use(obj) &#123;\n    if (#foo in obj) &#123;\n      // 私有属性 #foo 存在\n        return true;\n    &#125; else &#123;\n      // 私有属性 #foo 不存在\n        return false;\n    &#125;\n  &#125;\n&#125;\nconst a = new A();\nconsole.log(a.use(a));  // true\n\nClass的继承Class 可以通过extends关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。\n\nclass Point &#123;\n&#125;\n\nclass ColorPoint extends Point &#123;\n    constructor(x, y, color) &#123;\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  &#125;\n\n  toString() &#123;\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  &#125;\n&#125;\n\n上面示例中，constructor()方法和toString()方法内部，都出现了super关键字。\nsuper在这里表示父类的构造函数，用来新建一个父类的实例对象。\n\nES6 规定，子类必须在constructor()方法中调用super()，否则就会报错。这是因为子类自己的this对象，\n必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，\n添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象。\n\n为什么子类的构造函数，一定要调用super()？原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，\n是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。\nES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，\n即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用super()方法，因为这一步会生成一个\n继承父类的this对象，没有这一步就无法继承父类。\n\n注意，这意味着新建子类实例时，父类的构造函数必定会先运行一次。\n\nclass Person &#123;\n    constructor(name,age)&#123;\n        this.name = name;\n        this.age = age;\n        console.log(\"Person类的构造函数执行了\");\n    &#125;\n    \n    hello()&#123;\n        console.log(\"hello\");\n    &#125;\n&#125;\n\nclass Student extends Person&#123;\n    constructor(name,age,school,grade)&#123;\n        super(name,age);\n        this.school = school;\n        this.grade = grade;\n        console.log(\"Student类的构造函数执行了\");\n    &#125;\n&#125;\n\nconst student  = new Student(\"LK\",20,\"HZU\",\"four\");\nconsole.log(student);\n\nstudent.hello(); // hello  hello\nconsole.log(student.hasOwnProperty(\"hello\"));  // false\nconsole.log(student.__proto__ instanceof Person); // true\nconsole.log(student.__proto__.__proto__.hasOwnProperty(\"hello\"));  //true\n\n\n在上述实例Student对象时，必须先要执行一次其父类的构造函数；\n其次，父类身上的方法是在其实例对象的隐式原型对象身上的，所以子类继承了该父类，子类的隐式原型对象应该是其父类的一个实例，而父类的方法应该在子类的隐式原型的隐式原型身上；\n\n另一个需要注意的地方是，在子类的构造函数中，只有调用super()之后，才可以使用this关键字，\n否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有super()方法才能让子类实例继承父类。\nclass Point &#123;\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n&#125;\n\nclass ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    //this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  &#125;\n&#125;\n\n如果子类没有定义constructor()方法，这个方法会默认添加，并且里面会调用super()。也就是说，不管有没有显式定义，任何一个子类都有constructor()方法。\n\n除了私有属性，父类的所有属性和方法，都会被子类继承，其中包括静态方法。\n子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用。\nclass Foo &#123;\n  #p = 1;\n  #m() &#123;\n    console.log('hello');\n  &#125;\n&#125;\n\nclass Bar extends Foo &#123;\n  constructor() &#123;\n    super();\n    console.log(this.#p); // 报错\n    this.#m(); // 报错\n  &#125;\n&#125;\nObject.getPrototypeOf()Object.getPrototypeOf()方法可以用来从子类上获取父类。\nclass Point &#123; /*...*/ &#125;\n\nclass ColorPoint extends Point &#123; /*...*/ &#125;\n\nObject.getPrototypeOf(ColorPoint) === Point\n// true\nsuper关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\n​    第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，\n因此super()在这里相当于A.prototype.constructor.call(this)。\n作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。\n​    第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\nclass A &#123;\n  p() &#123;\n    return 2;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    console.log(super.p()); // 2\n  &#125;\n&#125;\n\nlet b = new B();\n\n上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\n\n这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。\n如果属性定义在父类的原型对象上，super就可以取到。\n\nES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。\n\nclass A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n  print() &#123;\n    console.log(this.x);\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n  &#125;\n  m() &#123;\n    super.print();\n  &#125;\n&#125;\n\nlet b = new B();\nb.m() // 2\n\n由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\n\n在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。\n类的prototype属性和__proto__属性Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。\n（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\nclass A &#123;\n&#125;\n\nclass B extends A &#123;\n&#125;\n\nB.__proto__ === A // true  子类的__proto__ 指向 父类\nB.prototype.__proto__ === A.prototype // true  子类的prototype的__proto__ 指向父类的prototype\n\n这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"数值扩展-Set-Map","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/07/数值扩展-Set-Map/","content":"数值扩展二进制和八进制表示法ES6 中提供了二进制和八进制的新写法，使用前缀 0b(或0B)表示二进制，0o（或0O）表示八进制；\n\nconsole.log(0b10 === 2);  // true\nconsole.log(0o7 === 7);   //true\n\n如果要将0b和0o前缀的字符串数值转为十进制，需要使用Number方法\nconsole.log(Number('0b10'));  // 2\nconsole.log(Number('0o7'));  // 7\nNumber.isFinite(),Number.isNaN()Number.isFinite() 是用来检查一个数值是否为有限的，既不是infinity\nNumber.isFinite(1);  // true\nNumber.isFinite(1.5); // true\nNumber.isFinite(Infinity); // false\nNumber.isFinite(NaN);  // false\nNumber.isFinite(Math.PI);  // true 在JS中PI是被固定大小的 3.141592653589793\n\n如果参数类型不是数值一律返回false；\nconsole.log(Number.isFinite('LK'));  // false\n\nNumber.isNaN()用来检查一个值是否为NaN。\n如果参数类型不是NaN，Number.isNaN一律返回false。\n\nisFinite(25) // true\nisFinite(\"25\") // true\nNumber.isFinite(25) // true\nNumber.isFinite(\"25\") // false\n\nisNaN(NaN) // true\nisNaN(\"NaN\") // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(\"NaN\") // false\nNumber.isNaN(1) // false\n\n它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。\n\n总结：全局isFinite()和isNaN()方法当传入非数值时，会先进行隐式转换（类似==），而Number.isNaN()和Number.isFinite()不会进行隐式转换（类似 ===）\nNumber.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。\n\n// ES5的写法\nparseInt('12.34') // 12\nparseFloat('123.45#') // 123.45\n\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\n\n总结：功能和以前全局上的一致，这样做可以逐步减少全局性方法，使得语言逐步模块化。\nNumber.isInteger()Number.isInteger()用来判断一个数值是否为整数。\n\nNumber.isInteger(25) // true\nNumber.isInteger(25.1) // false\n\n在JS内部，整数和浮点数采用的是同样的储存方法，所以25和25.0被视为同一个值；\nNumber.isInteger(25) // true\nNumber.isInteger(25.0) // true\n\n如果参数不是数值，Number.isInteger返回false。\nNumber.isInteger() // false\nNumber.isInteger(null) // false\nNumber.isInteger('15') // false\nNumber.isInteger(true) // false\n\nJS采用IEEE754标准，数值存储为64位双精度格式，数值精度最多可以达到53个二进制位。如果数值的精度炒超过这个限度会被丢弃，此时Number.isInteger()会出现误判\nNumber.isInteger(1.0000000000000000001);  // true\n\nJS能够分辨的最小绝对值Number.MIN_VALUE = 5E-324 ，当一个数小于这个值时，JS会将这个这个数自动转为0；\nNumber.isInteger(5E-324) // false\nNumber.isInteger(5E-325) // true\n\n总结：如果对数据的进度要求很高，不建议采用Number.isInteger()判断一个数是否为整数；\nNumber.EPSILONS6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，\n它表示 1 与大于 1 的最小浮点数之间的差。\n\n对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，\n小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。\n\nNumber.EPSILON === Math.pow(2, -52) // true\n\nNumber.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，\n就可以认为已经没有意义了，即不存在误差了。\n\n引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。\n\nconsole.log(0.1 + 0.2 === 0.3); // false\n\nconsole.log(0.1+0.2-0.3 &lt;= Number.EPSILON);  // true 为true可认为第一个计算式为0\nNumber.isSafeInteger()JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，\n无法精确表示这个值。\n\nconsole.log(Math.pow(2, 53));  // 9007199254740992\nconsole.log(9007199254740992); // 9007199254740992\nconsole.log(9007199254740992 + 1); // 9007199254740992\n\nES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，\n用来表示这个范围的上下限。\n\nNumber.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。\n这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。\n\nNumber.isSafeInteger('a') // false\nNumber.isSafeInteger(null) // false\nNumber.isSafeInteger(NaN) // false\nNumber.isSafeInteger(Infinity) // false\nNumber.isSafeInteger(-Infinity) // false\n\nNumber.isSafeInteger(3) // true\nNumber.isSafeInteger(1.2) // false\nNumber.isSafeInteger(9007199254740990) // true\nNumber.isSafeInteger(9007199254740992) // false\n\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false\nMath对象扩展ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，\n只能在 Math 对象上调用。\n\n1.Math.trunc方法用于去除一个数的小数部分，返回整数部分。\n\n2.Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。\n如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。\n它会返回五种值。\n\n\t参数为正数，返回+1；\n\t参数为负数，返回-1；\n\t参数为 0，返回0；\n\t参数为-0，返回-0;\n\t其他值，返回NaN。\n\n3.Math.cbrt()方法用于计算一个数的立方根。\n对于非数值，Math.cbrt()方法内部也是先使用Number()方法将其转为数值。\nSet数据结构基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet本身是一个构造函数，用来生成 Set 数据结构。\n\nconst set = new Set();\n\nconst arr = [2,4,2,3,1,3,4,1,5];\narr.forEach((item) => &#123;\n    set.add(item);\n&#125;);\n\nconsole.log(set);  // Set(5) &#123;2, 4, 3, 1, 5&#125;\n\n上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\n\nSet函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n上面代码也展示了一种去除数组重复成员的方法\n[...new Set(array)]\n\n上面的方法也可以用于，去除字符串里面的重复字符。\n[...new Set('ababbc')].join('')   // \"abc\"\n\n向 Set 加入值的时候，不会发生类型转换，所以5和\"5\"是两个不同的值。\nSet 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，\n它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，\n而精确相等运算符认为NaN不等于自身。\n\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set &#123;NaN&#125;  这表明，在 Set 内部，两个NaN是相等的。\n\n另外，两个对象总是不相等的。\nlet set = new Set();\n\nset.add(&#123;&#125;);\nset.size // 1\n\nset.add(&#123;&#125;);\nset.size // 2\nSet实例的属性和方法Set 结构的实例有以下属性。\n\nSet.prototype.constructor：构造函数，默认就是Set函数。\nSet.prototype.size：返回Set实例的成员总数。\nSet 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\nSet.prototype.add(value)：添加某个值，返回 Set 结构本身。\nSet.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\nSet.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。\nSet.prototype.clear()：清除所有成员，没有返回值。\n\nArray.from方法可以将 Set 结构转为数组。\nconst items = new Set([1, 2, 3, 4, 5]);\nconst array = Array.from(items);\n\n去除数组重复成员的另一种方法\nfunction dedupe(array) &#123;\n  return Array.from(new Set(array));\n&#125;\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n\nSet 结构的实例有四个遍历方法，可以用于遍历成员。\n\nSet.prototype.keys()：返回键名的遍历器\nSet.prototype.values()：返回键值的遍历器\nSet.prototype.entries()：返回键值对的遍历器\nSet.prototype.forEach()：使用回调函数遍历每个成员\n\nkeys方法、values方法、entries方法返回的都是遍历器对象，由于 Set 结构没有键名，\n只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。\n\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let item of set.keys()) &#123;\n  console.log(item);\n&#125;\n// red\n// green\n// blue\n\nfor (let item of set.values()) &#123;\n  console.log(item);\n&#125;\n// red\n// green\n// blue\n\nfor (let item of set.entries()) &#123;\n  console.log(item);\n&#125;\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\n\n可以直接使用for...of 循环遍历Set\n\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let x of set) &#123;\n  console.log(x);\n&#125;\n// red\n// green\n// blue\n\nSet 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。\n\nlet set = new Set([1, 4, 9]);\nset.forEach((value, key) => console.log(key + ' : ' + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n\nforEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\n\n扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。\nlet set = new Set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\nMap含义和基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制；\n\n为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，\n但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，\nObject 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，\n是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\nconst m = new Map();\nconst o = &#123;p: 'Hello World'&#125;;\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n\n作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\nconst map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n\n上面代码在新建 Map 实例时，就指定了两个键name和title。\n\nMap构造函数接受数组作为参数，实际上执行的是下面的算法。\n\nconst items = [\n  ['name', '张三'],\n  ['title', 'Author']\n];\n\nconst map = new Map();\n\nitems.forEach(\n  ([key, value]) => map.set(key, value)\n);\n\n事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的\n数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\nconst map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n\n如果读取一个未知的键，则返回undefined。\nnew Map().get('asfddfsasadf') // undefined\n\n只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。\n\n同理，同样的值的两个实例，在 Map 结构中被视为两个键。\nconst map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n\n由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。\n这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，\n如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。\n\n如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，\nMap 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。\nMap实例的属性和操作方法1.size属性返回 Map 结构的成员总数。\nconst map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n\n2.set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，\n则键值会被更新，否则就新生成该键。\nset方法返回的是当前的Map对象，因此可以采用链式写法。\n\nlet map = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\nconsole.log(map.size);  // 3\n\n3.get方法读取key对应的键值，如果找不到key，返回undefined。\n\n4.has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\n\nconst m = new Map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(262)           // true\nm.has(undefined)     // true\n\n5.delete方法删除某个键，返回true。如果删除失败，返回false。\nconst m = new Map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n\n6.clear方法清除所有成员，没有返回值。\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。\n\nMap.prototype.keys()：返回键名的遍历器。\nMap.prototype.values()：返回键值的遍历器。\nMap.prototype.entries()：返回所有成员的遍历器。\nMap.prototype.forEach()：遍历 Map 的所有成员。\n需要特别注意的是，Map 的遍历顺序就是插入顺序。\n\nconst map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\nfor (let key of map.keys()) &#123;\n  console.log(key);\n&#125;\n// \"F\"\n// \"T\"\n\nfor (let value of map.values()) &#123;\n  console.log(value);\n&#125;\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) &#123;\n  console.log(item[0], item[1]);\n&#125;\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) &#123;\n  console.log(key, value);\n&#125;\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) &#123;\n  console.log(key, value);\n&#125;\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\nMap 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。\n\nconst map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。\nconst map0 = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\nconst map1 = new Map(\n  [...map0].filter(([k, v]) => k &lt; 3)\n);\n// 产生 Map 结构 &#123;1 => 'a', 2 => 'b'&#125;\n\nconst map2 = new Map(\n  [...map0].map(([k, v]) => [k * 2, '_' + v])\n    );\n// 产生 Map 结构 &#123;2 => '_a', 4 => '_b', 6 => '_c'&#125;\n\nMap 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。\nmap.forEach(function(value, key, map) &#123;\n  console.log(\"Key: %s, Value: %s\", key, value);\n&#125;);","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"Promise对象","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/05/Promise对象/","content":"Promise的含义Promise 是异步编程的一种解决方案，比传统的解决方案 — 回调函数和事件 — 更加合理强大，ES6中统一了语法，原生提供了Promise对象\n 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\nPromise对象的两个特点\n\n对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：*pending(进行中)**,fulfilled(已成功)，rejected(已失败)***，只有异步操作的结果才可以决定当前Promise的状态，任何其他操作都无法改变这个状态（这也就是Promise名字的由来—承诺，表示其他手段无法改变）；\n\nPromise对象的状态一旦改变就不会再改变，任何时候都是这个结果。Promise对象的状态改变只有两种情况：从pending –&gt; fulfilled , 和从 pending –&gt; rejected ；一旦这两种情况发生一种，Promise对象的状态就凝固不会再改变，会一直保持这个结果，这个时候称为 resolved (已定型)。\n​    后面的resolved状态统一只指fulfilled状态，不包含rejected状态；\n\n\n有了Promise对象，可以将异步操作以同步操作的流程表达，避免回调地狱（层层嵌套的回调函数）；\n​    补充：同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。异步，和同步相反  调用方不会理解得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回掉函数来处理这个调用\n\n\n\nPromise还提供了统一的接口，使得控制一部操作更加容易；\n基本用法ES6语法规定，Promise对象是一个构造函数，用来生成Promise实例。\nconst promise = new Promise(function(resolv,reject)&#123;\n    if(/* 异步操作成功 */)&#123;\n        resoleve(value);  //将Promise对象的状态改变为fulfilled\n    &#125;else&#123;\n        reject(reason);  //将Promise对象的状态改变为rejected；\n    &#125;\n&#125;);\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\n它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），\n在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，\n将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，\n并将异步操作报出的错误，作为参数传递出去。\n\nPromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\n\npromise.then(function(value)&#123;\n    //异步成功的回调执行\n&#125;,function(reason)&#123;\n    //异步失败的回调执行\n&#125;);\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，\n第二个回调函数是Promise对象的状态变为rejected时调用。这两个函数都是可选的，不一定要提供。\n它们都接受Promise对象传出的值作为参数。\n\nPromise对象一旦建立就会立即开始执行，但是then方法指定的回调函数只会在当前脚本的所有同步任务执行完毕以后才会执行；\nconsole.log(\"同步任务1执行\");  //该语句最先执行输出\n\nlet promise = new Promise(function(resolve,reject)&#123;\n    //开始执行异步任务\n    console.log(\"开始异步任务 ---- 立即执行\");\n    resolve(\"succeed\");\n&#125;);\n\npromise.then(function(value)&#123;\n    //succeed回调\n    console.log(\"异步成功回调开始执行\")\n&#125;,function(reason)&#123;\n    //失败回调\n    console.error(reason);\n&#125;);\n\nconsole.log(\"同步任务2继续执行\");\n\n从执行结果可以知道，Promise的then回调执行将会在当前脚本的所有同步任务执行以后才执行；\n\nresolve()函数的参数除了返回异步请求的值以外，也可以返回一个Promise实例：\n\nconst p1 = new Promise(function(resolve,reject)&#123;\n    //...\n&#125;);\nconst p2 = new Promise(function(resolve,reject)&#123;\n    ...\n    resolve(p1);\n&#125;);\n\n上面代码中，p2的resolve方法将p1作为参数，即一个异步操作的结果返回另一个异步操作；\n此时p1的状态会传递给p2，也就是p1的状态决定p1的状态，如果p1的状态是pending，\n那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，\n那么p2的回调函数将会立刻执行。\n\nconst p1 = new Promise(function (resolve, reject) &#123;\n  setTimeout(() => reject(new Error('fail')), 3000)\n&#125;)\n\nconst p2 = new Promise(function (resolve, reject) &#123;\n  setTimeout(() => resolve(p1), 1000)\n&#125;)\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// 控制台输出 Error: fail\n\n在上面的代码中，首先顺序执行第一个Promise，但是它的异步请求需要在3秒后才会执行，\n此时将继续执行第二个Promise，第二个promise的异步请求在1秒后开始执行，时间过了一秒后，\n执行p2的异步任务，调用resolve，并传入参数p1（此时才过了1秒，p1还属于pending状态），\n因为此时resolve传入的参数是一个Promise实例，所以此时p2自己的resolved状态失效，\np2的状态将由p1的状态决定，时间又过了2秒，此时p1的异步任务开始执行，调用reject方法，\n将p1的状态设置为rejected，并出传入参数Error，此时p2的then语句是针对p1状态执行\n（p2本身的状态被无效化），最后导致p2的catch方法被触发；\n\n注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。\n\nnew Promise((resolve, reject) => &#123;\n  resolve(1);\n  console.log(2);\n&#125;).then(r => &#123;\n  console.log(r);\n&#125;);\n// 2\n// 1\n\n上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。\n这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。\n\n一般说来在调用完resolve或者reject方法以后，Promise的使命就完成了，\n后续的操作应该放在then完成，所以要确保resolve或者reject方法后面的语句不执行，\n可以在resolve或reject方法前加上return关键字；\n\nnew Promise((resolve, reject) => &#123;\n  return resolve(1);\n  // 后面的语句不会执行\n  console.log(2);\n&#125;)\nPromise.prototype.then()Promise实例都具有 then 方法，是因为 then 方法是定义在Promise构造函数的原型对象\n（Promise.prototype）身上的；\n\n它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，\nthen方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，\n它们都是可选的。\n\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。\n因此可以采用链式写法，即then方法后面再调用另一个then方法。\nPromise.prototype.catch()Promise.prototype.catch()方法是.then(null,rejecvtion)或.then(undefined,rejection)的别名，\n用于指定发生错误时的回调函数。\n\n const p1 = new Promise(function(resolve,reject)&#123;\n    console.log(\"开始执行异步任务\");\n    // resolve(\"succeed\");\n    //reject(new Error(\"异常\"));\n     throw new Error(\"异常\");  //一旦抛出异常，promise实例状态将自动变为rejected\n  &#125;);\n\n  p1.then(function(value)&#123;\n    console.log(value);\n  &#125;,function(reason)&#123;\n    console.error(reason);\n  &#125;);\n  p1.catch(function(reason)&#123;\n    console.error(\"捕捉到异常\",reason);\n  &#125;);\n\n在上面的代码中，如果p1的状态为resolved，则会调用then里的第一个成功回调函数，\n但是p1的状态若为rejected，则此时then里的第二回调函数将会执行，在异步操作中\n抛出异常是p1的状态将会自动变为rejected，此时会调用catch()方法指定的回调函数来处理错误。\n\nthen()方法中指定的回调函数中抛出的错误也会被catch()方法捕获；\n\n可以发现reject()方法的作用，等同于抛出错误。(即使再reject中不抛出异常，但如果then方法中没有提供reject的回调，reject还是会被catch捕捉到！！！)\n\nconst p1 = new Promise(function(resolve,reject)&#123;\n    console.log(\"开始执行异步任务\");\n    // resolve(\"succeed\");\n  // throw new Error(\"异常\");\n  reject(\"异常！！！！\");\n  &#125;);\n\n  p1\n  .then(function(value)&#123;\n    console.log(value);\n  &#125;)\n  .catch(function(reason)&#123;\n    console.error(\"捕捉到异常\",reason);\n  &#125;)\n  .finally(function()&#123;\n    console.log(\"执行结束\");\n  &#125;);\n\n输出：\n开始执行异步任务\n捕捉到异常 异常！！！！\n执行结束\n\n但如果在reject()中没有抛出异常且then方法中提供了rejected状态的回调函数，则此时catch不会被触发；\n\n如果在reject(new Error(\"手动抛出异常！\")),该异常优先被then方法中的resolved状态\n回调捕捉（一旦被捕捉，后面的catch将无法捕捉本次异常）\n\n总的来说，then()方法中的resolved状态的回调函数功能和catch一致，不要在then()方法\n里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。\n\n如果 Promise 状态已经变成resolved，再抛出错误是无效的。\n\n\n// bad\npromise\n  .then(function(data) &#123;\n    // success\n  &#125;, function(err) &#123;\n    // error\n  &#125;);\n\n// good\npromise\n  .then(function(data) &#123; //cb\n    // success\n  &#125;)\n  .catch(function(err) &#123;\n    // error\n  &#125;);\n\n一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。\ncatch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。\nPromise.prototype.finally()finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。\n\npromise\n.then(result => &#123;···&#125;)\n.catch(error => &#123;···&#125;)\n.finally(() => &#123;···&#125;);\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，\n都会执行finally方法指定的回调函数。\n\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态\n到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，\n不依赖于 Promise 的执行结果。\n\nfinally本质上是then方法的特例。\n\npromise\n.finally(() => &#123;\n  // 语句\n&#125;);\n\n// 等同于\npromise\n.then(\n  result => &#123;\n    // 语句\n    return result;\n  &#125;,\n  error => &#123;\n    // 语句\n    throw error;\n  &#125;\n);\n\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。\n有了finally方法，则只需要写一次。\n\nfinally方法总是会返回原来的值。\nPromise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。\n\n let obj = &#123;&#125;;\n\n  console.log(obj instanceof Object);  // true\n  console.log(obj instanceof Promise); //false\n\n  obj = Promise.resolve(obj);\n\n  console.log(obj instanceof Promise);  //true\n\n（1）参数是一个 Promise 实例:如果参数是一个Promise实例，调用Promise.resolve()\n将不做任何修改，原封不动的返回当前传入的实例；\n\n（2）参数是一个thenable对象：thenable对象指的是具有then方法的对象，比如下面这个对象。\nlet thenable = &#123;\n  then: function(resolve, reject) &#123;\n    resolve(42);\n  &#125;\n&#125;;\n\nPromise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。\n\n  const obj = &#123;\n    name:\"LK\",\n    then()&#123;\n      console.log(\"对象里的then方法被执行了！\");\n    &#125;\n  &#125;\n\n  const promise = Promise.resolve(obj);\n\n  console.log(promise instanceof Promise);\n\n可知，传入一个thenable对象时，将obj转换成Promise对象后，将会立即执行thenable对象的then方法，\n在这里先输出true再执行then，是因为then回调属于异步，需要当脚本的所有同步代码执行\n完毕以后才开始执行异步回调；\n\nlet thenable = &#123;\n  then: function(resolve, reject) &#123;\n    resolve(42);\n  &#125;\n&#125;;\n\nlet p1 = Promise.resolve(thenable);\np1.then(function (value) &#123;\n  console.log(value);  // 42\n&#125;);\n\n上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，\n从而立即执行最后那个then()方法指定的回调函数，输出42。\n\n（3）参数不是具有then()方法的对象，或根本就不是对象：\n如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法\n返回一个新的 Promise 对象，状态为resolved。\n\nconst p = Promise.resolve('Hello');\n\np.then(function (s) &#123;\n  console.log(s)\n&#125;);\n// Hello\n\n上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作\n（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成\n就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。\n\n（4）不带有任何参数：Promise.resolve()方法允许调用时不带参数，\n直接返回一个resolved状态的 Promise 对象。\nPromise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。\n\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) &#123;\n  console.log(s)\n&#125;);\n// 出错了\n\n上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。\n\nPromise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。\n\nPromise.reject('出错了')\n.catch(e => &#123;\n  console.log(e === '出错了')\n&#125;)\n// true\n\n上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"yield关键字和generator函数","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/04/yeild关键字和generator函数/","content":"Generator（生成器）函数基本概念Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\n\n//定义一个生成器函数\nfunction * myGenerator()&#123;\n    yield \"first\";\n    yield \"second\";\n    return \"end\";\n&#125;\nlet generator = myGenerator();\nconsole.log(generator);  // 输出一个myGenerator对象\n\n上面代码定义的一个Generator函数，其内部有两个yield表达式，所以可以知道该函数有三个状态 first second 和 return语句（结束执行）。\n\n但是调用Generator函数后，该函数并不会执行：\nfunction * myGenerator()&#123;\n    console.log(\"myGenerator函数被执行了！\");\n    yield \"first\";\n    yield \"second\";\n    return \"end\";\n&#125;\nlet generator = myGenerator();\nconsole.log(generator);  // 输出一个myGenerator对象\n\n返回的也不是函数的运行结果，而是一个指向内部状态的指针对象---Iterator遍历器对象；\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\nconsole.log(generator.next());\n//先输出 myGenerator函数被执行了！ \n//之后输出第一个yield后的表达式，将其值封装在一个对象中\n// &#123;value: 'first', done: false&#125;\n\n再接着连续调用三次遍历器对象的next方法\nconsole.log(generator.next());\nconsole.log(generator.next());\nconsole.log(generator.next());\n\n第一次调用，Generator 函数开始执行，先输出console.log()语句；\n直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值first，done属性的值false，表示遍历还没有结束。\n\n第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值 second，done属性的值false，表示遍历还没有结束。\n\n第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。\n\n第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。\n\n总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\n\nES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。\nyield关键字yield官方解释：\nThe yield keyword is used to pause and resume a generator function.\n// yield这个关键字是用来暂停和恢复一个遍历器函数（的运行）的。\n\n所以yield这个关键字能使生成函数暂停，yield关键字后面的表达式的值会返回给生成器的调用者，它可以被认为是一个基于生成器的版本的return关键字；\n\n--------------------------------------------------------------------\n由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\n遍历器对象的next方法的运行逻辑如下。\n\n（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n\n（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n\n（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n\n（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。\n\n需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\nfunction * fun()&#123;\n    yield 123+456;\n&#125;\n上面代码中，yield后的表达式不会立即执行，只有调用该Generator函数返回的Iterator对象中的next方法时，next指针将指针移到这一语句时才会执行；\n\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。\n\nGenerator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。\n\n注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。\n\nyield表达式如果用在另一个表达式之中，必须放在圆括号里面。\n\nfunction* demo() &#123;\n  console.log('Hello' + yield); // SyntaxError\n  console.log('Hello' + yield 123); // SyntaxError\n\n  console.log('Hello' + (yield)); // OK\n  console.log('Hello' + (yield 123)); // OK\n&#125;\n\nyield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。\n\nfunction* demo() &#123;\n  foo(yield 'a', yield 'b'); // OK\n  let input = yield; // OK\n&#125;\nGenerator与Iterator接口的关系任意一个对象的Symbol.iterator属性（方法），都是一个Iterator遍历器生成函数（调用该方法会返回一个遍历器对象），而Generator函数的返回值也是一个遍历器对象，因此可以把Generator赋值给对象的Symbol.iterator属性，使这个对象具有Iterator接口；\n\nvar obj = &#123;\n    name:\"LK\",\n    data: [1,2,3],\n    [Symbol.iterator]: function * ()&#123;\n        console.log(\"开始执行！\");\n        for(var i = 0;i&lt;this.data.length;i++)&#123;\n            yield this.data[i];\n        &#125;\n        return \"end\";\n    &#125;\n&#125;;\n\nlet it = obj[Symbol.iterator]();\nconsole.log(it.next());\nconsole.log(it.next());\nconsole.log(it.next());\nconsole.log(it.next());\n\nvar myIterable = &#123;&#125;;\nmyIterable[Symbol.iterator] = function* () &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;;\n\n[...myIterable] // [1, 2, 3]\n\n上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。\nnext方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\nfunction* f() &#123;\n  for(var i = 0; true; i++) &#123;\n    var reset = yield i;\n    if(reset) &#123; i = -1; &#125;\n  &#125;\n&#125;\n\nvar g = f();\n\ng.next() // &#123; value: 0, done: false &#125;\ng.next() // &#123; value: 1, done: false &#125;\ng.next(true) // &#123; value: 0, done: false &#125;\n\n上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。\n\n这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\n\nfunction* foo(x) &#123;\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n&#125;\n\nvar a = foo(5);\na.next() // Object&#123;value:6, done:false&#125;\na.next() // Object&#123;value:NaN, done:false&#125;\na.next() // Object&#123;value:NaN, done:true&#125;\n\nvar b = foo(5);\nb.next() // &#123; value:6, done:false &#125;\nb.next(12) // &#123; value:8, done:false &#125;\nb.next(13) // &#123; value:42, done:true &#125;\n\n上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。\n\n如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。\n\n注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。\n\nfunction* dataConsumer() &#123;\n  console.log('Started');\n  console.log(`1. $&#123;yield&#125;`);\n  console.log(`2. $&#123;yield&#125;`);\n  return 'result';\n&#125;\n\nlet genObj = dataConsumer();\ngenObj.next();\n// Started\ngenObj.next('a')\n// 1. a\ngenObj.next('b')\n// 2. b\nfor …of 循环for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。\n\nfunction * fun ()&#123;\n    yield 1;\n    yield 2;\n    yield 3;\n    return 4;\n&#125;\nfor(var i of fun())&#123;\n    console.log(i);\n&#125;\n\n上面代码使用for...of循环，依次显示 3 个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的4，不包括在for...of循环之中。\n\n除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。\n\nfunction* numbers () &#123;\n  yield 1\n  yield 2\n  return 3\n  yield 4\n&#125;\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) &#123;\n  console.log(n)\n&#125;\n// 1\n// 2\nGenerator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\n\nvar g = function* () &#123;\n  try &#123;\n    yield;\n  &#125; catch (e) &#123;\n    console.log('内部捕获', e);\n  &#125;\n&#125;;\n\nvar i = g();\ni.next();\n\ntry &#123;\n  i.throw('a');\n  i.throw('b');\n&#125; catch (e) &#123;\n  console.log('外部捕获', e);\n&#125;\n// 内部捕获 a\n// 外部捕获 b\n\n上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。\n\n注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。\n\nvar g = function* () &#123;\n  while (true) &#123;\n    try &#123;\n      yield;\n    &#125; catch (e) &#123;\n      if (e != 'a') throw e;\n      console.log('内部捕获', e);\n    &#125;\n  &#125;\n&#125;;\n\nvar i = g();\ni.next();\n\ntry &#123;\n  throw new Error('a');\n  throw new Error('b');\n&#125; catch (e) &#123;\n  console.log('外部捕获', e);\n&#125;\n// 外部捕获 [Error: a]\n\n上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。\n\n如果 Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。\n\nvar g = function* () &#123;\n  while (true) &#123;\n    yield;\n    console.log('内部捕获', e);\n  &#125;\n&#125;;\n\nvar i = g();\ni.next();\n\ntry &#123;\n  i.throw('a');\n  i.throw('b');\n&#125; catch (e) &#123;\n  console.log('外部捕获', e);\n&#125;\n// 外部捕获 a\n\n上面代码中，Generator 函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获。\n\n如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。\nGenerator.prototype.return()Generator 函数返回的遍历器对象，还有一个return()方法，可以返回给定的值，并且终结遍历 Generator 函数。\n\nfunction* gen() &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;\n\nvar g = gen();\n\ng.next()        // &#123; value: 1, done: false &#125;\ng.return('foo') // &#123; value: \"foo\", done: true &#125;\ng.next()        // &#123; value: undefined, done: true &#125;\n\n上面代码中，遍历器对象g调用return()方法后，返回值的value属性就是return()方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next()方法，done属性总是返回true。\n\n如果return()方法调用时，不提供参数，则返回值的value属性为undefined。\n\n如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return()方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束\n\nfunction* numbers () &#123;\n  yield 1;\n  try &#123;\n    yield 2;\n    yield 3;\n  &#125; finally &#123;\n    yield 4;\n    yield 5;\n  &#125;\n  yield 6;\n&#125;\nvar g = numbers();\ng.next() // &#123; value: 1, done: false &#125;\ng.next() // &#123; value: 2, done: false &#125;\ng.return(7) // &#123; value: 4, done: false &#125;\ng.next() // &#123; value: 5, done: false &#125;\ng.next() // &#123; value: 7, done: true &#125;\n\n上面代码中，调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。\nGenerator函数的this调用Generator函数总是返回一个Iterator遍历器对象，在ES6中规定这个返回的遍历器对象是这个Generator函数的一个实例对象，自然的，这个实例对象也就会继承Generator函数的prototype对象身上的方法；\n\nfunction * g()&#123;&#125;\n\ng.prototype.hello = function()&#123;\n    console.log(\"hello\");\n&#125;\n\nlet obj = g();\n\nconsole.log(obj instanceof g);  // true\nobj.hello();  // hello\n\n上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。\n\nfunction* g() &#123;\n  this.a = 11;\n&#125;\n\nlet obj = g();\nobj.next();  //执行g函数\nobj.a // undefined\n\nGenerator 函数也不能跟new命令一起用，会报错。\n\n我们可以通过先生成一个空对象，使用call方法绑定Generator函数内部的this，这样当Generator函数调用以后这个空对象就是Generator函数的实例对象了；\n\nfunction* F() &#123;\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n&#125;\nvar obj = &#123;&#125;;\nvar f = F.call(obj);\n\nf.next();  // Object &#123;value: 2, done: false&#125;\nf.next();  // Object &#123;value: 3, done: false&#125;\nf.next();  // Object &#123;value: undefined, done: true&#125;\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n\n上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次next方法（因为F内部有两个yield表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。\n\n上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，可以通过将obj换成F.prototype来进一步修改；\n\nfunction* F() &#123;\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n&#125;\nvar f = F.call(F.prototype);\n\nf.next();  // Object &#123;value: 2, done: false&#125;\nf.next();  // Object &#123;value: 3, done: false&#125;\nf.next();  // Object &#123;value: undefined, done: true&#125;\n\nf.a // 1\nf.b // 2\nf.c // 3\n\n再将F改成构造函数，就可以对它执行new命令了；\n\nfunction* gen() &#123;\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n&#125;\n\nfunction F() &#123;\n  return gen.call(gen.prototype);\n&#125;\n\nvar f = new F();\n\nf.next();  // Object &#123;value: 2, done: false&#125;\nf.next();  // Object &#123;value: 3, done: false&#125;\nf.next();  // Object &#123;value: undefined, done: true&#125;\n\nf.a // 1\nf.b // 2\nf.c // 3\nGenerator函数实际的应用（模拟业务） //模拟获取  用户数据  订单数据  商品数据 \n        function getUsers()&#123;\n            setTimeout(()=>&#123;\n                let data = '用户数据';\n                //调用 next 方法, 并且将数据传入\n                iterator.next(data);\n            &#125;, 1000);\n        &#125;\n\n        function getOrders()&#123;\n            setTimeout(()=>&#123;\n                let data = '订单数据';\n                iterator.next(data);\n            &#125;, 1000)\n        &#125;\n\n        function getGoods()&#123;\n            setTimeout(()=>&#123;\n                let data = '商品数据';\n                iterator.next(data);\n            &#125;, 1000)\n        &#125;\n\n        function * gen()&#123;\n            let users = yield getUsers();\n            console.log(users);\n            let orders = yield getOrders();\n            console.log(orders);\n            let goods = yield getGoods();\n            console.log(goods);\n        &#125;\n\n        //调用生成器函数\n        let iterator = gen();\n        iterator.next();\n\n在上面的代码中，定义了三个业务逻辑函数，要求它们之间一定要按照规定的顺序和条件执行；\n\n首先获得生成器函数gen返回的遍历器对象，调用遍历器对象的next方法，将会执行生成器函数的第一行代码中的 getUsers()函数,在getUsers函数中模拟请求到用户数据后，继续调用遍历器的next方法，并将获取到的用户数据作为参数传入，此时用户数据将被赋值给gen函数中的users变量，并打印输出；接着继续执行getOrders()函数，在这个函数中模拟获取到订单数据后，开始调用遍历器对象的next方法，并将订单数据作为参数传入，此时订单数据将被赋值给gen函数的orders变量并打印输出；最后开始执行getGoods()函数，在模拟获取到商品数据后，开始调用遍历器对象的next函数，并将获取到的商品数据作为参数传入，此时商品数据将被赋值给gen函数的goods变量并打印输出，此时gen函数执行完毕；\n\n总的来说，Generator函数功能十分强大，我们可以将其应用在异步编程中，实现控制流管理；","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"遍历器（迭代器）Iterator","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/04/遍历器（迭代器）Iterator/","content":"Iterator(遍历器/迭代器)概念JS原有的表示“集合”的数据结构只有数组和对象，在ES6中又添加了Map，Set，所以目前共有四种数据集合，用户可以自定义自己的数据结构，所以需要一种同一的接口机制来处理所有不同的数据结构；\n\n遍历器（Iterator）就是一种机制，一种接口，可以为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口就可以完成遍历操作（依次遍历当前数据结构的所有成员）；\n\nIterator的作用：\n\t1.为各种数据结构提供一个统一的，简便的访问接口；\n    2.使得数据结构的成员能够按照某种次序排列；\n    3.ES6中创建了一种全新的遍历命令 for...of 循环，Iterator接口主要供 for...of 使用；\n\nIterator 的遍历过程是这样的。\n\n（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n\n（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n\n（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n\n//模拟一个next方法返回值\n\nfunction simulationIterator(arr)&#123;\n    let index = 0;\n    return &#123;\n        next:function()&#123;\n            if(index &lt; arr.length)&#123;\n                return &#123;value:arr[index++],done:false&#125;;\n            &#125;\n    \t\treturn &#123;value:undefined,done:true&#125;;\n        &#125;\n    &#125;\n&#125;\n\nconst iterator = simulationIterator([1,2,3]);\nconsole.log(iterator.next()); // 输出 &#123;value: 1, done: false&#125;\nconsole.log(iterator.next());  // 输出 &#123;value: 2, done: false&#125;\nconsole.log(iterator.next());  // 输出 &#123;value: 3, done: false&#125;\nconsole.log(iterator.next());  //输出 &#123;value: undefined, done: true&#125;\n\n上面的代码就定义了一个遍历器生成函数，调用它将会生成一个遍历器对象，对数组[1,2,3]执行这个函数，会返回该数组的遍历器对象（指针对象）iterator；\n\n在遍历器对象iterator中有一个next方法，用来移动当前指针指向的数组的起始位置，每调用一次next方法指针就会指向数组的下一个成员；\n\n调用next方法会返回一个对象，表示当前遍历到的数据成员信息，这个对象具有value和done两个属性，value属性返回当前遍历到的数据成员信息，done属性为布尔值，表示遍历是否结束；\n\n当然，next的返回对象中的value:undefined和done:false是可以省略的，可以只返回如下形式的对象：\nnext:function()&#123;\n    if(index &lt; arr.length)&#123;\n        return &#123;value:arr[index++]&#125;;\n    &#125;\n    return &#123;done:true&#125;;\n&#125;\n\n默认的Iterator接口从上文可知，Iterator接口的目的是为所有数据结构提供一个同一的访问机制，当使用 for...of 循环遍历某一种数据结构时，该循环会自动去寻找Iterator接口；\n\n一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。\n\nES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内；\n\n//创建一个对象并在其身上添加Iterator接口\nconst obj = &#123;\n    name: \"Lk\",\n    data : [1,2,3,4],\n    [Symbol.iterator]:function()&#123;\n        let _this = this;\n        let index = 0;\n        return &#123;\n            next : function()&#123;\n                if(index &lt; _this.data.length)&#123;\n                    return &#123;value:_this.data[index++],done:false&#125;;\n                &#125;\n                return &#123;value:undefined,done:true&#125;;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nfor(var i of obj)&#123;  使用for...of 就会自动去寻找需要遍历的数据结构上的Iterator接口\n    console.log(i);\n&#125;\n\n面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。\n\nES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\n\n原生具备 Iterator 接口的数据结构如下。\n\nArray\nMap\nSet\nString\nTypedArray\n函数的 arguments 对象\nNodeList 对象\n\nlet arr = [1,2,3,4];\nfor(var i of arr)&#123;\n    console.log(i);  //依次输出 1 2 3 4\n&#125;\n\nlet it = arr[Symbol.iterator]();  //调用arr身上的Iterator接口（是一个函数），将会返回一个指针对象it；\n\nconsole.log(it.next());\nconsole.log(it.next());\nconsole.log(it.next());\nconsole.log(it.next());\nconsole.log(it.next());\n\nlet str &#x3D; &quot;LK&quot;;\nlet it &#x3D; str[Symbol.iterator]();\nconsole.log(it.next());\nconsole.log(it.next());\nconsole.log(it.next());\n\n可知String基本数据类型也具有原生的Iterator接口机制；\n\n对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，for...of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for...of循环遍历。\n\n对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。\n\n一个对象如果要具备可被for...of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。\n伪数组的Iterator对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。\n\n//自定义一个类数组对象\nlet simulateArray = &#123;\n    //注意数值索引要从0开始\n    0:\"fhgth\",\n    1:\"fre\",\n    2:\"fdf\",\n    3:\"kj\",\n    length:4,\n    [Symbol.iterator]:Array.prototype[Symbol.iterator]\n&#125;\n\nfor(var i of simulateArray)&#123;\n    console.log(i);\n&#125;\n\n注意，普通对象部署数组的Symbol.iterator方法，并无效果。\n\nlet iterable = &#123;\n  a: 'a',\n  b: 'b',\n  c: 'c',\n  length: 3,\n  [Symbol.iterator]: Array.prototype[Symbol.iterator]\n&#125;;\nfor (let item of iterable) &#123;\n  console.log(item); // undefined, undefined, undefined\n&#125;\n调用Iterator接口的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了for...of循环，还有几个别的场合。\n（1）解构赋值：对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\nlet set = new Set().add('a').add('b').add('c');\n\nlet [x,y] = set;\n// x='a'; y='b'\n\nlet [first, ...rest] = set;\n// first='a'; rest=['b','c'];\n\n(2)扩展运算符：扩展运算符（...）也会调用默认的 Iterator 接口。\n\n// 例一\nvar str = 'hello';\n[...str] //  ['h','e','l','l','o']\n\n// 例二\nlet arr = ['b', 'c'];\n['a', ...arr, 'd']\n// ['a', 'b', 'c', 'd']\n\n上面代码的扩展运算符内部就调用 Iterator 接口。\n\n实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。\nlet arr = [...iterable];\n\n（3）yield*：yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口；\n\n（4）其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\n\nfor...of\nArray.from()\nMap(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）\nPromise.all()\nPromise.race()\nfor…of 循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。\n\n一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。\n\nfor...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串。\n数组数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环本质上就是调用这个接口产生的遍历器；\n\nfor...of循环可以代替数组实例的forEach方法。\nconst arr = ['red', 'green', 'blue'];\n\narr.forEach(function (element, index) &#123;\n  console.log(element); // red green blue\n  console.log(index);   // 0 1 2\n&#125;);\n\n\nJavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。\n\nvar arr = ['a', 'b', 'c', 'd'];\n\nfor (let a in arr) &#123;\n  console.log(a); // 0 1 2 3\n&#125;\n\nfor (let a of arr) &#123;\n  console.log(a); // a b c d\n&#125;\n与其他遍历语法的比较我们可以使用最简单的for循环来遍历数组，也可以使用数组提供的内置forEach()方法，但是forEach无法中途跳出循环，break命令或return命令都不能奏效。\n\nfor...in循环可以遍历数组的键名。\nfor...in循环有几个缺点。\n\n数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。\n\tfor...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\n\t某些情况下，for...in循环会以任意顺序遍历键名。\n\t总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。\n\nfor...of循环相比上面几种做法，有一些显著的优点。\n\t1.有着同for...in一样的简洁语法，但是没有for...in那些缺点。\n\t2.不同于forEach方法，它可以与break、continue和return配合使用。\n\t3.提供了遍历所有数据结构的统一操作接口。","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"参数默认值-rest-spread-Symbol","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/03/参数默认值-rest-spread-Symbol/","content":"参数默认值ES6 语法中允许在定义函数时给函数参数赋初值\n\t规则：形参初始值（具有默认初始值的参数）一般位置靠后\n    \t可以与解构赋值一起使用\n        \nfunction fun(a = 1, b = 2)&#123;\n    return a + b;\n&#125;\nconsole.log(fun());  // 输出 3\nconsole.log(fun(5));  //输出 7\nconsole.log(fun(5,6));  // 输出 11\n\nfunction userInfo(&#123;name=\"Lk\",sex=\"man\",age=12&#125;)&#123;\n    console.log(name);\n    console.log(sex);\n    console.log(age);\n&#125;\nuserInfo(&#123;&#125;);  // 输出 Lk man 12 ；\nuserInfo(&#123;name:\"ZK\",sex:\"female\"&#125;);  // 输出 ZK female 12；\n\nfunction mutation(&#123;commit&#125;)&#123;\n    console.log(connmit);\n&#125;\nmutation(&#123;commit:\"解构赋值，vuex\",name:\"LK\",count:12&#125;);  // \"解构赋值，vuex\"\nrest参数在ES6中引入rest参数来获取函数的实参，用来代替 arguments;\n\n(1) Rest 参数接受函数的多余参数，组成一个数组，放在形参的最后;\n\nfunction func(a, b, ...theArgs)&#123;\n    // ...\n&#125;\n\n(2) Rest参数和arguments对象的区别：\n\t\trest参数只包括那些没有给出名称的参数，arguments包含所有参数\n\t\targuments 对象不是真正的数组，而rest 参数是数组实例，可以直接应用sort, map, forEach, pop等方法\n\t\targuments 对象拥有一些自己额外的功能\n        \n (3) Rest参数可以被结构(通俗一点，将rest参数的数据解析后一一对应)不要忘记参数用[]括起来，因为它是数组\n        \nfunction f(...[a, b, c]) &#123;  \n  return a + b + c;  \n&#125;  \n  \nf(1)          //NaN 因为只传递一个值，其实需要三个值  \nf(1, 2, 3)    // 6  \nf(1, 2, 3, 4) // 6 (第四值没有与之对应的变量名)\n    \nrest 参数之后不能再有其他参数(即，只能是最后一个参数)，否则会报错!!\n    \nES5 获取实参：\nfunction fun()&#123;\n    console.log(arguments);\n&#125;\nfun([1,2,3]);  // argument包含所有的参数放入一个伪数组\n\n在ES6 中获取实参  arr这一名字是自定义的\nfunction fun2(...arr)&#123;\n    console.log(arr);\n&#125;\nfun2([1,2,3]);\nfun2(1,2);\n\nfunction fun3(a,b,...args)&#123;\n    console.log(a+b);\n    console.log(args);\n&#125;\nfun3(1,2,3,4);  //输出 3   (2) [3, 4]  --- rest封装  多余  的参数放入数组，是真正的数组\nspread扩展运算符ES6 中 使用 ... 扩展运算符将数组展开，转换成逗号分隔的参数序列\n\n\nlet arr = [1,2,3];\nconsole.log(...arr);  // 输出 1 2 3\n\n//1.数组合并\nfunction concat(arr1,arr2)&#123;\n    return [...arr1,...arr2];\n&#125;\nconsole.log(concat([1,2,3],[4,5,6]));  // 输出 数组 (6) [1, 2, 3, 4, 5, 6]\n\n//2.数组克隆\nconst arr1 = [1,2,3];\nconst arr2 = [...arr1];\nconsole.log(arr2);  // 输出 Array(3) [1,2,3]\n\n//3.将伪数组转换成真正的数组\n&lt;body>\n    &lt;div>&lt;/div>\n\t&lt;div>&lt;/div>\n\t&lt;div>&lt;/div>\n&lt;/body>\n const divs = document.querySelectorAll('div');\n        const divArr = [...divs];\n        console.log(divArr);// arguments\nSymbol\t在ES5中对象的属性名其实都是字符串，很容易造成对象中属性名冲突；为了保证每一个属性名的名字都是独一无二的，从根本上防止属性名的冲突，在ES6中引入Symbol；\n\tES6中引入一种全新的原始数据类型 --- Symbol，表示独一无二的值，它属于JS语言的数据类型之一；\n\tSymbol值可以通过Symbol()函数生成，对象的属性名现在可以有两种类型，一种就是原来的字符串，另一种就是新增的Symbol类型，凡是属性名是Symbol类型的，它就是独一无二的，可以保证不会与其他属性名产生冲突。\n    \nlet s = Symbol();  // 创建一个Symbol类型的变量\nconsole.log(typeof s); //输出 'symbol'\n\n注意 ：使用Symbol函数不能使用 new 关键字，否则会报错，因为生成的Symbol是一个原始类型的值，不是对象，因此也不能给symbol类型的变量添加属性，它是一种类似与字符串的数据类型；\n\n\tSymbol()函数可以接受一个字符串作为参数，表示对当前Symbol变量的描述；主要是为了在控制台显式或者在转为字符串时易于区分；\n    \nlet s1 = Symbol(\"LK\");\nlet s2 = Symbol(\"zk\");\nconsole.log(s1);  // 输出 Symbol(LK)\nconsole.log(s2);  //输出 Symbol(zk)\nconsole.log(s1.toString());  //Symbol(LK)\nconsole.log(s2.toString());  //Symbol(zk)\n\n如果Symbol的参数是一个对象，就会调用对象身上的toString()方法将其转换为字符串，然后才生成一个Symbol值；\n\nconst obj = &#123;\n    name:\"obj\",\n    //自定义一个对象身上的同toString()方法，在Symbol函数传入对象时就会调用这个值，在控制台打印即可知道\n    toString: function()&#123;\n        return \"obj\";\n    &#125;\n&#125;\nlet sym = Symbol(obj);\nconsole.log(sym);  // 输出 Symbol(obj)\n\nconst obj2 = &#123;\n    name:\"ZK\"\n    //不重写对象身上的toString方法\n    //Object原型身上的toString()默认输出[[object Object]]\n&#125;\nlet sym2 = Symbol(obj2);\nconsole.log(sym2);  //Symbol([object Object])\n\n注意：Symbol函数的参数只是表示对当前Symbol值的一种描述，因此相同参数的Symbol函数的返回值不相等；\n\nlet s1 = Symbol();\nlet s2 = Symbol();\nconsole.log(s1 === s2);  // false\nlet s3 = Symbol(\"ZK\");\nlet s4 = Symbol(\"ZK\");\nconsole.log(s3 === s4);  //false \n\n使用Symbol函数返回的值不能与其他类型的值运算，会报错；\nlet sym = Symbol('My symbol');\n\n\"your symbol is \" + sym\n// TypeError: can't convert symbol to string\n`your symbol is $&#123;sym&#125;`\n// TypeError: can't convert symbol to string\n\nSymbol值可以显式转换成字符串和布尔值，但是不能转换成数值；\n\nlet sym = Symbol('My symbol');\n\nString(sym) // 'Symbol(My symbol)'\nsym.toString() // 'Symbol(My symbol)'\n\nlet sym = Symbol();\nBoolean(sym) // true\n!sym  // false\n\nif (sym) &#123;\n  // ...\n&#125;\n\nNumber(sym) // TypeError\nsym + 2 // TypeError\nSymbol.prototype.description在创建一个Symbol的时候，可以添加一个描述；\n\nconst sym = Symbol(\"lk\"); // 此时 lk 就是 sym 的描述\n\n可以通过ES2019提供的一个实例属性 description，直接返回Symbol 的描述\nconsole.log(sym.description);  // 输出 lk\n使用Symbol作为对象的属性名每一个Symbol的值都是独一无二的，可以用Symbol值来作为标识符，用作对象的属性名，保证不会出现一样的同名属性名；\n\nlet mySymbol = Symbol();\n\n// 第一种写法\nlet a = &#123;&#125;;\na[mySymbol] = 'Hello!';\n\n// 第二种写法\nlet a = &#123;\n  [mySymbol]: 'Hello!'  //在对象中使用Symbol值需要使用[]包括起来\n&#125;;\n\n// 第三种写法\nlet a = &#123;&#125;;\nObject.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);\n\n// 以上写法都得到同样结果\na[mySymbol] // \"Hello!\"\n\n注意，Symbol 值作为对象属性名时，不能用点运算符。因为点运算符后面总是字符串，所以不会读取Symbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个Symbol 值。\n\nconst mySymbol = Symbol();\nconst a = &#123;&#125;;\n\na.mySymbol = 'Hello!';\na[mySymbol] // undefined\na['mySymbol'] // \"Hello!\"\n\nSymbol 值作为属性名时，该属性还是公开属性，不是私有属性。\n属性名的遍历Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。\n\n但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\n\nconst obj = &#123;&#125;;\nlet s1 = Symbol('s1');\nlet s2 = Symbol('s2');\n//给obj对象添加属性\nobj[s1] = \"ZK\";\nobj[s2] = \"lk\";\nobj.name = \"sndj\"\n\nconst objSymbol = Object.getOwnPropertySymbols(obj);\nconsole.log(objSymbol);  // 输出 (2) [Symbol(s1), Symbol(s2)]\nconsole.log(typeof objSymbol); // 输出 object\nconsole.log(objSymbol instanceof Array);  // 输出 true\n\n可知Object.getOwnPropertySymbols这一方法只会将对象中的使用Symbol值作为属性名的属性（无法获取字符串类型的属性名）返回，且封装在一个数组中；\n\n在以前的ES5语法中可以使用 for...in 来枚举对象的属性；\nconst obj = &#123;\n    name:\"LK\",\n    age:12,\n    sex:\"female\"\n&#125;\nfor (let i in obj)&#123;\n    console.log(i);\n&#125; //依次输出 name age sex\nconsole.log(Object.getOwnPropertyNames(obj)); //输出 数组 (3) ['name', 'age', 'sex']\n\n但是使用Symbol定义的属性名无法使用 for...in 来枚举属性名\n\nconst obj = &#123;&#125;;\nconst foo = Symbol('foo');\n\nobj[foo] = 'bar';\n\nfor (let i in obj) &#123;\n  console.log(i); // 无输出\n&#125;\n\nObject.getOwnPropertyNames(obj) // []\nObject.getOwnPropertySymbols(obj) // [Symbol(foo)]\n\n可以知道使用Symbol值作为属性名的也无法使用Object.getOwnPropertyNames来获取属性名数组；\n\n新的API：Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\n\nconst obj = &#123;\n    [Symbol('myKey')]:1,\n    name:\"LK\",\n    age:12\n&#125;\nconsole.log(Object.keys(obj)); \nconsole.log(Reflect.ownKeys(obj));\n\n可以知道，使用Reflect.ownKeys()可以获取对象的所有属性名（包括字符串类型的属性名和Symbol值类型的属性名）；\nSymbol.for()与Symbol.keyFor()我们可以使用Symbol.for()方法来反复使用同一个Symbol值；该方法接受一个字符串作为参数（将用于对Symbol值的描述），然后搜索有没有以该字符串作为名称的Symbol值，如果有就返回这个Symbol值，不存在就新建一个以这个字符串为名称的Symbol值，并注册到全局；\n\nlet s1 = Symbol.for('foo');\nlet s2 = Symbol.for('foo');\n\nconsole.log(s1 === s2);   // true\n\nSymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(\"cat\")30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(\"cat\")30 次，会返回 30 个不同的 Symbol 值。\n注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\n\nfunction fun()&#123;\n    let s1 = Symbol.for(\"LK\");\n    return s1;\n&#125;\nlet s1 = fun();\nlet s2 = Symbol.for(\"LK\");\nconsole.log(s1 === s2); // true\n\n上面代码中，Symbol.for('LK')是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行Symbol.for('LK')可以取到这个 Symbol 值。\n\nSymbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。\n\nlet s1 = Symbol.for(\"foo\");\nconsole.log(Symbol.keyFor(s1)); // \"foo\"\n\nlet s2 = Symbol(\"foo\");\nconsole.log(Symbol.keyFor(s2)) // undefined\n内置的Symbol值\nclass Person&#123;\n    //定义Person类的hasInstance() 方法，调用instanceof判断是否为该类的一个实例时会自动调用该类的hasInstance()\n    static [Symbol.hasInstance]()&#123;\n        console.log(\"这个方法会被用来检测是否是Person类实例\");\n    &#125;\n&#125;\nconst person = new Person();\nconsole.log(person instanceof Person);  // 输出 这个方法会被用来检测是否是Person类实例 false\\\n\n\n其他的Symbol内置方法参见 https://es6.ruanyifeng.com/?search=rest&amp;x=0&amp;y=0#docs/symbol\n","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"let-const-解构赋值-箭头函数","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/04/01/let-const-箭头函数/","content":"ECMAScript介绍ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。\nlet关键字使用 let 关键字来声明变量；\n\t\nlet a = 1;  //声明Number类型基本变量\nlet b = \"hello\";  //声明String类型基本变量\nlet flag = true;  //声明Boolean类型基本变量\nlet obj = &#123;name:\"LK\"&#125;; //声明对象\nlet arr = [1,3]; //声明数组\nlet fun = function()&#123;   //声明函数\n    console.log(\"hello\");\n&#125;\n\n除了以下几点和 var 关键字不一样以外其他用法两者一致；\n\n1.不允许重复声明变量（使用var关键字可以反复声明同一变量，js引擎在解析时发现用var关键字声明的变量已经存在时直接跳过而不会报错，而使用 let 关键字会报错）；\n    \nlet a = 1;\nlet a = \"hello\";  //报错 Identifier 'a' has already been declared\n\nvar a = 2;\nvar a = \"hello\";  \n注意 ： 已经使用let关键字声明的变量再次使用var关键字声明同样会报错！！！\n\n2.具有块级作用域：（使用大括号&#123;&#125;包起来的属于一个块级作用域，块级作用域内声明的变量只在当前块级作用域下可见，for，if，while中的内容体都属于块级作用域）；\n\n&#123;\n    let a = 1;\n&#125;\nconsole.log(a);  //报错 a is not defined\n\nif(true)&#123;\n    let b = 2;\n&#125;\nconsole.log(b);  //报错 b is not defined\n\nif(true)&#123;\n    var c = 1;\n&#125;\nconsole.log(c);  // 输出 1\n\n使用var关键字给按钮绑定事件\nfor(var j=0;j&lt;btnList;j++)&#123;\n    btnList[j].onclick = function()&#123;\n        console.log(i);\n        //注意这里的this依旧是当前被点击的按钮对象\n    &#125;\n&#125;\n\n/*\n触发效果 ： 点击每一个按钮都是输出btnList的长度值；\n原因分析：在for循环中使用 var关键字声明的变量将成为全局变量（不存在块级作用域和村存在变量声明提升），回调函数的执行是在初始化代码执行完毕以后，用dom事件模块监听到事件触发才把对应的函数回调放入循环事件队列中执行的，此时，i作为全局变量已经自增到了btnList的长度值，此时执行回调函数时输出的是全局变量变量的值；\n以上代码具体展开：\n\nvar j; \n&#123;j = 0; btnList[j].onclick = function()&#123;console.log(j)&#125;;&#125;\n&#123;j = 1; btnList[j].onclick = function()&#123;console.log(j)&#125;;&#125;\n&#123;j = 2; btnList[j].onclick = function()&#123;console.log(j)&#125;;&#125;\n&#123;j = 3;&#125;\n\n因为js都是先执行初始化代码，在执行回调代码，所以在绑定的function()&#123;console.log(j)&#125;; 语句都是在初始化代码之后，也就是这里的 j = 3 ;之后；\n在执行回调时，回调函数输出访问的是全局的j，而不是当前块级作用域中的j（var 变量不具有块作用域）\n*/\n\n利用let的块级作用域绑定事件：\nvar  btnList = document.getElementsByTagName(\"btn\");\n\nfor(let i =0;i&lt;btnList.length;i++)&#123;\n    btnList[i].onclick = function()&#123;\n        console.log(i);\n    &#125;\n&#125;\n\n/*\n触发效果：点击对象按钮就能正确输出它的索引值；\n原因分析：在for循环中使用let关键字声明的变量具有块级作用域和不存在变量声明提升；每一次执行一次for循环都是一个全新的let i；循环之间的i具有块级作用域不会相互影响；\n以上代码具体展开：\n\n&#123;let i = 0;bthList[i].onclick = function()&#123;console.log(i)&#125;;&#125;\n&#123;let i = 1;bthList[i].onclick = function()&#123;console.log(i)&#125;;&#125;\n&#123;let i = 2;bthList[i].onclick = function()&#123;console.log(i)&#125;;&#125;\n&#123;let i = 3;&#125;\n\nlet 声明的关键字具有块级作用域，所以在执行回调函数时，输出的i都是访问当前块级作用域下的i；\n*/\n\n3.let 关键字声明的变量不存在变量提升；\nconsole.log(a);  //报错 Cannot access 'a' before initialization\nlet a = 1;\n\nconsole.log(b); //输出 undefined\nvar b = 1;\n\n4.不影响作用域链\n&#123;\n    let name = \"LK\";\n    function fun()&#123;\n        console.log(name);\n    &#125;\n    fun();  //输出 LK，在当前函数的块级作用域下没有查找到name，则前往外层作用域查找\n&#125;\n\n let school = '尚硅谷';\n        &#123;\n            // let school = '尚硅谷';\n            function fn()&#123;\n                console.log(school);\n            &#125;\n            fn();  //输出 尚硅谷\n        &#125;\nconst关键字使用const关键字声明 常量；\n\t1.const声明的变量在声明时就需要赋初值；\n\t2.const声明的基本数据类型值不能再改变，否则会报错；\n    3.但是const声明的对象（数组，函数）里面的值可以改变，因为栈中保存的const变量是保存的对象地址的引用；\n    4.const 声明的变量也具有块级作用域；\n    5.不允许重复声明；\n    \n    应用场景：声明对象类型使用 const，非对象类型声明选择 let；\n    \n    const num;   //报错 Missing initializer in const declaration\n\n    const a = 1;\n\ta = 2 ;  // 报错 Assignment to constant variable.\n\n\tconst obj = &#123;\n        name:\"Lk\"\n    &#125;\n    obj.name = \"LBJ\";\n\tconsole.log(obj);  // &#123;name: 'LBJ'&#125;\n\n\t\n解构赋值https://www.cnblogs.com/xiaohuochai/p/7243166.html\n\nES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。\n\n注意使用解构赋值时，解构的类型和赋值的类型要一致，对象->对象 数组 ->数组\n\n默认值：\n　使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为undefined；\n \n let node = &#123;\n    type: \"Identifier\",\n    name: \"foo\"\n&#125;;\nlet &#123; type, name, value &#125; = node;\nconsole.log(type); // \"Identifier\"\nconsole.log(name); // \"foo\"\nconsole.log(value); // undefined\n\n　这段代码额外定义了一个局部变量value，然后尝试为它赋值，然而在node对象上，没有对应名称的属性值，所以像预期中的那样将它赋值为undefined\n\n　　当指定的属性不存在时，可以随意定义一个默认值，在属性名称后添加一个等号(=)和相应的默认值即可\n\nlet node = &#123;\n    type: \"Identifier\",\n    name: \"foo\"\n&#125;;\nlet &#123; type, name, value = true &#125; = node;\nconsole.log(type); // \"Identifier\"\nconsole.log(name); // \"foo\"\nconsole.log(value); // true\n\n为非同名局部变量赋值：\n　如果希望使用不同命名的局部变量来存储对象属性的值，ES6中的一个扩展语法可以满足需求，这个语法与完整的对象字面量属性初始化程序的很像；\n \n let node = &#123;\n    type: \"Identifier\",\n    name: \"foo\"\n&#125;;\nlet &#123; type: localType, name: localName &#125; = node;\nconsole.log(localType); // \"Identifier\"\nconsole.log(localName); // \"foo\"\n\n\n//数组的解构赋值\nconst arr = ['LK','Zk','Lili'];\nlet [p1,p2,p3] = arr;\nconsole.log(p1,p2,p3);  // 输出 LK ZK Lili\n\nlet &#123;s1,s2,s3&#125; = arr;\nconsole.log(s1,s2,s3);  //输出 undefined undefined undefined （解构类型不一致）\n\n//对象解构赋值\nconst obj = &#123;\n    name:\"LK\",\n    age:12\n&#125;\nlet &#123;name,age&#125; = obj;\nconsole.log(name,age);  //输出 LK 12\n\n//复杂解构\nlet wangfei = &#123;\n name: '王菲',\n age: 18,\n songs: ['红豆', '流年', '暧昧', '传奇'],\n history: [\n &#123;name: '窦唯'&#125;,\n &#123;name: '李亚鹏'&#125;,\n &#123;name: '谢霆锋'&#125;\n ]\n&#125;;\nlet &#123;songs: [one, two, three], history: [first, second, third]&#125; = \nwangfei;\n\nconsole.log(one,two,three,first,second,third);\n//输出 红豆 流年 暧昧 &#123;name: '窦唯'&#125; &#123;name: '李亚鹏'&#125; &#123;name: '谢霆锋'&#125;\n\n解构赋值一般用于获取对象的方法用于简便表示：\nconst obj = &#123;\n    name:\"lk\",\n    fun:function()&#123;\n        console.log(this);\n    &#125;\n&#125;\nlet &#123;fun&#125; = obj; \nfun();  //输出 window\n模板字符串模板字符串（template string）是增强版的字符串，用反引号（``）标识，特点：\n1) 字符串中可以出现换行符\n2) 可以使用 $&#123;xxx&#125; 形式输出变量\n\nconst str = `hello`;\nconsole.log(str);  // 输出 hello\nconsole.log(typeof str);  //输出 string\n\nlet Text = `床前明月光\n            疑是地上霜\n            举头望明月\n            低头思故乡`;\nconsole.log(Text);\n\nlet num = 1;\nconsole.log(`$&#123;num&#125;2`);  //输出 12\nconsole.log(typeof `$&#123;num&#125;2`);  //输出 string\n简化对象写法ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\nlet name = '尚硅谷';\nlet slogon = '永远追求行业更高标准';\nlet improve = function () &#123;\n console.log('可以提高你的技能');\n&#125;\n//属性和方法简写\nlet atguigu = &#123;\n name,\n slogon,\n improve,\n change() &#123;\n console.log('可以改变你')\n &#125;\n&#125;;\n//对象中的属性如果和外部的全局变量名字一致，可以直接省去key:value 的写法，直接写value，对象中的方法也可以直接省去function关键字；\n箭头函数https://blog.csdn.net/qq_32614411/article/details/80897256\nES6 允许使用「箭头」（=>）定义函数。\n箭头函数的注意点:\n1) 如果形参只有一个，则小括号可以省略\n2) 函数体如果只有一条语句，则花括号可以省略（省略花括号时return必须省略），函数的返回值为该条语句的执行结果\n3) 箭头函数 this 指向声明时所在作用域下 this 的值（静态this）\n4) 箭头函数不能作为构造函数实例化\n5) 不能使用 arguments\n\n// 箭头函数适合与 this 无关的回调. 定时器, 数组的方法回调\n// 箭头函数不适合与 this 有关的回调.  事件回调, 对象的方法\n\nlet fun = () => &#123;\n    console.log(\"hello\");\n&#125;\nfun();  // 输出 hello\n\nconst n = 1;\nlet fun = n => &#123;\n    console.log(n);\n&#125;\nfun(n);  //输出1 如果形参只有一个 那可以省略()，但是如果没有形参那必须要有();\n\nconst fun2 = n => n*n;\nconsole.log(fun2(3));  //输出 9 ；如果箭头函数体只有一句代码则可以省略花括号，此时必须省略return 关键字，语句的执行结果就是函数的返回值\n\nconst Person = (name,age) => &#123;\n    this.name = name;\n    this.age = age;\n&#125;\nconst person = new Person(\"ZK\",12);  //报错 Person is not a constructor 箭头函数不能作为构造函数使用；\n\nconst fun = () =>&#123;\n    console.log(arguments);\n&#125;\nfunction fun2() &#123;\n    console.log(arguments);\n&#125;\nfun2(\"LK\");  //输出 Arguments ['LK', callee: ƒ, Symbol(Symbol.iterator): ƒ]\nfun(\"LK\");  //报错 arguments is not defined 箭头函数中不能使用 arguments\n\nconst name = \"LK\";\nfunction fun()&#123;\n    console.log(this.name);\n&#125;\nconst fun2 = () => &#123;\n    console.log(this.name);\n&#125;\nconst obj = &#123;\n    name:\"ZK\",\n&#125;\n\nfun();  //输出 LK\nfun2(); //输出 LK\nfun.call(obj);  //输出 ZK\nfun2.call(obj);  //输出 LK  无法通过call改变箭头函数的静态this\n\n箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。（词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变 。）\n\n\nconst Person = &#123;\n    firstName : \"hello\",\n    lastName : \"world\",\n    getFullName : function()&#123;\n        console.log(this);\n        let first = this.firstName;\n        const fun = function()&#123;\n            console.log(this);\n            return this.firstName + this.lastName;\n        &#125;\n        return fun();\n    &#125;\n&#125;\n\nlet str = Person.getFullName();\n//输出 Person对象 window全局对象\nconsole.log(str);   //输出 NaN\n\nconst Person = &#123;\n    firstName : \"hello\",\n    lastName : \"world\",\n    getFullName : function()&#123;\n        console.log(this);\n        let first = this.firstName;\n        const fun = () => &#123;\n            console.log(this);\n            return this.firstName + this.lastName;\n        &#125;\n        return fun();\n    &#125;\n&#125;\n\nlet str = Person.getFullName();\n//输出 Person对象 Person对象\nconsole.log(str);   //输出 helloworld\n\n","categories":["ES6语法"],"tags":["WEB前端"]},{"title":"线程机制与事件机制","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/31/线程机制与事件机制/","content":"进程与线程&lt;!--\n1. 进程：程序的一次执行, 它占有一片独有的内存空间\n2. 线程： CPU的基本调度单位, 是程序执行的一个完整流程\n3. 进程与线程\n  * 一个进程中一般至少有一个运行的线程: 主线程\n  * 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的\n  * 一个进程内的数据可以供其中的多个线程直接共享\n  * 多个进程之间的数据是不能直接共享的\n4. 浏览器运行是单进程还是多进程?\n  * 有的是单进程\n    * firefox\n    * 老版IE\n  * 有的是多进程\n    * chrome\n    * 新版IE\n5. 如何查看浏览器是否是多进程运行的呢?\n  * 任务管理器==>进程\n6. 浏览器运行是单线程还是多线程?\n  * 都是多线程运行的\n-->\n\n浏览器内核&lt;!--\n1. 什么是浏览器内核?\n  * 支持浏览器运行的最核心的程序\n2. 不同的浏览器可能不太一样\n  * Chrome, Safari: webkit\n  * firefox: Gecko\n  * IE: Trident\n  * 360,搜狗等国内浏览器: Trident + webkit\n3. 内核由很多模块组成\n  * html,css文档解析模块 : 负责页面文本的解析\n  * dom/css模块 : 负责dom/css在内存中的相关处理\n  * 布局和渲染模块 : 负责页面的布局和效果的绘制\n  * 布局和渲染模块 : 负责页面的布局和效果的绘制\n\n  * 定时器模块 : 负责定时器的管理\n  * 网络请求模块 : 负责服务器请求(常规/Ajax)\n  * 事件响应模块 : 负责事件的管理\n-->\n\n\nJS是单线程运行&lt;!--\n1. 如何证明js执行是单线程的?\n  * setTimeout()的回调函数是在主线程执行的\n  * 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行\n2. 为什么js要用单线程模式, 而不用多线程模式?\n  * JavaScript的单线程，与它的用途有关。\n  * 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。\n  * 这决定了它只能是单线程，否则会带来很复杂的同步问题\n\n3. 代码的分类:\n  * 初始化代码\n  * 回调代码\n4. js引擎执行代码的基本流程\n  * 先执行初始化代码: 包含一些特别的代码   回调函数(异步执行)\n    * 设置定时器\n    * 绑定事件监听\n    * 发送ajax请求\n  * 后面在某个时刻才会执行回调代码\n-->\n事件循环模型&lt;!--\n1. 所有代码分类\n  * 初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码\n  * 回调执行代码(异步代码): 处理回调逻辑\n2. js引擎执行代码的基本流程:\n  * 初始化代码===>回调代码\n3. 模型的2个重要组成部分:\n  * 事件(定时器/DOM事件/Ajax)管理模块\n  * 回调队列\n4. 模型的运转流程\n  * 执行初始化代码, 将事件回调函数交给对应模块管理\n  * 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中\n  * 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行\n-->\n\nhttps://www.cnblogs.com/cangqinglang/p/8967268.html\n\n\t一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。\n\n\t以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。\n\n\tjs引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。\n\n\n\nWeb Workers&lt;!--\n1. H5规范提供了js分线程的实现, 取名为: Web Workers\n2. 相关API\n  * Worker: 构造函数, 加载分线程执行的js文件\n  * Worker.prototype.onmessage: 用于接收另一个线程的回调函数\n  * Worker.prototype.postMessage: 向另一个线程发送消息\n  \t\t接受信息和发送信息方法的api都在Worker的原型对象身上\n3. 不足\n  * worker内代码不能操作DOM(更新UI)\n  * 不能跨域加载JS\n  * 不是每个浏览器都支持这个新特性\n-->\n\n//创建一个Worker对象\n    var worker = new Worker('worker.js')\n    // 绑定接收消息的监听\n    worker.onmessage = function (event) &#123;\n      console.log('主线程接收分线程返回的数据: '+event.data)\n      alert(event.data)\n    &#125;\n\n    // 向分线程发送消息\n    worker.postMessage(number)\n    console.log('主线程向分线程发送数据: '+number)\n\nworker.js :\n\nfunction fibonacci(n) &#123;\n  return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2)  //递归调用\n&#125;\n\nconsole.log(this)  //这里的this已经不再是window\nthis.onmessage = function (event) &#123;\n  var number = event.data\n  console.log('分线程接收到主线程发送的数据: '+number)\n  //计算\n  var result = fibonacci(number)\n  postMessage(result)\n  console.log('分线程向主线程返回数据: '+result)\n  // alert(result)  alert是window的方法, 在分线程不能调用\n  // 分线程中的全局对象不再是window, 所以在分线程中不可能更新界面\n&#125;\n\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"对象创建模式-继承模式","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/30/对象创建模式-继承模式/","content":"使用Object构造函数创建对象&lt;!--\n方式一: Object构造函数模式\n  * 套路: 先创建空Object对象, 再动态添加属性/方法\n  * 适用场景: 起始时不确定对象内部数据\n  * 问题: 语句太多\n-->\n  var obj = new Object();\n  obj.name = \"Lk\";\n  obj.age = 12;\n使用对象字面量创建对象&lt;!--\n方式二: 对象字面量模式\n  * 套路: 使用&#123;&#125;创建对象, 同时指定属性/方法\n  * 适用场景: 起始时对象内部数据是确定的\n  * 问题: 如果创建多个对象, 有重复代码\n-->\n\nvar obj = &#123;\n    name : \"Lk\";\n    age : 12;\n    fun :function()&#123;\n        console.log(this.name);\n    &#125;\n&#125;\n使用工厂模式创建对象&lt;!--\n方式三: 工厂模式\n  * 套路: 通过工厂函数动态创建对象并返回\n  * 适用场景: 需要创建多个对象\n  * 问题: 对象没有一个具体的类型, 都是Object类型\n-->\n\nfunction person(name,age)&#123;\n    var obj = &#123;\n        name :name,\n        age : age,\n        fun : function()&#123;\n            console.log(this.name);\n        &#125;\n    &#125;\n    return obj;\n&#125;\n\nvar p = person(\"LK\",12);\n自定义构造函数创建对象&lt;!--\n方式四: 自定义构造函数模式\n  * 套路: 自定义构造函数, 通过new创建对象\n  * 适用场景: 需要创建多个类型确定的对象\n  * 问题: 每个对象都有相同的数据, 浪费内存\n-->\n\nfunction Person(name,age)&#123;\n    this.name = name;\n    this.age = age;\n    this.fun = function()&#123;\n        console.log(this.name);\n    &#125;\n&#125;\n\nvar person = new Perosn(\"LK\",12);\n构造函数 + 原型的组合模式&lt;!--\n方式六: 构造函数+原型的组合模式\n  * 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上\n  * 适用场景: 需要创建多个类型确定的对象\n-->\n  \n function Person(name,age)&#123;\n     this.name = name;\n     this.age = age;\n &#125;\n\nPerson.prototype.fun = function()&#123;\n    console.log(this.name);\n&#125;\n\nvar person = new Person(\"LK\",12);\n\nconsole.log(person.fun()); //输出 LK\n原型链继承&lt;!--\n方式1: 原型链继承\n  1. 套路\n    1. 定义父类型构造函数\n    2. 给父类型的原型添加方法\n    3. 定义子类型的构造函数\n    4. 创建父类型的对象赋值给子类型的原型\n    5. 将子类型原型的构造属性设置为子类型\n    6. 给子类型原型添加方法\n    7. 创建子类型的对象: 可以调用父类型的方法\n  2. 关键\n    1. 子类型的原型为父类型的一个实例对象\n-->\n   \nfunction Person(name,age,sex)&#123;\n    this.name = name;\n    this.age = age;\n    this.sex = sex;\n&#125;\n\nPerson.prototype.getName = function()&#123;\n    console.log(this.name);\n&#125;\n\nfunction Student (grade,teacherName)&#123;\n    this.grade = grade;\n    this.teacherNmae = teacherName;\n&#125;\n\n//将子类的原型对象指向Person实例  --- 类型的原型为父类型的一个实例对象\nStudent.prototype = new Person();\n\n//将子类原型对象上的constructor指向Student构造函数 -- 让子类型的原型的constructor指向子类型\nStudent.prototype.constructor = Student;\n\nvar student = new Student(\"highSchool\",\"Tom\");\nPerson.call(student,\"LK\",12,\"man\"); \n\nconsole.log(student);\n//输出 Student &#123;grade: 'highSchool', teacherNmae: 'Tom', name: 'LK', age: 12, sex: 'man'&#125;\n\nstudent.getName();\n//输出 LK\n\n借用构造函数继承&lt;!--\n方式2: 借用构造函数继承(假的)\n1. 套路:\n  1. 定义父类型构造函数\n  2. 定义子类型构造函数\n  3. 在子类型构造函数中调用父类型构造\n2. 关键:\n  1. 在子类型构造函数中通用call()调用父类型构造函数\n-->\n  function Person(name,age,sex)&#123;\n    this.name = name;\n    this.age = age;\n    this.sex = sex;\n&#125;\n\nPerson.prototype.getName = function()&#123;\n    console.log(this.name);\n&#125;\n\nfunction Student (name,age,sex,grade,teacherName)&#123;\n    Person.call(this,name,age,sex);\n    this.grade = grade;\n    this.teacherNmae = teacherName;\n&#125;\n\n//将子类的原型对象指向Person实例  --- 类型的原型为父类型的一个实例对象\nStudent.prototype = new Person();\n\n//将子类原型对象上的constructor指向Student构造函数 -- 让子类型的原型的constructor指向子类型\nStudent.prototype.constructor = Student;\n\nvar student = new Student(\"Lk\",12,\"man\",\"highSchool\",\"Tom\");\n\nconsole.log(student);\n\nstudent.getName();\n\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"执行上下文-作用域链-闭包","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/29/执行上下文-作用域链-闭包/","content":"变量提升与函数提升&lt;!--\n1. 变量声明提升\n  * 通过var定义(声明)的变量, 在定义语句之前就可以访问到\n  * 值: undefined\n2. 函数声明提升\n  * 通过function声明的函数, 在之前就可以直接调用\n  * 值: 函数定义(对象)\n3. 问题: 变量提升和函数提升是如何产生的?\n    \t在浏览器开始执行JS代码之前，会先进行一些预处理，例如先实例化window全局对象，之后再提前执行JS代码中的var 变量声明和函数声明（函数声明将会被完全执行载入内存，而变量只会提前声明而不执行赋值；）；函数表达式将会看成为var 变量声明，提前调用函数将报错！！！\n-->\n  //变量提升优先级高于函数提升！！！\n  var a = 3\n  function fn () &#123;\n    console.log(a)  //在执行函数定义时，局部变量 var a先被执行，也就是说在打印a时，内存在已经存在a的声明但还没有执行赋值语句，所以此时打印a为undefined；\n    var a = 4\n  &#125;\n  fn()  //输出 undefined\nconsole.log(b) //undefined  变量提升\n  fn2() //可调用  函数提升\n   fn3() //输出 Uncaught TypeError: fn3 is not a function ； 变量提升  此时fn3只是提前声明为变量，还不是函数，提前调用将报错\n\n  var b = 3\n  function fn2() &#123;\n    console.log('fn2()')\n  &#125;\n\n  var fn3 = function () &#123;\n    console.log('fn3()')\n  &#125;\n执行上下文（Context）&lt;!--\n1. 代码分类(位置)\n  * 全局代码\n  * 函数(局部)代码\n2. 全局执行上下文\n  * 在执行全局代码前将window确定为全局执行上下文\n  * 对全局数据进行预处理\n    * var定义的全局变量==>undefined, 添加为window的属性\n    * function声明的全局函数==>赋值(fun), 添加为window的方法\n    * this==>赋值(window)\n  * 开始执行全局代码\n3. 函数执行上下文\n  * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)\n  * 对局部数据进行预处理\n    * 形参变量==>赋值(实参)==>添加为执行上下文的属性\n    * arguments==>赋值(实参列表), 添加为执行上下文的属性\n    * var定义的局部变量==>undefined, 添加为执行上下文的属性\n    * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法\n    * this==>赋值(调用函数的对象)\n  * 开始执行函数体代码\n-->\n  console.log(a1, window.a1)  //undefined undefined\n  window.a2()  //输出 'a2()'\n  console.log(this)  //输出 window\n\n  var a1 = 3\n  function a2() &#123;\n    console.log('a2()')\n  &#125;\n  console.log(a1)  //输出 3\n\n执行上下文栈\n&lt;!--\n1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象\n2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)\n3. 在函数执行上下文创建后, 将其添加到栈中(压栈)\n4. 在当前函数执行完后,将栈顶的对象移除(出栈)\n5. 当所有的代码执行完后, 栈中只剩下window\n-->\n\n如上图，在第24行添加断点，时函数此时的调用栈如右图所示：\n\t1.JS代码执行前进行预处理，将window确定为全局的context，变量 a，bar，foo声明提前；\n    2.开始执行第16行代码，a变量赋值为16；\n    3.开始执行第17~21行代码块，变量bar赋值为函数（此时只是在堆创建bar函数对象，不会执行里面的代码）；\n    4.开始执行第22~25行代码块，变量foo赋值为函数（此时只是在堆中创建foo函数对象，不会执行里面的代码）；\n    5.开始执行第26行代码块，调用bar函数，此时创建bar函数的执行上下文环境，并压入函数调用栈栈顶，此时栈底为window全局context，开始准备执行bar函数；\n    6.开始执行bar函数，运行至第19行时，调用foo函数，此时又创建一个foo函数的执行context，并压入调用栈栈顶，开始准备执行foo函数；\n    7.执行foo函数，在执行到24行代码时遇到断点，此时的调用栈就是上图所示；\n    8.执行24行断点，控制台输出 30 ；此时foo函数执行完毕，调用栈中的foo函数执行context出栈，并销毁；此时的调用栈情况如下图：\n\n9.可知此时调用栈的栈顶为bar函数执行context，继而继续执行第20行代码；\n10.执行第20行断点，控制台输出11，此时函数bar执行完毕，bar函数执行context也要出栈并销毁；\n11.js代码执行完毕，此时调用栈中只剩下全局window执行context；\n\n  /*\n   测试题1:  先执行变量提升, 再执行函数提升\n   */\n  function a() &#123;&#125;\n  var a\n  console.log(typeof a) // 'function'\n/*\n实际的代码执行顺序如下：\n\tvar a;\n\tfunction a()&#123;&#125;\n\t此时这里虽然已经声明了a，但是后面声明的a函数将其值设定为函数；\n\tconsole.log(typeof a);\n\t\n\t注意在js中可以使用var关键字重复声明同一变量名，浏览器在执行代码时若发现使用var关键字声明的变量已经存在时不会报错，而是跳过；\n*/\n\n  /*\n   测试题2:\n   */\n  console.log(d);  // 报错  d is not defined\n  console.log(window);  //在这里可以看到b，说明变量b有声明提升\n  if (!(b in window)) &#123; //所以if语句不成立，赋值语句不会执行，所以b只是声明了但是未赋值\n    var b = 1  // 这里的b存在变量声明提升！！！\n  &#125;\n  console.log(b) // undefined\n注意：在if/for语句var定义的变量会提升(在严格模式下一样)(chrome/firefox/IE)；\n\n\n /*\n   测试题3:\n   */\n  var c = 1\n  function c(c) &#123;\n    console.log(c)\n    var c = 3\n  &#125;\n  c(2) // 报错 这里调用c函数将报错！\n/*\n实际的代码执行顺序为：\n\tvar c;\n\tfunction c(c)&#123;\n\tconsole.log(c);\n\tvar c = 3;\n\t&#125;\n\tc = 1;\n\tc(2);\n\t\n\t可知变量声明提升先声明了一个变量c，执行将c赋值为一个函数对象，之后再将c赋值为1；\n\t此时c成为了一个基本数据而不是函数，一调用将会出错；\n*/\n作用域&lt;!--\n1. 理解\n  * 就是一块\"地盘\", 一个代码段所在的区域\n  * 它是静态的(相对于上下文对象), 在编写代码时就确定了\n2. 分类\n  * 全局作用域\n  * 函数作用域\n  * 没有块作用域(ES6有了)\n3. 作用\n  * 隔离变量，不同作用域下同名变量不会有冲突\n-->\nvar a = 10,b = 20;\n  function fn(x) &#123;//传入10 局部变量x = 10\n    var a = 100, c = 300;  //全局变量\n    console.log('fn()', a, b, c, x)  // 输出 fn() 100 20 300 10\n\n    function bar(x) &#123;  //1.传入局部变量 x = 100\n      var a = 1000,  d = 400 //局部\n       \n      console.log('bar()', a, b, c, d, x)  \n    &#125;\n\n    bar(100)  //输出 bar() 1000 20 300 400 100\n    bar(200)   //输出 bar() 1000 20 300 400 200\n  &#125;\n  fn(10)\n作用域与执行上下文&lt;!--\n1. 区别1\n  * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时\n  * 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建\n  * 函数执行上下文是在调用函数时, 函数体代码执行之前创建\n2. 区别2\n  * 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化\n  * 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放\n3. 联系\n  * 执行上下文(对象)是从属于所在的作用域\n  * 全局上下文环境 ==>全局作用域\n  * 函数上下文环境 ==>对应的函数使用域\n-->\n作用域链&lt;!--\n1. 理解\n  * 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)\n  * 查找变量时就是沿着作用域链来查找的\n2. 查找一个变量的查找规则\n  * 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2\n  * 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3\n  * 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常\n-->\n\nvar x = 10;\n  function fn() &#123;\n    console.log(x);\n  &#125;\n  function show(f) &#123;\n    var x = 20;\n    f();\n  &#125;\n  show(fn);  // 输出 10 \n/*\n在执行到show函数时，此时函数调用栈从上到下的为 show ，window；\n执行show时，此时的this是window；\n在show()函数中执行fn()函数时，调用栈从上到下依次为 fn , show , window ;\n虽然此时是在show函数内部执行fn函数，但是fn函数的外层作用域应该是全局作用域，而不是show函数的局部作用域；\n因为函数作用域是静态的，在函数定义代码书写好的时候就确定了，不会再变化；\n*/\n\n\n  var fn = function () &#123;\n    console.log(fn)\n  &#125;\n  fn()  //输出 fn函数\n\n/*\n\t这里调用fn函数时，fn函数内部不存在fn变量，则前往全局变量上查找，查找到其本身然后输出；\n*/\n\n  var obj = &#123;\n    fn2: function () &#123;\n     console.log(fn2)  //这里会报错\n     console.log(this.fn2)  //打印fn2\n    &#125;\n  &#125;\n  obj.fn2()  //报错 \n\n/*\n调用对象obj身上的fn2()方法时，若在里面直接输出fn1，则会先在fn2函数内部作用域查找，但是此时并不存在fn2变量，则前往全局作用域查找，也不存在，则输出 fn2 is not defined；\n\t若在fn2函数内部输出 this.fn2 ,因为此时是调用obj对象的方法，所以此时函数执行的上下文中的this指向obj，所以此时输出 this.fn2 不会报错\n*/\n\n闭包\n\n闭包是指有权访问另一个函数作用域中的变量的函数。\n\t闭包是可以在另一个函数的外部访问到其作用域中的变量的函数。而被访问的变量可以和函数一同存在。即使另一个函数（外部函数）已经运行结束，导致创建变量的环境销毁，也依然会存在，直到访问变量的那个函数被销毁。\n&lt;!--\n1. 如何产生闭包?\n  * 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包\n2. 闭包到底是什么?\n  * 使用chrome调试查看\n  * 理解一: 闭包是嵌套的内部函数(绝大部分人)\n  * 理解二: 包含被引用变量(函数)的对象(极少数人)\n  * 注意: 闭包存在于嵌套的内部函数中\n3. 产生闭包的条件?\n  * 函数嵌套\n  * 内部函数引用了外部函数的数据(变量/函数)\n\n闭包有3个特性：\n①函数嵌套函数\n②函数内部可以  引用  函数外部的参数和变量\n③被引用的外部参数和变量不会被垃圾回收机制回收\n-->\n\nfunction fn1 () &#123;\n    var a = 2\n    var b = 'abc'\n    function fn2 () &#123; //执行函数定义就会产生闭包(不用调用内部函数)\n      console.log(a)\n    &#125;\n    fn2()\n  &#125;\n  fn1()\n/*\n代码解析：\n\t在函数fn1中，定义了一个内部函数fn2，而且fn2引用了外部函数的数据变量 a ，闭包会在执行函数定义时就产生而不是再调用内部函数，具体可查看下图1：在调用fn2内部函数时，已经存在闭包Closure；\n\t在fn1中调用fn2时，此时闭包完全可见，见下图2\n*/\n\n\n在调用内嵌函数时并产生闭包时，如果没有全局变量指向闭包在堆中产生的对象，则在函数执行完毕时，闭包就会成为垃圾对象并且销毁；\n\n&lt;!--\n1. 将函数作为另一个函数的返回值\n2. 将函数作为实参传递给另一个函数调用\n-->\n\n // 1. 将内嵌函数作为另一个函数的返回值\n  function fn1() &#123;\n    var a = 2\n    function fn2() &#123;\n      a++ //这里的a是外层函数的a，内嵌函数访问外部的数据，产生闭包\n      console.log(a)\n    &#125;\n    return fn2\n  &#125;\n  var f = fn1()\n  f() // 3\n  f() // 4\n\n/*\n\t在执行函数定义时，fn1内部就产生了闭包，此时在闭包中保存了局部变量 a 的地址（换言之在闭包中可以访问得变量a），在执行 var f = fn1() 时，全局变量f保存了返回的fn2的地址值，因此，在fn1函数执行完毕时，闭包没有成为垃圾对象而销毁（因为此时有f指向它），因此被闭包中所访问到的fn1函数中的局部变量a也没有被销毁，f可以通过闭包访问到之前定义的局部变量a；（在这里闭包就是fn2，闭包是指有权访问另一个函数作用域中的变量的函数。）\n\t在第一次执行 f()函数，因为闭包中的a变量为2，a++ 后成为3 之后打印输出并结束f函数；\n\t在第二次执行f()函数，闭包中的a变量为3，a++后成为4，之后打印输出并结束f函数；\n*/\n\n\n  // 2. 将函数作为实参传递给另一个函数调用\n  function showDelay(msg, time) &#123;\n    setTimeout(function () &#123;\n      alert(msg) //这里再延时器内部回调函数中访问了外部函数的参数，产生了闭包，并没有全局变量获取该内部函数（闭包）的地址值，所以在showDelay执行完毕后，闭包也将成为垃圾对象被销毁；\n    &#125;, time)\n  &#125;\n  showDelay('atguigu', 2000)\n\n其实，用两个函数形成闭包只是一般形式。闭包真正的含义是，如果一个函数访问了此函数的父级及父级以上的作用域变量，就可以称这个函数是一个闭包。\n闭包的作用&lt;!--\n1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)\n2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)\n\n问题:\n  1. 函数执行完后, 函数内部声明的局部变量是否还存在?  一般是不存在, 存在于闭包中的变量才可能存在\n  2. 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它\n-->\n闭包的生命周期&lt;!--\n1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)\n2. 死亡: 在嵌套的内部函数成为垃圾对象时\n-->\n补充：js代码在执行前函数声明提升已经执行完了，我们无法使用浏览器的断点调试查看，函数声明提升只是说在js执行前先在堆中创建该函数对象，并在栈中保存该函数对象的地址引用；函数执行只有调用了函数才会进行；\nfunction fn1() &#123;\n    //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了，但在没调用fn1时，堆中只有fn1函数对象，只有调用了fn1，才开始执行内部代码，才会创建内部函数对象fn2)\n    var a = 2\n    function fn2 () &#123;\n      a++\n      console.log(a)\n    &#125;\n    return fn2\n  &#125;\n  var f = fn1()\n  f() // 3\n  f() // 4\n  f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)\n闭包的应用-自定义JS模块&lt;!--\n闭包的应用2 : 定义JS模块\n  * 具有特定功能的js文件\n  * 将所有的数据和功能都封装在一个函数内部(私有的)\n  * 只向外暴露一个包信n个方法的对象或函数\n  * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能\n-->\n\n方法1：js文件直接向外暴露闭包方法：（需要先执行js文件的方法才能获取闭包）\nmyModule.js：\n\tfunction myModule() &#123;\n  //私有数据\n  var msg = 'My atguigu'\n  //操作数据的函数\n  function doSomething() &#123;\n    console.log('doSomething() '+msg.toUpperCase())\n  &#125;\n  function doOtherthing () &#123;\n    console.log('doOtherthing() '+msg.toLowerCase())\n  &#125;\n\n  //向外暴露对象(给外部使用的方法)\n  return &#123;\n    doSomething: doSomething,\n    doOtherthing: doOtherthing\n  &#125;\n&#125;\n\n&lt;script type=\"text/javascript\" src=\"myModule.js\">&lt;/script>\n&lt;script type=\"text/javascript\">\n  var module = myModule()  //需要先手动调用myModule方法才能获取到闭包\n  module.doSomething()\n  module.doOtherthing()\n&lt;/script>\n\n方法2：js文件中将闭包封装到一个对象身上，再将其暴露出去：（使用匿名函数立即执行，不需要手动调用函数，js模块文件载入成功时window身上就存在该模块属性）\nmyModule.js:\n(function () &#123;\n  //私有数据\n  var msg = 'My atguigu'\n  //操作数据的函数\n  function doSomething() &#123;\n    console.log('doSomething() '+msg.toUpperCase())\n  &#125;\n  function doOtherthing () &#123;\n    console.log('doOtherthing() '+msg.toLowerCase())\n  &#125;\n\n  //向外暴露对象(给外部使用的方法)\n  window.myModule2 = &#123;\n    doSomething: doSomething,\n    doOtherthing: doOtherthing\n  &#125;\n&#125;)()\n\n&lt;script type=\"text/javascript\" src=\"myModule2.js\">&lt;/script>\n&lt;script type=\"text/javascript\">\n  myModule2.doSomething()  //直接使用window身上的myModule属性上的方法\n  myModule2.doOtherthing()\n&lt;/script>\n闭包的缺点和解决方法&lt;!--\n1. 缺点\n  * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长\n  * 容易造成内存泄露\n\t\t * 占用的内存没有及时释放\n          * 内存泄露积累多了就容易导致内存溢出\n\t\t\t内存溢出\n                  * 一种程序运行出现的错误\n                  * 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误\n              * 常见的内存泄露:\n                * 意外的全局变量  -- 在函数定义域中声明变量未使用var关键字 导致变量成为全局变量；\n                * 没有及时清理的计时器或回调函数\n                * 闭包\n2. 解决\n  * 能不用闭包就不用\n  * 及时释放\n-->\n\n  function fn1() &#123;\n    var arr = new Array[100000]\n    function fn2() &#123;\n      console.log(arr.length) //内部函数访问外部变量，产生闭包\n    &#125;\n    return fn2\n  &#125;\n  var f = fn1()\n  f()\n\n  f = null //让内部函数成为垃圾对象-->回收闭包\n面试题  //代码片段一\n  var name = \"The Window\";\n  var object = &#123;\n    name : \"My Object\",\n    getNameFunc : function()&#123;\n      // var name = \"LK\";\n        console.log(this.name);  //  My Object\n      return function()&#123;\n        return name;\n        // return this.name;\n      &#125;;\n    &#125;\n  &#125;;\n  console.log(object.getNameFunc()());  //?  the window\n/*\n\t如果 var name = \"LK\" 这一行代码被注释掉，那getNameFunc这一函数中返回的内部函数并没有产生闭包，原因在于返回的内部匿名函数并没有访问到外部函数的变量，故此时只是返回了一个普通的匿名函数（用于输出name）；\n\t此时执行object.getNameFunc()获得的就是上述的普通匿名函数，直接调用该返回的匿名函数object.getNameFunc()()，在里面输出name，因为此时的函数执行上下文是window，则直接输出了\n\tThe Window（改成输出this.name 也是同样的结果，因为执行上下文依旧是window）；\n\t\n\t但如果 var name = \"LK\" 这一行代码存在，那么getNameFunc()这一函数内部的匿名函数就是闭包（因为其访问了外部函数的name），所以此时object.getNameFunc()得到的就是闭包的地址引用，之后直接调用闭包object.getNameFunc()()，将获得getNameFunc函数的内部数据Name；从而输出 LK  ；\n*/\n\n //代码片段二\n  var name2 = \"The Window\";\n  var object2 = &#123;\n    name2 : \"My Object\",\n    getNameFunc : function()&#123;\n      var that = this;\n      return function()&#123;\n        return that.name2;\n      &#125;;\n    &#125;\n  &#125;;\n  console.log(object2.getNameFunc()()); //?  my object\n/*\n产生了闭包，在返回的匿名函数中访问了外部的this，此时的this指向object2本身（object2.getNameFunc()是object2调用它身上的getNameFunc方法）下图1，后面再执行返回的匿名函数时，this指向window；下图2\n*/\n\n\nfunction fun(n,o) &#123;\n\n    console.log(o)\n    \n    return &#123;\n      fun:function(m)&#123;\n        return fun(m,n)  //产生闭包 访问了外部的参数m\n      &#125;\n    &#125;\n\n  &#125;\n\n  /*\n    首先调用fun函数返回的是一个对象&#123;&#125;，对象中有一个方法fun，该方法会返回调用全局函数fun后的值；\n\n    在全局函数fun中，返回的对象中的方法fun访问了全局函数的形参n，从而产生了闭包；\n\n    执行 var a = fun(0)：\n         首先调用全局函数fun，传入参数 0 ，此时fun函数需要的两个参数： n = 0； o = undefined；\n          在函数内部输出 参数 o ，为undefined；\n          返回对象&#123;\n                    fun:function(m)&#123;\n                      return fun(m,n);\n                    &#125;\n                &#125;\n                在执行该返回值定义时，就产生了闭包，因为该返回对象中的方法fun中，返回fun调用访问了全局函数fun的参数n\n                （返回值中的参数m在这里不属于外部变量，m与返回值在同一个函数作用域中）；\n          全局变量 a 引用返回的对象，该对象中包含闭包（对象中的方法fun），此时闭包中的n值为0；\n    \n    执行变量a中的方法（因为此时a指向一个对象）fun，并传入参数 1 ；\n          执行fun(1)方法, 即执行 function(1)&#123;\n                              return fun(1,n);  \n                            &#125;\n                此时在该函数内部又调用全局函数fun，传入的两个参数为： n = 1 ，o = 0（这里的0时闭包中n的值）\n                            打印输出o，为 0 ；\n                             返回对象&#123;\n                                      fun:function(m)&#123;\n                                        return fun(m,n);\n                                      &#125;\n                                  &#125;\n                              在执行该返回值定义时，有产生了新的闭包（内部函数返回值访问了外部的函数的参数n，此时n为1），\n                              但是语句 a.fun(1) 只是调用对象方法，没有使用变量来引用返回的闭包函数地址，所以当这一语句执行完毕时\n                              fun函数执行上下文环境销毁，内部闭包函数成为垃圾对象也一同被销毁；\n      \n      后面的 a.fun(2)  a.fun(3) 语句均和 a.fun(1) 语句一样 输出0（闭包中的n） ，这些语句执行完存在的都是同一个闭包，而且闭包引用的内部变量n值从未改变；\n\n\n  */\n\n  var a = fun(0)  //输出 undefined 返回fun函数\n  a.fun(1)  // 0\n  a.fun(2)  // 0 \n  a.fun(3)  // 0\n\n  var b = fun(0).fun(1).fun(2).fun(3)//undefined,0,1,2\n  b.fun(100);  //输出 3\n  /*\n      执行 var b = fun(0) 输出 undefined 并返回一个对象，对象中包含的方法fun是闭包函数（引用外部变量 n = 0）\n          执行返回的对象中的方法fun，传入参数1，输出 0（当前执行环境中的闭包中的引用变量n），之后返回对象，对象中包含的方法fun又是一个新的闭包（引用外部变量 n = 1）\n              执行返回的对象中的方法fun，传入参数2，输出 1 （当前执行环境中的闭包的引用变量n），之后返回对象，对象中包含的方法fun又是一个新的闭包（引用我外部变量 n = 2）\n                  执行返回的对象中的方法fun，传入参数3，输出 2 （当前执行环境中的闭包的引用变量n），之后返回对象，对象中包含的方法fun又是一个新的闭包（引用我外部变量 3 = 2）\n  \n      在这里由于返回了对象又立即调用对象中的方法，而调用方法又会返回新的对象从而导致之前返回的对象成为垃圾对象，产生的闭包也随着一起销毁；\n  */\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"原型-原型链","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/28/原型-原型链/","content":"原型&lt;!--\n1. 函数的prototype属性(图)\n  * 每个函数都有一个prototype属性, 它默认指向一个Object实例空对象(可称其为当前函数的原型对象，这里的空对象并不等与null，而是说在初始时我们还没有在其身上定义自己的方法和属性，初始时该对象身上已经有了默认隐含的constructor，其指回函数本身)\n  * 原型对象中有一个属性constructor, 它指向函数对象\n2. 给原型对象添加属性(一般都是方法)\n  * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)\n-->\n\n\n//声明一个构造函数\nfunction Fun()&#123;\n    console.log(\"这是Fun构造函数！\");\n&#125;\n//查看当前构造函数的原型对象\nconsole.log(Fun.prototye);\n/*\n在这里打印Fun的原型对象时发现此时已经存在了下面代码语句执行后的属性 --- 给Fun原型对象添加\ntest()方法，在这里以我目前的找到的有两种解释：\n\n\t1.声明提前，因为此时Fun函数对象已经存在，所以下面的语句 Fun.prototype.test = function\n\t会被提前执行，也就是说在执行到打印原型对象时，原型对象身上已经有了test(并且知道此时test是方法)，但是此时还没有执行赋值语句，此时打印出test为undefined；\n\t\n\t2.浏览器显示的最终结果；\n\t\n\t我倾向第一种解释；\n*/\n//通过构造函数身上的prototype属性给它的原型对象身上添加属性\nFun.prototype.test = function ()&#123;\n    console.log(\"test()\");\n&#125;\n//添加给原型对象的方法可以通过实例对象访问到\nvar fun = new Fun();  //输出 这是Fun构造函数！\nfun.test();  //输出 test()\n\n给window添加方法或属性的声明提前 console.log(window);\n\n console.log(window.aLK);\n\n window.aLK = function ()&#123;\n        console.log(\"这是自定义的window方法\");\n    &#125;\n\n  console.log(window.aLK);\n/*\n从下图可知在还没有执行\n\twindow.aLK = function ()&#123;\n        console.log(\"这是自定义的window方法\");\n    &#125;\n 这一代码时，window身上已经有了aLK这一属性，而且知道aLK是方法，所以可知此时给全局变量添加属性或方法将会提前声明，但是不会赋值；\n*/\n\n显示原型与隐式原型&lt;!--\n1. 每个函数function都有一个prototype，即显式原型(属性)\n\t\t其实每个函数都有显式原型属性和隐式原型属性；\n2. 每个实例对象都有一个__proto__，可称为隐式原型(属性)\n\t\t实例对象只有隐式原型属性；\n3. 实例对象的隐式原型的值为其对应构造函数的显式原型的值\n4. 内存结构(图)\n5. 总结:\n  * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象\n  * 实例对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值\n  * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)\n-->\n\n//定义构造函数\n  function Fun() &#123;   // 内部语句: this.prototype = &#123;&#125;\n\n  &#125;\n  \nvar fun = new Fun();  // 内部语句: this.__proto__ = Fun.prototype\n\nconsole.log(fun.prototype);  //输出 undefined  -- 实例对象身上没有prototype属性；\n\nconsole.log(fun.__proto__);   //输出 &#123;constructor: ƒ&#125;\n\nconsole.log(Fun.prototype === fun.__proto__);  //输出 true\n\n/*\n\t可知构造函数的显示原型prototype的值 === 其实例对象的隐式原型__proto__ 的值；\n*/\n\n原型链&lt;!--\n1. 原型链\n  * 访问一个对象的属性时，\n    * 先在自身属性中查找，找到返回\n    * 如果没有, 再沿着__proto__这条链向上查找, 找到返回\n    * 如果最终没找到, 返回undefined\n  * 别名: 隐式原型链\n  * 作用: 查找对象的属性(方法)\n2. 构造函数/原型/实体对象的关系\n3. 构造函数/原型/实体对象的关系2\n-->\n\n图解：\n//定义一个Fn构造函数\nfunction Fn()&#123;\n    this.test1 = function ()&#123;\n        console.log(\"这是Fn构造函数里的test1方法！\");\n    &#125;\n&#125;\n/*\n以下解释的地址值只是为了方便表示\n\n\t在执行这一代码块时浏览器已经完成的工作：\n\t\n\t\tObject对象为浏览器的全局对象，在网页加载分配内存区域时，浏览器自动在堆空间0x345创建Object的原型对象（其身上包含toString()和hasOwnProperty()等方法，其中该原型对象的隐式原型__proto__值为null）；\n\t\t并在堆空间0x456创造Object构造函数对象（它的显式原型对象prototype值为堆地址0x345，指向Object原型对象），之后再栈空间分配内存空间存分全局变量Object，其对应的数据值为堆地址0x456；\n\t\t\n\t开始执行这一代码块：\n\t\n\t浏览器先根据已存在的Object构造函数在堆内存0x234创建一个Object实例对象，这个Object的实例对象身上的隐式原型__proto__值为0x345，指向Object原型对象；\n\t轴浏览器在堆内存区域划分一块地址为0x123的内存空间存放Fn构造函数对象，该构造函数的显式原型prototype值为堆地址0x234（此时之前创造的Object实例成为Fn构造函数的原型对象），之后浏览器在栈空间分配一块内存存放变量名Fn，Fn对应的数据值中存放堆地址0x123；\n*/\n\n//给Fn的原型对象身上添加方法\nFn.prototype.test2 = function()&#123;\n    console.log(\"我是Fn原型对象身上的test2函数\");\n&#125;\n/*\n\t此时在堆内存0x234创建方法test2；\n*/\n\n//创建Fn实例对象fn\nvar fn = new Fn();\n/*\n\t现在堆内存0x567创建Fn的实例对象fn，将其隐式原型__proto__值设置为0x234，之后在fn实例对象中创建test1()方法；\n\t最后在栈空间分配内存存分全局变量fn，fn中的数据值为堆地址0x567；\n*/\n\n以上就是这几句代码所执行时浏览器在内存操作的步骤；\n跟着实例对象的隐式原型__proto__所追溯的关系链成为隐式原型链（原型链），原型链在Object的原型对象处结束；\n\n堆内存区域的Object构造函数也属于函数，只要是函数就有隐式原型__proto__;\nconsole.log(Object.__proto__); //输出 ƒ () &#123; [native code] &#125;\n\nconsole.log(Fn.prototype instanceof Object) // true  Fn构造函数的显式原型默认为空的Object实例对象；\n\nconsole.log(Fn.prototype === &#123;&#125;);   //false Fn构造函数的显式原型初始时默认的Object空对象实例是指其内部还没有我们自定义的方法和属性，并不是指真的为null；\n\n/*\n  1. 函数的显式原型指向的对象默认是空Object实例对象(但Object不满足)\n   */\n\n console.log(Function.prototype instanceof Object) // true  Function构造函数的显式原型也是Object的一个实例（既然是实例，那Function构造函数的显式原型（Function.prototype）也有它的隐式原型__proto__，它的值指向Object原型对象；）\n\n console.log((Object.prototype) instanceof Object);  // 输出 false  Object的构造函数的显式原型prototype指向Object原型对象，而不是Object实例，所以返回false；\n\n /*\n  2. 所有函数都是Function的实例(包含Function)\n  */\n\n console.log(Fn.prototype === Fn.__proto__);  //false  \n\n console.log(Fn.prototype instanceof Object); //true  函数的显式原型都是指向Object实例（除了Object构造函数以外）；\n\n console.log(Fn.__proto__ === Function.prototype);  //true  见下面的长注释\n\n console.log(Fn instanceof Function);  //true  见下面的长注释\n\n/*\n\tFn构造函数的显式原型prototype指向的是Object实例（Fn.prototype），Fn构造函数的隐式原型__proto__指向的是Function.prototype(因为Fn构造函数算是Function构造函数的一个实例，所以实例的隐式原型等于其构造函数的显式原型)\n*/\n\nconsole.log(Object.__proto__ === Function.prototype);  //true  Object构造函数也是Function构造函数的一个实例；\n\nconsole.log(Function.__proto__=== Function.prototype) //true  Function构造函数的显示原型和隐式原型都指向同一个对象（Function.prototype），说明 Function = new Function() \n\n/*\n  3. Object的原型对象是原型链尽头\n   */\nconsole.log(Function.prototype.__proto__);  //输出Object原型对象\n\nconsole.log(Function.prototype.__proto__.__proto__);  // null\n\nconsole.log(Fn.prototype.__proto__);  //输出Object原型对象\n\nconsole.log(Fn.prototype.__proto__.__proto__);  //null\n\nconsole.log(Function.prototype.__proto__ === Fn.prototype.__proto__);  // true 两者都是Object原型对象；\n\nconsole.log(fn.__proto__.__proto__);  // 输出 Object原型对象\n\nconsole.log(fn.__proto__.__proto__.__proto__);  //null\n\n总结：\n\t1.所有的函数的显式原型prototype都指向一个Object实例（除了Object构造函数以外，Object构造函数的显式原型prototype指向Object原型，其他构造函数的显式原型的隐式原型才指向Object原型）；\n    \n    2.所有函数的隐式原型__proto__都是向Function.prototype(因为所有的函数都是Function构造函数的一个实例，实例的隐式原型等于其构造函数的显式原型)，并且Function构造函数的显式原型等于其隐式原型；即：Function() = new Function() \n\n\t3.Object原型是原型链的尽头；\n原型链的属性问题&lt;!--\n1. 读取对象的属性值时: 会自动到原型链中查找\n2. 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值\n3. 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上\n-->\ninstanceof原理&lt;!--\n1. instanceof是如何判断的?\n  * 表达式: A instanceof B\n  * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false\n2. Function是通过new自己产生的实例\n-->\n\n/*\n  案例1\n   */\n  function Foo() &#123;  &#125;  //定义一个Foo构造函数；\n  var f1 = new Foo()   //创建一个Foo实例对象f1\n  console.log(f1 instanceof Foo) // true\n  console.log(f1 instanceof Object) // true\n\n  /*\n  案例2\n   */\n  console.log(Object instanceof Function) // true\n/*\n\tA:Object , Object.__proto__ --->  Object原型\n\tB:Function , Function.prototype ---> Object原型\n\t\t故Object构造函数是Function构造函数的一个实例\n*/\n\n  console.log(Object instanceof Object) // true\n/*\n\tA:Object, Object.__proto__  ---> Function.prototype , \n\t\tFunction.prototype.__proto__ ---> Object原型\n\tB:Object, Object.prototype ---> Object原型\n\t\t故Object是Object的一个实例；\n*/\n\n  console.log(Function instanceof Function) // true \n/*\n\tA:Function, Function.__proto__ ---> Function.prototype ,\n\t\tFunction.prototype.__proto__ ---> Object原型\n\tB:Function, Function.prototype ---> Object原型\n\t\t故Function是 Function 的实例（Function.prptotype === Function.__proto__）\n*/\n\n  console.log(Function instanceof Object) // true\n/*\n\tA:Function, Function.__ptoto__  ---> Function.prototype\n\t\tFunction.prototype.__ptoto__ ---> Object原型\n\tB:Object, Object.prototype ---> Object原型\n\t\t故Function构造函数是Object的一个实例\n*/\n\n  function Foo() &#123;&#125;\n  console.log(Object instanceof  Foo) // false\n/*\n\tA:Object ,Object.__proto__ ---> Function.prototype\n\t\tFunction.prototype.__proto___ ---> Object原型对象\n\tB:Foo, Foo.prototype ---> 这个类的原型对象\n\t\t两者没有交集，所以Object构造函数不是Foo的一个实例；\n*/\n\n总结：\n\tA instanceof B 中，A的隐式原型若存在，则可以一直沿着A的隐式原型链往下走，若在A的隐式原型链上出现了B的显式原型B.prototype，则可称A是B的一个实例，否则A不是B的一个实例；（B只能沿着显式原型走一次）\n面试题 /*\n  测试题1\n   */\n//声明创造一个A构造函数\n  function A () &#123;\n\n  &#125;\n//给A的原型对象身上添加属性\n  A.prototype.n = 1\n//创建A的实例对象b\n  var b = new A()\n//修改A的prototype指向，指向一个新的原型对象\n  A.prototype = &#123;\n    n: 2,\n    m: 3\n  &#125;\n//再创建一个A的实例c\n  var c = new A()\n  console.log(b.n, b.m, c.n, c.m)  // 输出 1 undefined 2 3\n/*\n\t在创建A的实例对象b时，内部执行 this.__proto__ = A.prototype , 所以此时b的隐式原型对象等于A的显式原型对象；\n\t后面修改A.prototype时，即为将A的显式原型对象更改为&#123;n:2,m:3&#125;这一新对象，但是不会影响已经实例化的b的隐式原型对象；\n\t最后再创建A的实例c时，内部执行 this.__proto__ = A.prototype ,即c.__proto__ = &#123;n:2,m:3&#125; \n*/\n\n/*\n   测试题2\n   */\n  function F ()&#123;&#125;\n  Object.prototype.a = function()&#123;\n    console.log('a()')  //Object.prototype  --> Object原型\n  &#125;\n  Function.prototype.a = function()&#123;\n    console.log('b()')\n  &#125;\n var f = new F()\n  f.a()  // a() 实例对象按他的隐式原型链查找（f实例->f实例的原型对象->Object原型）\n  f.b()  //执行报错\n  F.a()  //a()  此时将构造函数看成对象，也按它的隐式原型链查找（F->Function.prototype->Object原型）\n  F.b()  //b()  （F->Function.prototype）\n\n补充：在上题中，若将构造函数修改成如下：\n\n  function F ()&#123;\n    var a = function()&#123;  \n //这里如果不使用var， a方法 将变成window身上的方法,使用 var 将变成在构造函数创造实例对象时的一个局部变量，一旦构造函数程序执行完毕，该局部变量将销毁，不会存在实例对象身上；\n      console.log(\"我是F里的a函数\");\n    &#125;\n    //如果需要在构造函数创造实例对象时给实例对象添加方法，需要使用this关键字\n    this.A = function()&#123;\n        ....\n    &#125;\n  &#125;\n\n//使用window也能访问到Object原型身上的方法\n console.log(window instanceof Object);  //true\n console.log(window instanceof Function); //false\n console.log(window.__proto__.__proto__.__proto__.__proto__); //Object原型\n console.log(window.__proto__.__proto__.__proto__.__proto__.__proto__);  //null\n\n\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"JS进阶-基础总结","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/27/JS进阶-基础总结/","content":"数据类型&lt;!--\n1. 分类\n  * 基本(值)类型\n    * String: 任意字符串\n    * Number: 任意的数字，NaN（非数值）\n    * boolean: true/false\n    * undefined: undefined\n    * null: null\n  * 对象(引用)类型\n    * Object: 任意对象\n    * Function: 一种特别的对象(可以执行)\n    * Array: 一种特别的对象(数值下标, 内部数据是有序的)\n2. 判断\n  * typeof:\n    * 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function\n    * 不能判断: null与object  object与array ， null 与 Array 使用typeof 均返回 object\n  * instanceof:\n    * 判断对象的具体类型  --- 用来判断对象的类型（Array，Function），注意只能用来判断对象！！！\n  * === （全等）\n    * 可以判断: undefined, null\n-->\n\nvar a ; //声明变量a但不赋值；\nconsole.log(a , typeof a ,typeof  a === 'undefined', a === undefined);\n//输出 undefined 'undefined' true true\n//可知typeof 返回值是字符串类型；\n\nvar b = null;\nconsole.log(typeof b);  //输出 object  \n//可知不能使用typeof 判断 null 基本数据类型\nconsole.log(b === null);  //输出 true \n//可知可以使用 === 来判断null\n\n var b1 = &#123;\n    b2: [1, 'abc', console.log],\n    b3: function () &#123;\n      console.log('b3')\n      return function () &#123;\n        return 'xfzhang'\n      &#125;\n    &#125;\n  &#125;\n\n  console.log(b1 instanceof Object, b1 instanceof Array) // true  false\n\n  console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true\n\n  console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true\n\n  console.log(typeof b1.b2, '-------') // 'object'\n\n  console.log(typeof b1.b3==='function') // true\n\n  console.log(typeof b1.b2[2]==='function')  //true\n\n\n&lt;!--\n1. undefined与null的区别?\n  * undefined代表定义未赋值\n  * nulll定义并赋值了, 只是值为null\n2. 什么时候给变量赋值为null呢?\n  * 初始赋值, 表明将要赋值为对象\n  * 结束前, 让对象成为垃圾对象(被垃圾回收器回收)\n3. 严格区别变量类型与数据类型?\n  * 数据的类型\n    * 基本类型\n    * 对象类型\n  * 变量的类型(变量内存值的类型)\n    * 基本类型: 保存就是基本类型的数据\n    * 引用类型: 保存的是地址值\n-->\n     // 1. undefined与null的区别?\n  var a  //这里只是声明了变量 a 此时内存中 变量 a 不存放数据\n  console.log(a)  // undefined\n  a = null  //这里把声明为 null 几基本数据类型 且将其值赋值为 null\n  console.log(a) // null\n\n  //起始\n  var b = null  // 初始赋值为null, 表明将要赋值为对象\n  //确定对象就赋值\n  b = ['atguigu', 12]\n  //最后\n  b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收)\n数据 - 变量 - 内存&lt;!--\n1. 什么是数据?\n  * 存储在内存中代表特定信息的'东东', 本质上是0101...\n  * 数据的特点: 可传递, 可运算\n  * 一切皆数据\n  * 内存中所有操作的目标: 数据\n    * 算术运算\n    * 逻辑运算\n    * 赋值\n    * 运行函数\n2. 什么是内存?\n  * 内存条通电后产生的可储存数据的空间(临时的)\n  * 内存产生和死亡: 内存条(电路版)==>通电==>产生内存空间==>存储数据==>处理数据==>断电==>内存空间和数据都消失\n  * 一块小内存的2个数据\n     * 内部存储的数据\n     * 地址值\n  * 内存分类\n    * 栈: 全局变量/局部变量\n    * 堆: 对象\n3. 什么是变量?\n  * 可变化的量, 由变量名和变量值组成\n  * 每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据\n4. 内存,数据, 变量三者之间的关系\n  * 内存用来存储数据的空间\n  * 变量是内存的标识\n-->\n\n&lt;!--\n  问题: var a = xxx, a内存中到底保存的是什么?\n    * xxx是基本数据, 保存的就是这个数据\n    * xxx是对象, 保存的是对象的地址值\n    * xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值)\n-->\n&lt;!--\n关于引用变量赋值问题\n  * 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据\n  * 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象\n-->\n&lt;!--\n问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递\n  * 理解1: 都是值(基本/地址值)传递\n  * 理解2: 可能是值传递, 也可能是引用传递(地址值)\n-->\nvar a = 1;\nfunction fun(a)&#123;\n    a++;\n    console.log(a);\n&#125;\nfun(a);  //输出 2\nconsole.log(a);  //输出1\n//可知这里在调用fun函数只是传递了全局变量a的值，fun函数内部又声明了一个局部变量a，将全局变量\n//a的值赋给局部变量 a，此时在fun函数内部进行的a++操作也是操作的局部变量，所以在函数执行输出2，\n//但是全局变量的a还是值为1\n/*\n在函数中若操作变量不在当前局部变量中时，函数将会自动前往全局变量中寻找该变量，此时在函数内部操作的是全局变量；\n*/\n\nvar obj = &#123;\n  name:\"LK\",\n  age:12\n&#125;\nfunction changeAge(obj)&#123;\n  obj.age = 20;\n  console.log(obj);  \n&#125;\nchangeAge(obj);  //输出 &#123;name: 'LK', age: 20&#125;\nconsole.log(obj); //输出 &#123;name: 'LK', age: 20&#125;\n/*\n可知在函数传参时传入一个对象时，此时传递的是对象指向堆内存的地址值，所以此时函数内部进行的是引用传递，对此引用地址指向的堆内存中对象进行数据操作时，修改的是全局对象obj的数据值；\n*/\n\n&lt;!--\n问题: JS引擎如何管理内存?\n1. 内存生命周期\n  * 分配小内存空间, 得到它的使用权\n  * 存储数据, 可以反复进行操作\n  * 释放小内存空间\n2. 释放内存\n  * 局部变量: 函数执行完自动释放\n  * 对象: 成为垃圾对象==>垃圾回收器回收\n-->\n对象&lt;!--\n1. 什么是对象?\n  * 多个数据的封装体\n  * 用来保存多个数据的容器\n  * 一个对象代表现实中的一个事物\n2. 为什么要用对象?\n  * 统一管理多个数据\n3. 对象的组成\n  * 属性: 属性名(字符串)和属性值(任意)组成\n  * 方法: 一种特别的属性(属性值是函数)\n4. 如何访问对象内部数据?\n  * .属性名: 编码简单, 有时不能用\n  * ['属性名']: 编码麻烦, 能通用\n-->\n&lt;!--\n问题: 什么时候必须使用['属性名']的方式?\n  1. 属性名包含特殊字符: - 空格\n  2. 属性名不确定\n-->\n函数&lt;!--\n1. 什么是函数?\n  * 实现特定功能的n条语句的封装体\n  * 只有函数是可以执行的, 其它类型的数据不能执行\n2. 为什么要用函数?\n  * 提高代码复用\n  * 便于阅读交流\n3. 如何定义函数?\n  * 函数声明\n  * 表达式\n4. 如何调用(执行)函数?\n  * test(): 直接调用\n  * obj.test(): 通过对象调用\n  * new test(): new调用\n  * test.call/apply(obj): 临时让test成为obj的方法进行调用\n-->\n  function fn1 () &#123; //函数声明\n    console.log('fn1()')\n  &#125;\n  var fn2 = function () &#123; //表达式\n    console.log('fn2()')\n  &#125;\n回调函数&lt;!--\n1. 什么函数才是回调函数?\n  1). 你定义的\n  2). 你没有调\n  3). 但最终它执行了(在某个时刻或某个条件下)\n2. 常见的回调函数?\n  * dom事件回调函数 ==>发生事件的dom元素（点击事件之类）\n  * 定时器回调函数 ===>window\n\n  * ajax请求回调函数(后面讲)\n  * 生命周期回调函数(后面讲)\n-->\nIIFE – 立即执行函数&lt;!--\n1. 理解\n  * 全称: Immediately-Invoked Function Expression -- 立即执行函数表达式\n2. 作用\n  * 隐藏实现\n  * 不会污染外部(全局)命名空间\n  * 用它来编码js模块\n-->\n\n(function ()&#123;\n    console.log(this);\n&#125;)();  //输出 window  -- 立即执行函数需要其实就是一个会立即由window调用的匿名函数，函数体需要使用()包含起来；\nthis&lt;!--\n1. this是什么?\n  * 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window\n  * 所有函数内部都有一个变量this\n  * 它的值是调用函数的当前对象\n2. 如何确定this的值?\n  * test():  --- window\n  * p.test(): --- p\n  * new test(): --- 新创建的对象\n  * p.call(obj): --- obj\n-->\n分号问题\njs一条语句的后面可以不加分号；\n\n是否加分号是编码风格问题, 没有应该不应该，只有你自己喜欢不喜欢；\n\n在下面2种情况下不加分号会有问题；\n\n小括号开头的前一条语句；\n中方括号开头的前一条语句；\n\n\n解决办法: 在行首加分号；\n\n\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"BOM-定时器-JSON","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/25/BOM-定时器-JSON/","content":"BOM(Browser Object Model)BOM -- 浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window；\nBOM由一些列相关的对象构成，并且每个对象都提供了很多方法与属性。\n\nDOM\n● 文档对象模型\n● DOM就是把【文档】当作一个【对象】来看待\n● DOM的顶级对象是document\n● DOM主要学习的是操作页面元素\n● DOM是W3C标准规范\nBOM\n● 浏览器对象模型\n● 把【浏览器】当做一个【对象】来看待\n● BOM的顶级对象是window\n● BOM学习的是浏览器窗口交互的一些对象\n● BOM是浏览器厂商在各自浏览器上定义的，兼容性交差\n\nBOM比DOM更大，它包含DOM；\nwindow对象是浏览器的顶级对象，它具有双重角色。\n1.它是JS访问浏览器窗口的一个接口。\n2.它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。\n在调用的时候可以省略alert()、prompt()等window对话框都属于window对象方法。\n注意：window下的特殊属性window.name，由此尽量不要使用var name=’’;\n\n\n/*\n\t\t\t * BOM\n\t\t\t * \t- 浏览器对象模型\n\t\t\t * \t- BOM可以使我们通过JS来操作浏览器\n\t\t\t * \t- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作\n\t\t\t * \t- BOM对象\n\t\t\t * \t\tWindow\n\t\t\t * \t\t\t- 代表的是整个浏览器的窗口，同时window也是网页中的全局对象\n\t\t\t * \t\tNavigator\n\t\t\t * \t\t\t- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器\n\t\t\t * \t\tLocation\n\t\t\t * \t\t\t- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面\n\t\t\t * \t\tHistory\n\t\t\t * \t\t\t- 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录\n\t\t\t * \t\t\t\t由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页\n\t\t\t * \t\t\t\t而且该操作只在当次访问时有效\n\t\t\t * \t\tScreen\n\t\t\t * \t\t\t- 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息\n\t\t\t * \n\t\t\t * \n\t\t\t * \t\t这些BOM对象在浏览器中都是作为window对象的属性保存的，\n\t\t\t * \t\t\t可以通过window对象来使用，也可以直接使用\n\t\t\t * \n\t\t\t * \t\t\n\t\t\t */\nNavigator\n/*\n\t\t\t * Navigator\n\t\t\t * \t- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器\n\t\t\t * \t- 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了\n\t\t\t * \t- 一般我们只会使用userAgent来判断浏览器的信息，\n\t\t\t * \t\tuserAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，\n\t\t\t * \t\t不同的浏览器会有不同的userAgent\n\t\t\t * \n\t\t\t * 火狐的userAgent\n\t\t\t * \tMozilla/5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0\n\t\t\t * \n\t\t\t * Chrome的userAgent\n\t\t\t *  Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36\n\t\t\t * \n\t\t\t * IE8\n\t\t\t * \tMozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\n\t\t\t * \n\t\t\t * IE9\n\t\t\t * \tMozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\n\t\t\t * \n\t\t\t * IE10\n\t\t\t * \tMozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\n\t\t\t * \n\t\t\t * IE11\n\t\t\t * \tMozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko\n\t\t\t * \t- 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了\n\t\t\t */\nconsole.log(navigator);\nconsole.log(window.navigator);  //两个语句输出内容一样，可以通过navigator查看浏览器的信息；\n\nconsole.log(navigator.userAgent); //userAgent -- 用户代理 --就是浏览器的意思，这里可以看到当前浏览器的详细信息；\n\n\t\t\t/*\n\t\t\t * 如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息\n\t\t\t * 比如：ActiveXObject -- 这个属性只有IE才有\n\t\t\t */\nif(\"ActiveXObject\" in window)&#123;\n    //进入这里说明window对象身上有ActiveXObject这个属性\n&#125;\nHistory\t\t\t/*\n\t\t\t * History\n\t\t\t * \t- 对象可以用来操作浏览器向前或向后翻页\n\t\t\t */\n\t\t\t\t\t/*\n\t\t\t\t\t * length\n\t\t\t\t\t * \t- 属性，可以获取到当成访问的链接数量\n\t\t\t\t\t */\nconsole.log(history.length);  //获取当前网页前面一访问的网页数量\nconsole.log(history.back);  //可以用来回退到上一页面，作用和浏览器回退按钮一样\nconsole.log(history.forward);  //可以用来前进到之前访问又回退了的网页，作用和浏览器的前进按钮一样；\n\t\t\t\t\t/*\n\t\t\t\t\t * go()\n\t\t\t\t\t * \t- 可以用来跳转到指定的页面\n\t\t\t\t\t * \t- 它需要一个整数作为参数\n\t\t\t\t\t * \t\t1:表示向前跳转一个页面 相当于forward()\n\t\t\t\t\t * \t\t2:表示向前跳转两个页面\n\t\t\t\t\t * \t\t-1:表示向后跳转一个页面\n\t\t\t\t\t * \t\t-2:表示向后跳转两个页面\n\t\t\t\t\t */\nconsole.log(history.go(1));\nLocation\t\t\t/*\n\t\t\t * Location\n\t\t\t * \t- 该对象中封装了浏览器的地址栏的信息\n\t\t\t */\nconsole.log(location.href);  //可以获取到当前页面的完整路径\n\n\t\t\t\t\t/*\n\t\t\t\t\t * 如果直接将location属性修改为一个完整的路径，或相对路径\n\t\t\t\t\t * \t则我们页面会自动跳转到该路径，并且会生成相应的历史记录\n\t\t\t\t\t */\nlocation = \"http://www.baidu.com\";\nlocation = \"01.BOM.html\";  //将网页的location修改为指定的地址，网页将自动跳转到该指定网页；\n\n\t\t\t\t\t/*\n\t\t\t\t\t * assign()\n\t\t\t\t\t * \t- 用来跳转到其他的页面，作用和直接修改location一样\n\t\t\t\t\t */\nlocation.assign(\"http://www.baidu.com\"); //作用和直接修改location一样；\n\n\t\t\t\t\t/*\n\t\t\t\t\t * reload()\n\t\t\t\t\t * \t- 用于重新加载当前页面，作用和刷新按钮一样\n\t\t\t\t\t * \t- 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面\n\t\t\t\t\t */\nlocation.reload(true);\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t * replace()\n\t\t\t\t\t * \t- 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面\n\t\t\t\t\t * \t\t不会生成历史记录，不能使用回退按钮回退\n\t\t\t\t\t */\nlocation.replace(\"01.BOM.html\");\n\n\n定时器\t\t\t\t/*\n\t\t\t\t * setInterval()\n\t\t\t\t * \t- 定时调用\n\t\t\t\t * \t- 可以将一个函数，每隔一段时间执行一次\n\t\t\t\t * \t- 参数：\n\t\t\t\t * \t\t1.回调函数，该函数会每隔一段时间被调用一次\n\t\t\t\t * \t\t2.每次调用间隔的时间，单位是毫秒\n\t\t\t\t * \n\t\t\t\t * \t- 返回值：\n\t\t\t\t * \t\t返回一个Number类型的数据\n\t\t\t\t * \t\t这个数字用来作为定时器的唯一标识\n\t\t\t\t */\n\t\t\t\t//clearInterval()可以用来关闭一个定时器\n\t\t\t\t//方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器\n\n\t\t\t/*\n\t\t\t * 延时调用，\n\t\t\t * \t延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次\n\t\t\t * \n\t\t\t * 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次\n\t\t\t * \n\t\t\t * 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择\n\t\t\t */\n\t\t\t//使用clearTimeout()来关闭一个延时调用\n\nvar count = 0;\n\t\t//创建一个定时器\n\t\tvar timeId = setInterval(function()&#123;\n\t\t\tvar test = console.time();\n\t\tvar count = 0;\n\t\t//创建一个定时器\n\t\tvar timeId = setInterval(function()&#123;\n\t\t\tconsole.log(count++);\n\n\t\t\tif(count > 10)&#123;\n\t\t\tclearInterval(timeId);\n\t\t\tconsole.log(\"停止定时器！\");\n\t\t&#125;\n\t\t&#125;,10);\n\n\t\tsetTimeout(function()&#123;\n\t\t\tconsole.log(\"执行暂停5秒\");\n\t\t&#125;,5000)\n\n\t\tconsole.log(\"不停止计时器，不执行我！\");\n\t\tconsole.timeEnd(test);console.log(count++);  \n            \n            if(count > 10)&#123;\n\t\t\tclearInterval(timeId);\n\t\t\tconsole.log(\"停止定时器！\");\n             //当count = 10 的时候停止定时器；切记停止计时器的调用判断要写在定时器的内部回调函数中；\n\t\t&#125;,1000);  //每过一秒在控制台输出count；\n\n结果分析：\n\t首先JS代码是从上到下执行的，在遇到创建定时器语句的时候，就异步启动定时器（相当于新开一个线程），但是此时定时器设定的是10ms才执行一次，所以目前的状态是开始计时而不会输出count而是继续执行下面的语句，遇到延时器语句，也异步开启一个延时器，但是此时因为要延时5秒才会执行延时器里的回调函数，所以此时程序继续往下执行，输出了最后一个控制台输出语句；而此时的时间才过了0.38ms，此时还不到定时器的第一次回调执行，而当定时器的10次回调都执行了延时器也还没有到时间。\n    所以结果就是js代码最后面的语句先执行；\n    所以我们要暂停定时器需要在定时器内部判断如果在外部判断的话，可能会造成提前判断而导致定时器无法关闭的现象；\n类的操作/*\n* 通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面\n* \t这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便\n*/\n我们希望一行代码可以同时修改对个样式，所以我们可以提前在style标签里设置需要的样式，使用js直接给元素动态添加类样式；\n\n\t\t\t//定义一个函数，用来向一个元素中添加指定的class属性值\n\t\t\t/*\n\t\t\t * 参数:\n\t\t\t * \tobj 要添加class属性的元素\n\t\t\t *  cn 要添加的class值\n\t\t\t * \t\n\t\t\t */\n\t\t\tfunction addClass(obj , cn)&#123;\n\t\t\t\t\n\t\t\t\t//检查obj中是否含有cn\n\t\t\t\tif(!hasClass(obj , cn))&#123;\n\t\t\t\t\tobj.className += \" \"+cn;\n\t\t\t\t&#125;\n\t\t\t\t\n\t\t\t&#125;\n\t\t\t\n\t\t\t/*\n\t\t\t * 判断一个元素中是否含有指定的class属性值\n\t\t\t * \t如果有该class，则返回true，没有则返回false\n\t\t\t * \t\n\t\t\t */\n\t\t\tfunction hasClass(obj , cn)&#123;\n\t\t\t\t\n\t\t\t\t//判断obj中有没有cn class\n\t\t\t\t//创建一个正则表达式\n\t\t\t\t//var reg = /\\bb2\\b/;\n\t\t\t\tvar reg = new RegExp(\"\\\\b\"+cn+\"\\\\b\");\n\t\t\t\t\n\t\t\t\treturn reg.test(obj.className);\n\t\t\t\t\n\t\t\t&#125;\n\t\t\t\n\t\t\t/*\n\t\t\t * 删除一个元素中的指定的class属性\n\t\t\t */\n\t\t\tfunction removeClass(obj , cn)&#123;\n\t\t\t\t//创建一个正则表达式\n\t\t\t\tvar reg = new RegExp(\"\\\\b\"+cn+\"\\\\b\");\n\t\t\t\t\n\t\t\t\t//删除class\n\t\t\t\tobj.className = obj.className.replace(reg , \"\");\n\t\t\t\t\n\t\t\t&#125;\n\t\t\t\n\t\t\t/*\n\t\t\t * toggleClass可以用来切换一个类\n\t\t\t * \t如果元素中具有该类，则删除\n\t\t\t * \t如果元素中没有该类，则添加\n\t\t\t */\n\t\t\tfunction toggleClass(obj , cn)&#123;\n\t\t\t\t\n\t\t\t\t//判断obj中是否含有cn\n\t\t\t\tif(hasClass(obj , cn))&#123;\n\t\t\t\t\t//有，则删除\n\t\t\t\t\tremoveClass(obj , cn);\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\t//没有，则添加\n\t\t\t\t\taddClass(obj , cn);\n\t\t\t\t&#125;\n\t\t\t\t\n\t\t\t&#125;\nJSON\t\t\t/*\n\t\t\t * JSON\n\t\t\t * \t- JS中的对象只有JS自己认识，其他的语言都不认识\n\t\t\t * \t- JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，\n\t\t\t * \t\t并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互\n\t\t\t * \t- JSON\n\t\t\t * \t\t- JavaScript Object Notation JS对象表示法\n\t\t\t * \t\t- JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号\n\t\t\t * \t\t\t其他的和JS语法一致\n\t\t\t * \t\tJSON分类：\n\t\t\t * \t\t\t1.对象 &#123;&#125;\n\t\t\t * \t\t\t2.数组 []\n\t\t\t * \n\t\t\t * \t\tJSON中允许的值：\n\t\t\t * \t\t\t1.字符串\n\t\t\t * \t\t\t2.数值\n\t\t\t * \t\t\t3.布尔值\n\t\t\t * \t\t\t4.null\n\t\t\t * \t\t\t5.对象\n\t\t\t * \t\t\t6.数组\n\t\t\t */\n\n//定义一个JSON字符串，对象或者数字里的key必须要使用双引号包裹：\nvar personJson = '&#123;\"name\":\"LK\",\"gender\":\"man\",\"age\":20,\"adress\":\"China\"&#125;';\n\n\t\t\t/*\n\t\t\t * 将JSON字符串转换为JS中的对象\n\t\t\t * \t在JS中，为我们提供了一个工具类，就叫JSON\n\t\t\t * \t这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON\n\t\t\t */\n\t\t\t/*\n\t\t\t * json --> js对象\n\t\t\t * \t JSON.parse()\n\t\t\t * \t\t- 可以将以JSON字符串转换为js对象\n\t\t\t * \t\t- 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回\n\t\t\t */\n\n//将定义好的personJSON字符串转换成JS对象\nvar jsonObj = JSON.parse(personJson);\nconsole.log(typeof jsonObj);  //输出 object\nconsole.log(jsonObj);  // 输出 &#123;name: 'LK', gender: 'man', age: 20, adress: 'China'&#125;\n\n\t\t\t/*\n\t\t\t * JS对象 ---> JSON\n\t\t\t * \tJSON.stringify()\n\t\t\t * \t\t- 可以将一个JS对象转换为JSON字符串\n\t\t\t * \t\t- 需要一个js对象作为参数，会返回一个JSON字符串\n\t\t\t */\nvar jsonStr = JSON.stringify(jsonObj);\nconsole.log(typeof jsonStr);  //输出 string\nconsole.log(jsonStr);  //输出 &#123;\"name\":\"LK\",\"gender\":\"man\",\"age\":20,\"adress\":\"China\"&#125;\n\n注意！！！！：JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错\n\t\t\tIE7如果需要使用JSON对象，需要引入第三方的js库 -- json2.js\nJSON – eval()\t\t\t/*\n\t\t\t * eval()\n\t\t\t * \t- 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回\n\t\t\t * \t- 如果使用eval()执行的字符串中含有&#123;&#125;,它会将&#123;&#125;当成是代码块\n\t\t\t * \t\t如果不希望将其当成代码块解析，则需要在字符串前后各加一个()\n\t\t\t * \n\t\t\t * \t- eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，\n\t\t\t * \t\t但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患\n\t\t\t */\nvar str = \"console.log('我是str里的打印语句！')\";\neval(str);  //  输出 我是str里的打印语句！\n\n我们可以利用这个函数来将string字符串转换成对象\nvar personJson = '&#123;\"name\":\"LK\",\"gender\":\"man\",\"age\":20,\"adress\":\"China\"&#125;';\nvar personObj = eval(\"(\"+personJson+\")\");\nconsole.log(typeof personObj);  //输出 object\nconsole.log(personObj);   //输出 &#123;name: 'LK', gender: 'man', age: 20, adress: 'China'&#125;","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"事件对象-鼠标事件","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/24/事件对象/","content":"事件对象事件对象 -- 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数（浏览器自动传入，我们可以使用参数接受）\n\t在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标  键盘哪个按键被按下  鼠标滚轮滚动的方向；\n    \n    兼容性问题：\n    \t在常见的Chrome浏览器，火狐浏览器等，事件的响应函数执行时，事件对象会被自动传入，但是在IE8及以下的浏览器中，事件的响应函数被执行是并不会传入事件对象，而是将当前的事件对象作为window的属性保存；\n        解决办法 ： event = event || window.event;  //在响应函数被执行的获取event，若此时获取不到event则说明此时的浏览器为IE8及以下，使用window.event 获取事件对象；\n\t\n\t\t/*\n\t\t * onmousemove\n\t\t * \t- 该事件将会在鼠标在元素中移动时被触发\n\t\t */\n\t\t\t/*\n\t\t\t * clientX可以获取鼠标指针的水平坐标\n\t\t\t * cilentY可以获取鼠标指针的垂直坐标\n\t\t\t \t这两个属性是事件对象上的属性\n\t\t\t */\nareaDiv.onmousemove = function(event)&#123;\n    event = event || window.event;\n    var x = event.clientX;\n    var y = event.clientY;\n&#125;\n\n//获取box元素\n    var box = document.getElementById(\"box\");\n\n    //给整个文档元素节点添加鼠标移入事件\n    document.onmousemove = function(event)&#123;\n        //处理兼容性问题\n        event = event || window.event;\n\n        //获取当前鼠标的位置\n        // var x = event.clientX;\n        // var y = event.clientY;\n\n        //改用pageX和pageY获取位置\n        // var x = event.pageX;\n        // var y = event.pageY;\n\n        //兼容的解决方法\n        var x = event.clientX + document.scrollingElement.scrollLeft;\n        var y = event.clientY + document.scrollingElement.scrollTop;\n\n        //修改box元素的位置\n        box.style.left = x + \"px\";\n        box.style.top = y + \"px\";\n\n        /*当页面出现滚动条的时候，去滑动滚动条，将会出现鼠标与box分离但是一起继续移动的现象；\n\n        //原因分析：enent.clientX/clientY 的位置永远都是根据网页中的左上角计算的，也就是显示器中的左上角，不\t\t\t会随着浏览器\n        //滚动条的滑动而改变，而box.style.left/top 此时是根据其父元素的body的文档流位置所计算的，相当于\t\t\tleft:0; top:0;\n        //所以当我们去滑动滚动条的时候，box距离定位原点的距离改变了，但是鼠标event的定位原点没有改变，\n        //实际效果是，本来在一个没有滚动条的网页中鼠标和元素的计算原点是一致的，但是滑动滚动条后，因为box的定\t\t\t位距离是要等于此时\n        的鼠标clientX/Y的，网页下移，鼠标不动--》clientX/Y不变，所以box的left和top也不变，所以此时box会出现\t\t在鼠标的上面，因为鼠标现在所在的位置\n        是大于box距离top:0 的位置的，所以其实是box上移了。而box和鼠标间的距离差就是滚动条滚动的距离；\n        */\n\n        //解决方法1：鼠标采用pageX和pageY获取位置，此时鼠标的计算原点将变为与box计算原点一致，即body所在文档\t\t流位置；\n\n        //pageX和pageY可以获取鼠标相对于当前页面的坐标\n\t\t//但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用\n        //解决方法2：获取此时document的scrollTop位置，将box与鼠标的距离差（scrollTop添加上）\n        //获取滚动条滚动的距离\n\t\t\t\t\t/*\n\t\t\t\t\t * chrome认为浏览器的滚动条是body的，可以通过body.scrollTop来获取\n\t\t\t\t\t * 火狐等浏览器认为浏览器的滚动条是html的，\n\t\t\t\t\t */\n\t\t\t\t\tvar st = document.body.scrollTop || document.documentElement.scrollTop;\n\t\t\t\t\tvar sl = document.body.scrollLeft || document.documentElement.scrollLeft;\n\n    &#125;\n事件冒泡/*\n * 事件的冒泡（Bubble）\n * \t- 所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也\t\t\t\t\t会被触发\n * \t- 在开发中大部分情况冒泡都是有用的,如果不希望发生事件冒泡可以通过事件对象来取消冒泡\n * \n */\n//取消冒泡\n\t//可以将事件对象的cancelBubble设置为true，即可取消冒泡\n\tevent.cancelBubble = true;\n事件委派\t\t\t\t/* 事件的委派\n\t\t\t\t * \t- 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖\t\t\t\t\t先元素，从而通过祖先元素的响应函数来处理事件。\n\t\t\t\t *  - 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能\n\t\t\t\t */\n\t\t\t\t\t/*\n\t\t\t\t\t * target\n\t\t\t\t\t * \t- event中的target表示的触发事件的对象\n\t\t\t\t\t */\nconsole.log(event.target.name);\n多重事件绑定\t\t\t\t/*\n\t\t\t\t * 使用 对象.事件 = 函数 的形式绑定响应函数，\n\t\t\t\t * \t它只能同时为一个元素的一个事件绑定一个响应函数，\n\t\t\t\t * \t不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * addEventListener()\n\t\t\t\t * \t- 通过这个方法也可以为元素绑定响应函数\n\t\t\t\t *  - 参数：\n\t\t\t\t * \t\t1.事件的字符串，不要on\n\t\t\t\t * \t\t2.回调函数，当事件触发时该函数会被调用\n\t\t\t\t * \t\t3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false\n\t\t\t\t * \n\t\t\t\t * 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，\n\t\t\t\t * \t这样当事件被触发时，响应函数将会按照函数的绑定顺序执行\n\t\t\t\t * addEventListener()中的this，是绑定事件的对象\n\t\t\t\t * \n\t\t\t\t * 这个方法不支持IE8及以下的浏览器\n\t\t\t\t */\nbtn01.addEventListener(\"click\",function()&#123;\n\t\t\t\t\talert(1);\n\t\t\t\t&#125;,false);\n\n\t\t\t\t/*\n\t\t\t\t * attachEvent()\n\t\t\t\t * \t- 在IE8中可以使用attachEvent()来绑定事件\n\t\t\t\t *  - 参数：\n\t\t\t\t * \t\t1.事件的字符串，要on\n\t\t\t\t * \t\t2.回调函数\n\t\t\t\t * \n\t\t\t\t *  - 这个方法也可以同时为一个事件绑定多个处理函数，\n\t\t\t\t * \t\t不同的是它是后绑定先执行，执行顺序和addEventListener()相反\n\t\t\t\t * attachEvent()中的this，是window\n\t\t\t\t */\nbtn01.attachEvent(\"onclick\",function()&#123;\n\t\t\t\t\talert(1);\n\t\t\t\t&#125;);\n\n\t//兼容性解决方法\n\t//定义一个函数，用来为指定元素绑定响应函数\n\t\t\t/*\n\t\t\t * addEventListener()中的this，是绑定事件的对象\n\t\t\t * attachEvent()中的this，是window\n\t\t\t *  需要统一两个方法this\n\t\t\t */\n\t\t\t/*\n\t\t\t * 参数：\n\t\t\t * \tobj 要绑定事件的对象\n\t\t\t * \teventStr 事件的字符串(不要on)\n\t\t\t *  callback 回调函数\n\t\t\t */\n\n\t//自定义一个可兼容的bind函数用于给事件绑定多重响应函数\n    //参数1：需要绑定的对象，\n    //参数2：固定参数，字符串 \"click\"\n    //参数3：事件响应函数的回调函数；\n    function bind(obj,enevtStr,callback)&#123;\n        //判断当前的浏览器是否兼容addEventListener()方法\n        if(odj.addEventListener)&#123;\n            //进入这里说明当前可使用addEventListener()\n            //addEventListener()方法中需要传入三个参数，\n            /*\n            参数1：事件的响应类型\n            参数2：事件响应的回调函数\n            参数3：是否开启事件的捕捉，默认不开启false\n            */\n            obj.addEventListener(eventStr,callback,false);\n        &#125;else&#123;\n            //进入这里说明当前浏览器不支持addEventListener()方法，\n            //应该使用attachEvent()方法 -- IE8及以下\n            /*\n            参数1：attachEvent的点击事件传入的事件名以on开头；\n            参数2：需要绑定事件的对象；\n            参数3：默认传入一个匿名函数，并在里面使用call调用当前的callback回调函数\n            */\n            obj.attachEvent(\"on\"+enevtStr,obj,function()&#123;\n                //在attachEvent方法中，传入的回调函数里的this是window而不是当前的attachEvent方法执行对象\n                //所以只能在参数中传入一个匿名函数，并在此使用call调用传入的callback；\n                callback.call(obj);\n            &#125;);\n        &#125;\n    &#125;\n事件的传播/*\n * 事件的传播\n * \t- 关于事件的传播网景公司和微软公司有不同的理解\n * \t- 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，\n * \t\t然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。\n *  - 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层\t\t\t\t\t的祖先元素的事件，\n * \t\t然后在向内传播给后代元素\n * \t- W3C综合了两个公司的方案，将事件传播分成了三个阶段\n * \t\t1.捕获阶段\n * \t\t\t- 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触\t\t\t\t\t发事件\n * \t\t2.目标阶段\n * \t\t\t- 事件捕获到目标元素，捕获结束开始在目标元素上触发事件\n * \t\t3.冒泡阶段\n * \t\t\t- 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件\n * \n * \t\t- 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true\n * \t\t\t一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false\n * \n * \t- IE8及以下的浏览器中没有捕获阶段\n */\n\n拖拽练习//获取box1元素节点\n    var box1 = document.getElementById(\"box1\");\n\n    //给box添加鼠标事件\n    box1.onmousedown = function(event)&#123;\n        //进入这里说明鼠标进入box1且进行了点击\n\n        event = event || window.event;\n\n        //获取当前box1的位置\n        var boxLeft = box1.offsetLeft;\n        var boxTop = box1.offsetTop;\n\n        //获取当前鼠标点击但还未移动时的位置\n        var mouseLeft = event.clientX;\n        var mouseHeight = event.clientY;\n\n        //获取当前box1与鼠标的距离差\n        var left = mouseLeft - boxLeft;\n        var top = mouseHeight - boxTop;\n\n        //在鼠标点击时间内定义document拖拽事件\n        document.onmousemove = function(event)&#123;\n\n            event = event || window.event;\n            \n            var x = event.clientX - left;\n            var y = event.clientY - top;\n\n            box1.style.left = x + \"px\";\n            box1.style.top = y + \"px\";\n\n            /* \n            此时出现了box1位置闪现的问题\n            原因分析：\n                在鼠标进入box1的内部点击时，触发box1的onmousedown事件，此时鼠标还没有移动时\n                没有异常现象出现，一旦鼠标开始移动，此时触发document的onmousemove响应函数，\n                此时将立即获取到鼠标的位置，并且将修改box1的位置\n                    box1的位置最后会变成鼠标当前所在文档流位置\n                因为box1的位置和此时鼠标所在位置不一定相同造成box1闪现问题\n\n            解决方法：\n                在鼠标在box1内部点击时还没开始出发移动的响应函数前，\n                先获取当前box1的文档流位置和此时鼠标的位置\n                通过event.clientX - box1.offsetLeft 获取当前box1与鼠标的距离差\n                之后在鼠标开始移动的时候，将box1要闪现的距离差添加上以此弥补，从而解决闪现问题\n            */\n        &#125;\n\n    &#125;\n\n    box1.onmouseup = function()&#123;\n        document.onmousemove = null;\n    &#125;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * setCapture()\n\t\t\t\t\t * \t- 只有IE支持，但是在火狐中调用时不会报错，\n\t\t\t\t\t * \t\t而如果使用chrome调用，会报错\n\t\t\t\t\t */\n//当调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上\n\t\t\t\tbtn01.setCapture();\n滚轮事件\t\t\t\t/*\n\t\t\t\t * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，\n\t\t\t\t * \t但是火狐不支持该属性\n\t\t\t\t event.wheelDelta 可以获取鼠标滚轮滚动的方向\n\t\t\t\t wheelDelta这个值我们不看大小，只看正负\n\t\t\t\t 向上滚 -- 值大于0 ；  向下滚 -- 值小于0；\n\t\t\t\t * \n\t\t\t\t * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件\n\t\t\t\t * \t注意该事件需要通过addEventListener()函数来绑定\n\t\t\t\t wheelDelta属性在火狐浏览器中也不支持，需要使用event.detail来获取滚动的方向\n\t\t\t\t 向上滚 -- 值小于0； 向下滚 -- 值大于0；\n\t\t\t\t */\nbox1.onmousewheel = function(event)&#123;\n    //event兼容\n    event = event || window.event;\n    \n    //判断此时滚轮方向\n    if(event.wheelDetal > 0 || event.detail &lt; 0)&#123;\n        //进入这里说明此时滚轮向上滚\n        //clientHeight为当前盒子的内容区+内边距区大小\n        box1.style.height = box1.clientHeight - 10 + \"px\"; \n    &#125;else&#123;\n        box1.style.height = box1.clientHeight  + 10 + \"px\";\n    &#125;\n    \t\t\t\t/*\n\t\t\t\t\t * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false\n\t\t\t\t\t * 需要使用event来取消默认行为event.preventDefault();\n\t\t\t\t\t * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错\n\t\t\t\t\t */\n\t\t\t\t\tevent.preventDefault &amp;&amp; event.preventDefault();\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，\n\t\t\t\t\t * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n&#125;\n\t\t\t\t//为火狐绑定滚轮事件\n\tbind(box1,\"DOMMouseScroll\",box1.onmousewheel);\n\n\tfunction bind(obj , eventStr , callback)&#123;\n\t\tif(obj.addEventListener)&#123;\n\t\t\t//大部分浏览器兼容的方式\n\t\t\tobj.addEventListener(eventStr , callback , false);\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\t/*\n\t\t\t\t\t * this是谁由调用方式决定\n\t\t\t\t\t * callback.call(obj)\n\t\t\t\t\t */\n\t\t\t\t\t//IE8及以下\n\t\t\t\t\tobj.attachEvent(\"on\"+eventStr , function()&#123;\n\t\t\t\t\t\t//在匿名函数中调用回调函数\n\t\t\t\t\t\tcallback.call(obj);\n\t\t\t\t\t&#125;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n //给按钮绑定点击响应事件1 -- 点击打印box1的大小\n    bind(btn,\"click\",function()&#123;\n        console.log(\"box1的clientX：\",box1.clientWidth);\n    &#125;);\n\n    //给按钮绑定点击响应事件2 -- 点击打印box1的背景颜色\n    bind(btn,\"click\",function()&#123;\n        console.log(\"box1的背景颜色：\",getComputedStyle(box1,null).backgroundColor);\n    &#125;);\n键盘事件\t\t\t\t/*\n\t\t\t\t * 键盘事件：\n\t\t\t\t * \tonkeydown\n\t\t\t\t * \t\t- 按键被按下\n\t\t\t\t * \t\t- 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发\n\t\t\t\t * \t\t- 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快\n\t\t\t\t * \t\t\t这种设计是为了防止误操作的发生。\n\t\t\t\t * \tonkeyup\n\t\t\t\t * \t\t- 按键被松开\n\t\t\t\t * \n\t\t\t\t *  键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document\n\t\t\t\t */\n\t\t\t\t\t/*\n\t\t\t\t\t * 可以通过keyCode来获取按键的编码\n\t\t\t\t\t * \t通过它可以判断哪个按键被按下\n\t\t\t\t\t * 除了keyCode，事件对象中还提供了几个属性\n\t\t\t\t\t * \taltKey\n\t\t\t\t\t * \tctrlKey\n\t\t\t\t\t * \tshiftKey\n\t\t\t\t\t * \t\t- 这个三个用来判断alt ctrl 和 shift是否被按下\n\t\t\t\t\t * \t\t\t如果按下则返回true，否则返回false\n\t\t\t\t\t */\n\n//获取box对象\n    var box = document.getElementById(\"box\");\n\n    //定义一个box每次唯一的距离\n    var distant = 10;\n\n    //给document添加键盘监听事件\n    document.onkeydown = function(event)&#123;\n        //解决event兼容\n        event = event || window.event;\n\n        // console.log(\"当前输入的键盘编码:\",event.keyCode);\n        /*\n        获取到上方向键编码：38\n        向下方向键编码：40\n        向左方向键编码：37\n        向右方向键编码：39\n        */\n\n       //判断此时clrt键是否被按下\n       if(event.ctrlKey)&#123;\n        distant = 20;\n        console.log(\"crlt键被按下，移动加速\");\n       &#125;\n\n        switch(event.keyCode)&#123;\n            case 38:\n                box.style.top = box.offsetTop - distant + \"px\";\n                console.log(\"向上移动\"+distant+\"px\");\n                break;\n            case 40:\n                box.style.top = box.offsetTop + distant + \"px\";\n                console.log(\"向下移动\"+distant+\"px\");\n                break;\n            case 37:\n                box.style.left = box.offsetLeft - distant + \"px\";\n                console.log(\"向左移动\"+distant+\"px\");\n                break;\n            case 39:\n                box.style.left = box.offsetLeft + distant + \"px\";\n                console.log(\"向右移动\"+distant+\"px\");\n                break;\n        &#125;\n\n    &#125;","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"DOM-查询与修改","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/23/DOM-查询与修改/","content":"HTML DOM（文档对象模型）当网页解析加载时，浏览器会创建当前页面的文档对象模型DOM（Document Object Model）；\n​    文档 – 表示的就是整个HTML网页文档；\n​    对象 – 表示将网页中的每一个部分都转换成一个对象；\n​    模型 – 使用模型来表示对象之间的关系，方便获取对象；\n所以DOM可以可以看成是一个网页模型，通常将其结构化表示为一个对象树（浏览器首先将收到的html代码，通过html解析器解析构建为一颗DOM树。）：\n\n节点类型（Node）节点 – 是构成网页最基本的组成部分，网页中的每一个部分都可以称为是一个节点，文档是由节点构成的集合；\n​    常用节点分为四类：\n​        文档节点 – 整个HTML文档；网页中的所有节点都是它的子节点；document对象是window身上的属性，可以直接使用；\n​        元素节点 – HTML文档中的HTML标签；\n​        属性节点 – 元素的属性；属性节点并非是元素节点的子节点，而是元素节点的一部分；\n​        文本节点 – HTML标签以外的文本内容；（标签元素之间的空白也会被解析成文本节点）；任意非HTML的文本都是文本节点；\n\n节点的属性\n\n\n\n\nnodeName\nnodeType\nnodeValue\n\n\n\n文档节点\n#document\n9\nnull\n\n\n元素节点\n标签名\n1\nnull\n\n\n属性节点\n属性名\n2\n属性值\n\n\n文本节点\n#text\n3\n文本内容\n\n\n事件文档或浏览器窗口发生的一些特定交互瞬间；例如点击元素，鼠标移入等；\n文档的加载浏览器在解析网页时，按照从上到下的顺序解析代码，如果将script代码写在页面代码之前，会导致在页面还没加载DOM对象执行JS代码，此时将无法获取DOM对象；\nonload()事件会在整个页面加载完成后才执行，为window绑定一个onload事件，以确保在页面记载完成后才开始执行js代码，开始获取DOM对象；\n\n\twindow.onload()&#123;\n        &#x2F;&#x2F;这里书写js代码，这样即使js代码写在网页结构之前也可以正常获取dom对象；\n    &#125;\ndom查询//定义按钮单击事件绑定函数\n\t\t\tfunction btnClick(btnName,fun)&#123;\n\t\t\t\t//获取按钮对象\n\t\t\t\tvar btn = document.getElementById(btnName);\n\t\t\t\t//给按钮绑定单击事件\n\t\t\t\tbtn.onclick = fun;\n\t\t\t&#125;\n\t\t\t\n\t\t\t//在网页结构加载完成以后再开始执行获取dom对象\n\t\t\twindow.onload = function()&#123;\n\n\t\t\t\t//查找#bj节点\n\t\t\t\tbtnClick(\"btn01\",function()&#123;\n\t\t\t\t\t//使用document.getElementById()获取文档的元素节点。需要以字符串形式传入元素节点的id名称\n\t\t\t\t\tvar bj = document.getElementById(\"bj\");\n\t\t\t\t\tconsole.log(bj);\n\t\t\t\t&#125;);\n\n\t\t\t\t//查找所有li节点\n\t\t\t\tbtnClick(\"btn02\",function()&#123;\n\t\t\t\t\t//document.getElementsByTagName根据元素节点的标签名获取文档的中所有符合的节点对象，\n\t\t\t\t\t//返回的是数组，即使返回结果只有一个节点\n\t\t\t\t\tvar list = document.getElementsByTagName(\"li\");\n\t\t\t\t\tfor(var i = 0; i &lt; list.length; i++)&#123;\n\t\t\t\t\t\tconsole.log(list[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;);\n\n\t\t\t\t//查找name=gender的所有节点\n\t\t\t\tbtnClick(\"btn03\",function()&#123;\n\t\t\t\t\t//document.getElementsByName根据元素的name属性节点获取对象，返回的是数组\n\t\t\t\t\tvar list = document.getElementsByName(\"gender\");\n\t\t\t\t\tfor(var i = 0; i &lt; list.length; i++)&#123;\n\t\t\t\t\t\tconsole.log(list[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;);\n\n\t\t\t\t//查找#city下所有li子节点\n\t\t\t\tbtnClick(\"btn04\",function()&#123;\n\t\t\t\t\tvar city = document.getElementById(\"city\");\n\t\t\t\t\t//元素节点也可以使用getElementsByTagName,getElementById之类同document对象的函数，将会在当前节点的子节点查找\n\t\t\t\t\tvar list = city.getElementsByTagName(\"li\");\n\t\t\t\t\tfor(var i = 0; i &lt; list.length; i++)&#123;\n\t\t\t\t\t\tconsole.log(list[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#city下的所有子节点\n\t\t\t\tbtnClick(\"btn05\",function()&#123;\n\t\t\t\t\tvar city = document.getElementById(\"city\");\n\t\t\t\t\t// 使用childNode属性获取元素的所有元素节点和文本子节点\n\t\t\t\t\t// var list = city.childNodes;\n\t\t\t\t\t//使用children属性就只会获取到元素内的所有子元素节点，不包括文本节点，但是该属性不是所有浏览器都兼容\n\t\t\t\t\tvar list = city.children;\n\t\t\t\t\tfor(var i = 0; i &lt; list.length; i++)&#123;\n\t\t\t\t\t\tconsole.log(list[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#phone的第一个子节点\n\t\t\t\tbtnClick(\"btn06\",function()&#123;\n\t\t\t\t\tvar phone = document.getElementById(\"phone\");\n\t\t\t\t\t// 使用firstChild属性或者元素下的第一个子节点（包括文本节点）\n\t\t\t\t\t// var child = phone.firstChild;\n\t\t\t\t\t//使用firstElementChild属性获取元素下的第一个元素节点\n\t\t\t\t\tvar child = phone.firstElementChild;\n\t\t\t\t\tconsole.log(child);\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#bj的父节点\n\t\t\t\tbtnClick(\"btn07\",function()&#123;\n\t\t\t\t\tvar bj = document.getElementById(\"bj\");\n\t\t\t\t\tvar parent = bj.parentNode;\n\t\t\t\t\t// var parent = bj.parentElement;\n\t\t\t\t\t//parentNode和parentElement都可以获取父节点的所有节点属性\n\t\t\t\t\t//区别在于：在获取根部document节点时，parentElement找的是元素，因此报错null,\n\t\t\t\t\t//而parentNode获取的是节点，返回的是#document\n\t\t\t\t\tconsole.log(parent);\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#android的前一个兄弟节点\n\t\t\t\tbtnClick(\"btn08\",function()&#123;\n\t\t\t\t\tvar android = document.getElementById(\"android\");\n\t\t\t\t\t//使用previousSibling属性或获取当前元素的前一个节点（文本节点和元素节点）\n\t\t\t\t\t// var pre = android.previousSibling;\n\t\t\t\t\t//previousElementSibling属性获取当前元素的前一个元素节点\n\t\t\t\t\tvar pre = android.previousElementSibling;\n\t\t\t\t\t//使用nextSibling属性或获取当前元素的下一个节点（文本节点和元素节点）\n\t\t\t\t\t// var next = android.nextSibling;\n\t\t\t\t\t//nextElementSibling属性获取当前元素的下一个元素节点\n\t\t\t\t\tvar next = android.nextElementSibling;\n\t\t\t\t\tconsole.log(pre);\n\t\t\t\t\tconsole.log(next);\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#username的value属性值\n\t\t\t\tbtnClick(\"btn09\",function()&#123;\n\t\t\t\t\tvar username = document.getElementById(\"username\");\n\t\t\t\t\t//使用 元素.属性名 获取元素节点的属性值\n\t\t\t\t\tconsole.log(username.value);\n\t\t\t\t&#125;);\n\n\t\t\t\t//设置#username的value属性值\n\t\t\t\tbtnClick(\"btn10\",function()&#123;\n\t\t\t\t\tvar username = document.getElementById(\"username\");\n\t\t\t\t\t//使用 元素.属性名 = 属性值  修改元素节点的属性值\n\t\t\t\t\tusername.value = \"HelloWorld\";\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#bj的文本值\n\t\t\t\tbtnClick(\"btn11\",function()&#123;\n\t\t\t\t\tvar bj = document.getElementById(\"bj\");\n\t\t\t\t\t//innerText属性会获取当前节点的内部所有文本内容，不包括html标签\n\t\t\t\t\t//innerHTML属性会回去当前节点的内部所有html代码，包括空格换行\n\t\t\t\t\tconsole.log(bj.innerText);\n\t\t\t\t&#125;);\n\t\t\t&#125;\n\n\t\t\t\t/*\n\t\t\t\t * document.querySelector()\n\t\t\t\t * \t- 需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象\n\t\t\t\t * \t- 虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替\n\t\t\t\t * \t- 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个\n\t\t\t\t */\n\t\t\t\tvar div = document.querySelector(\".box1 div\");\n\t\t\t\t\n\t\t\t\tvar box1 = document.querySelector(\".box1\")\n\t\t\t\t\n                /*\n\t\t\t\t * document.querySelectorAll()\n\t\t\t\t * \t- 该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回\n\t\t\t\t * \t- 即使符合条件的元素只有一个，它也会返回数组\n\t\t\t\t */\n\t\t\t\tbox1 = document.querySelectorAll(\".box1\");\n\t\t\t\tbox1 = document.querySelectorAll(\"#box2\");\ndom节点操作/*\n\t\t\t\t\t * document.createElement()\n\t\t\t\t\t * \t可以用于创建一个元素节点对象，\n\t\t\t\t\t * \t它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，\n\t\t\t\t\t * \t并将创建好的对象作为返回值返回\n\t\t\t\t\t */\n\t\t\t\t\tvar li = document.createElement(\"li\");\n\n/*\n\t\t\t\t\t * document.createTextNode()\n\t\t\t\t\t * \t可以用来创建一个文本节点对象\n\t\t\t\t\t *  需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回\n\t\t\t\t\t */\n\t\t\t\t\tvar gzText = document.createTextNode(\"广州\");\n\n/*\n\t\t\t\t\t * appendChild()\n\t\t\t\t\t * \t - 向一个父节点中添加一个新的子节点\n\t\t\t\t\t * \t - 用法：父节点.appendChild(子节点);\n\t\t\t\t\t */\n\t\t\t\t\tli.appendChild(gzText);\n\n\n/*\n\t\t\t\t\t * insertBefore()\n\t\t\t\t\t * \t- 可以在指定的子节点前插入新的子节点\n\t\t\t\t\t *  - 语法：\n\t\t\t\t\t * \t\t父节点.insertBefore(新节点,旧节点);\n\t\t\t\t\t */\n\t\t\t\t\tcity.insertBefore(li , bj);\n\n\n/*\n\t\t\t\t\t * replaceChild()\n\t\t\t\t\t * \t- 可以使用指定的子节点替换已有的子节点\n\t\t\t\t\t * \t- 语法：父节点.replaceChild(新节点,旧节点);\n\t\t\t\t\t */\n\t\t\t\t\tcity.replaceChild(li , bj);\n\n/*\n\t\t\t\t\t * removeChild()\n\t\t\t\t\t * \t- 可以删除一个子节点\n\t\t\t\t\t * \t- 语法：父节点.removeChild(子节点);\n\t\t\t\t\t * \t\t\n\t\t\t\t\t * \t\t子节点.parentNode.removeChild(子节点);\n\t\t\t\t\t */\n\t\t\t\t\t//city.removeChild(bj);\n\t\t\t\t\t\n\t\t\t\t\tbj.parentNode.removeChild(bj);\n\n/*\n\t\t\t\t\t * 使用innerHTML也可以完成DOM的增删改的相关操作\n\t\t\t\t\t * 一般我们会两种方式结合使用\n\t\t\t\t\t */\n\t\t\t\t\t//city.innerHTML += \"&lt;li>广州&lt;/li>\";\n使用DOM操作CSS\t\t\t\t\t&#x2F;*\n\t\t\t\t\t * 通过JS修改元素的样式：\n\t\t\t\t\t * \t语法：元素.style.样式名 &#x3D; 样式值\n\t\t\t\t\t * \n\t\t\t\t\t * 注意：如果CSS的样式名中含有-，\n\t\t\t\t\t * \t\t这种名称在JS中是不合法的比如background-color\n\t\t\t\t\t * \t\t需要将这种样式名修改为驼峰命名法，\n\t\t\t\t\t * \t\t去掉-，然后将-后的字母大写\n\t\t\t\t\t * \n\t\t\t\t\t * 我们通过style属性设置的样式都是内联样式，\n\t\t\t\t\t * \t而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示\n\t\t\t\t\t * \n\t\t\t\t\t * 但是如果在样式中写了!important，则此时样式会有最高的优先级，\n\t\t\t\t\t * \t即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效\n\t\t\t\t\t * \t所以尽量不要为样式添加!important \n\t\t\t\t\t *&#x2F;\n\n&#x2F;&#x2F;给按钮btn1绑定单击事件\n\t\t\t\tbtn1.onclick &#x3D; function()&#123;\n\t\t\t\t\tvar width &#x3D; Math.round(Math.random()*200+100);\n\t\t\t\t\tvar height &#x3D; width;\n\t\t\t\t\t&#x2F;&#x2F;通过js控制的元素样式都是添加到元素的内联样式\n\t\t\t\t\tdemo.style.width &#x3D; width + &quot;px&quot;;\n\t\t\t\t\tdemo.style.height &#x3D; height + &quot;px&quot;;\n\t\t\t\t\tconsole.log(width);\n\t\t\t\t&#125;\n\n\t\t\t\t\t&#x2F;*\n\t\t\t\t\t * 获取元素的当前显示的样式\n\t\t\t\t\t * \t语法：元素.currentStyle.样式名\n\t\t\t\t\t * 它可以用来读取当前元素正在显示的样式\n\t\t\t\t\t * \t如果当前元素没有设置该样式，则获取它的默认值\n\t\t\t\t\t * \n\t\t\t\t\t * currentStyle只有IE浏览器支持，其他的浏览器都不支持\n\t\t\t\t\t *&#x2F;\nconsole.log(box01.currentStyle);\n\n\t\t\t\t\t&#x2F;*\n\t\t\t\t\t * 在其他浏览器中可以使用\n\t\t\t\t\t * \t\tgetComputedStyle()这个方法来获取元素当前的样式\n\t\t\t\t\t * \t\t这个方法是window的方法，可以直接使用\n\t\t\t\t\t * 需要两个参数\n\t\t\t\t\t * \t\t第一个：要获取样式的元素\n\t\t\t\t\t * \t\t第二个：可以传递一个伪元素，一般都传null\n\t\t\t\t\t * \n\t\t\t\t\t * 该方法会返回一个对象，对象中封装了当前元素对应的样式（整个样式的计算属性）\n\t\t\t\t\t * \t可以通过对象.样式名来读取样式\n\t\t\t\t\t * \t如果获取的样式没有设置，则会获取到真实的值，而不是默认值\n\t\t\t\t\t * \t比如：没有设置width，它不会获取到auto，而是一个长度\n\t\t\t\t\t * \n\t\t\t\t\t * 但是该方法不支持IE8及以下的浏览器\n\t\t\t\t\t * \n\t\t\t\t\t * 通过currentStyle和getComputedStyle()读取到的样式都是只读的，\n\t\t\t\t\t * \t不能修改，如果要修改必须通过style属性\n\t\t\t\t\t *&#x2F;\nconsole.log(getComputedStyle(box1,null).width);\n其他样式操作的属性\t\t\t\t\t/*\n\t\t\t\t\t * clientWidth\n\t\t\t\t\t * clientHeight\n\t\t\t\t\t * \t- 这两个属性可以获取元素的可见宽度和高度\n\t\t\t\t\t * \t- 这些属性都是不带px的，返回都是一个数字，可以直接进行计算\n\t\t\t\t\t * \t- 会获取元素宽度和高度，包括内容区和内边距\n\t\t\t\t\t *  - 这些属性都是只读的，不能修改\n\t\t\t\t\t */\nconsole.log(\"demo的宽度\",demo.clientWidth);  //输出具体的数值，不携带单位，返回内边距区和内容区的大小之和；\n\n\t\t\t\t\t/*\n\t\t\t\t\t * offsetWidth\n\t\t\t\t\t * offsetHeight\n\t\t\t\t\t * \t- 获取元素的整个的宽度和高度，包括内容区、内边距和边框\n\t\t\t\t\t */\nconsole.log(\"demo的宽度\",demo.offsetWidth);  //返回元素的可见框大小（边框+内边距+内容区）；\n\n\t\t\t\t\t/*\n\t\t\t\t\t * offsetParent\n\t\t\t\t\t * \t- 可以用来获取当前元素的定位父元素\n\t\t\t\t\t *  - 会获取到离当前元素最近的开启了定位的祖先元素\n\t\t\t\t\t * \t\t如果所有的祖先元素都没有开启定位，则返回body\n\t\t\t\t\t */\nconsole.log(\"demo最近的开启了定位的祖先元素\",demo.offsetParent);  \n\n\t\t\t\t\t/*\n\t\t\t\t\t * offsetLeft\n\t\t\t\t\t * \t- 当前元素相对于其定位父元素的水平偏移量\n\t\t\t\t\t * offsetTop\n\t\t\t\t\t * \t- 当前元素相对于其定位父元素的垂直偏移量\n\t\t\t\t\t \t返回的是当前元素相对于开启了定位的祖先元素的 margin-left/top + left 或 top 之和\n\t\t\t\t\t */\nconsole.log(\"demo相对于开启了定位的祖先元素的水平偏移量\",demo.offsetLeft); \n\n\t\t\t\t\t/*\n\t\t\t\t\t * scrollWidth\n\t\t\t\t\t * scrollHeight\n\t\t\t\t\t * \t- 可以获取元素整个滚动区域的宽度和高度\n\t\t\t\t\t \n\t\t\t\t\t \t出现滚动框一般都是子元素的宽度或高度超出父元素的大小，且此时父元素开启了overflow:auto; 属性，此时使用 父元素.scrollHeight 获取的是里面子元素的高度；\n\t\t\t\t\t */\nconsole.log(demo1.scrollHeight);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * scrollLeft\n\t\t\t\t\t * \t- 可以获取水平滚动条滚动的距离\n\t\t\t\t\t * scrollTop\n\t\t\t\t\t * \t- 可以获取垂直滚动条滚动的距离\n\t\t\t\t\t 获取的是滚动条滚动的距离\n\t\t\t\t\t */\n\n\t\t\t\t\t//当满足scrollHeight - scrollTop == clientHeight\n\t\t\t\t\t//scrollHeight相当于父元素内部的溢出的子元素高度，scrollTop等于当前垂直滚动条滚动的距离，clientHeight等于此时父元素的高度，scrollTop的距离是一直在改变的，当scrollTop滑到顶部也就是最大值时，子元素在父元素的中显示的内容高度恰好等于父元素的clientHeight；\n\t\t\t\t\t//说明垂直滚动条滚动到底了\n\t\t\t\t\t\n\t\t\t\t\t//当满足scrollWidth - scrollLeft == clientWidth\n\t\t\t\t\t//说明水平滚动条滚动到底\n\t\t\t\t\t//alert(box4.scrollHeight - box4.scrollTop); // 600\nconsole.log(demo1.scrollTop);","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"String-正则表达式","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/22/String-正则表达式/","content":"String相关方法字符串在底层中其实是以字符数组的形式保存的；\nvar str = \"hello\";\nconsole.log(str.length);  //输出 5\nconsole.log(str[1]);  //输出 e\n\n\t\t\t/*\n\t\t\t * charAt()\n\t\t\t * \t- 可以返回字符串中指定位置的字符\n\t\t\t * \t- 根据索引获取指定的字符\n             \t\t该方法不太常用，需要使用索引获取单个字符的话，直接使用str[index]更加便捷；\n\t\t\t */\nvar str = \"helloworld\";\nconsole.log(str.charAt('3'));  //输出 l\n\n\t\t\t/*\n\t\t\t * charCodeAt()\n\t\t\t * \t- 获取指定位置字符的字符编码（Unicode编码）\n\t\t\t */\nvar str = \"helloLK\"; \nconsole.log(str.charCodeAt(2));  //输出 108 即字符l的Unicode编码是108；\n\n\t\t\t/*\n\t\t\t * String.formCharCode()\n\t\t\t * \t- 可以根据字符编码去获取字符\n\t\t\t */\nconsole.log(String.fromCharCode(108));  //输出 字符 l；\n\n\t\t\t/*\n\t\t\t * concat()\n\t\t\t * \t- 可以用来连接两个或多个字符串\n\t\t\t * \t- 作用和+一样\n\t\t\t */\nvar str = \"hello\";\nconsole.log(str.concat(\"world\")); //输出 helloworld\n\n\t\t\t/*\n\t\t\t * indexof()\n\t\t\t * \t- 该方法可以检索一个字符串中是否含有指定内容\n\t\t\t * \t- 如果字符串中含有该内容，则会返回其第一次出现的索引\n\t\t\t * \t\t如果没有找到指定的内容，则返回-1\n\t\t\t * \t- 可以指定一个第二个参数，指定开始查找的位置\n\t\t\t * \n\t\t\t * lastIndexOf();\n\t\t\t * \t- 该方法的用法和indexOf()一样，\n\t\t\t * \t\t不同的是indexOf是从前往后找，\n\t\t\t * \t\t而lastIndexOf是从后往前找  -- 返回的索引是从从左往右开始的\n\t\t\t * \t- 也可以指定开始查找的位置\n\t\t\t */\nvar str = \"hello\";\nconsole.log(str.indexOf(\"a\"));  //返回 -1 说明查找失败\nconsole.log(str.indexOf(\"l\"));  //返回 2 说明字符 l 在第三个字符\nconsole.log(str.indexOf(\"l\",3)); //返回3 说明从索引为3开始查找字符 l \nconsole.log(str.lastIndexOf(\"l\"));  //返回 3 说明从后往前找 ，首次出现字符 l 在第4个字符\n\n\t\t\t/*\n\t\t\t * slice()\n\t\t\t * \t- 可以从字符串中截取指定的内容\n\t\t\t * \t- 不会影响原字符串，而是将截取到内容返回\n\t\t\t * \t- 参数：\n\t\t\t * \t\t第一个，开始位置的索引（包括开始位置）\n\t\t\t * \t\t第二个，结束位置的索引（不包括结束位置）\n\t\t\t * \t\t\t- 如果省略第二个参数，则会截取到后边所有的\n\t\t\t * \t\t- 也可以传递一个负数作为参数，负数的话将会从后边计算\n\t\t\t */\nvar str = \"helloworld\";\nvar result = str.slice(1,2);\nconsole.log(str);  //输出 helloworld\nconsole.log(result);  // 输出 e\nresult = str.slice(2);\nconsole.log(result); // 输出 lloworld\nconsole.log(str.slice(2,-1)); //输出 lloworl  参数-1表示在倒数第一个位置停止截取\n\n\t\t\t/*\n\t\t\t * substring()\n\t\t\t * \t- 可以用来截取一个字符串，可以slice()类似\n\t\t\t * \t- 参数：\n\t\t\t * \t\t- 第一个：开始截取位置的索引（包括开始位置）\n\t\t\t * \t\t- 第二个：结束位置的索引（不包括结束位置）\n\t\t\t * \t\t- 不同的是这个方法不能接受负值作为参数，\n\t\t\t * \t\t\t如果传递了一个负值，则默认使用0\n\t\t\t * \t\t- 而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换\n\t\t\t */\nvar str = \"helloworld\";\nconsole.log(str.substring(1,3)); //输出 el\nconsole.log(str.substring(1,0)); // 输出 h 第二个参数小于第一个参数，自动调整为（0,1）\n\n\t\t\t/*\n\t\t\t * substr()\n\t\t\t * \t- 用来截取字符串\n\t\t\t * \t- 参数：\n\t\t\t * \t\t1.截取开始位置的索引\n\t\t\t * \t\t2.截取的长度\n\t\t\t */\nvar str = 'helloworld';\nconsole.log(str.substr(1,3));  //输出 ell 表示从第二个字符开始截取是三个字符\n\n\t\t\t/*\n\t\t\t * split()\n\t\t\t * \t- 可以将一个字符串拆分为一个数组\n\t\t\t * \t- 参数：\n\t\t\t * \t\t-需要一个字符串作为参数，将会根据该字符串去拆分数组\n\t\t\t */\nvar str = \"helloworld\";\nvar arr = str.split(\"w\");\nconsole.log(str); //输出 helloworld\nconsole.log(Array.isArray(arr)); //输出 true\nconsole.log(arr); // 输出 ['hello', 'orld']  从字符 w 处分开，且不包含字符 w \nconsole.log(str.split(\"\"));  //输出  ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']\n\n\t\t\t/*\n\t\t\t * toUpperCase()\n\t\t\t * \t- 将一个字符串转换为大写并返回\n\t\t\t */\nvar str = \"hedenLsdHGH\";\nconsole.log(str.toUpperCase());  //输出 HEDENLSDHGH\n\n\t\t\t/*\n\t\t\t * toLowerCase()\n\t\t\t * \t-将一个字符串转换为小写并返回\n\t\t\t */\nvar str = \"hedenLsdHGH\";\nconsole.log(str.toLowerCase());  //输出 hedenlsdhgh\n正则表达式//创建正则表达式对象 -- 使用构造函数创造\n\t\t\t/*\n\t\t\t * 语法：\n\t\t\t * \tvar 变量 = new RegExp(\"正则表达式\",\"匹配模式\");\n\t\t\t *  使用typeof检查正则对象，会返回object\n\t\t\t * \tvar reg = new RegExp(\"a\"); 这个正则表达式可以来检查一个字符串中是否含有a\n\t\t\t * 在构造函数中可以传递一个匹配模式作为第二个参数，\n\t\t\t * \t\t可以是 \n\t\t\t * \t\t\ti 忽略大小写 \n\t\t\t * \t\t\tg 全局匹配模式\n\t\t\t */\n\t\t\t/*\n\t\t\t * 正则表达式的方法：\n\t\t\t * \ttest()\n\t\t\t * \t - 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，\n\t\t\t * \t\t如果符合则返回true，否则返回false\n\t\t\t */\nvar reg = new RegExp(\"ab\",\"i\");  //创建正则表达式规则 要求字符串中要包含有 \"ab\"，且不区分大小写\nconsole.log(reg.test(\"sdxardbasds\"));  //输出 false\nconsole.log(reg.test(\"hsujabiijio\"));  // 输出 true\nconsole.log(reg.test(\"Absdjs\"));  //输出 true\n\n方括号\n//使用字面量创建正则表达式\nvar reg = /ab/i;   //等同于new RegExp(\"ab\",\"i\");\nconsole.log(reg.test(\"abhdjshuh\")); //输出 true\n\n\t\t\t/*\n\t\t\t\t方括号\n\t\t\t * 使用 | 表示或者的意思\n\t\t\t * []里的内容也是或的关系\n\t\t\t * [ab] == a|b\n\t\t\t * [a-z] 任意小写字母\n\t\t\t * [A-Z] 任意大写字母\n\t\t\t * [A-z] 任意字母\n\t\t\t * [0-9] 任意数字\n\t\t\t  * [^ ] 除了\n\t\t\t */\nreg = /a|b|c/;  //创建一个规则为包含字符 a 或 b 或 c 的正则对象\nconsole.log(reg.test(\"asddefe\"));  //输出 true \n\nreg = /[A-Z]/;  //创建一个规则为包含字符 A 到 Z 的正则对象\nconsole.log(reg.test(\"asjjHsBd\"));  //返回 true\n\nreg = /[^BS]/;  //创建一个规则为除了字符BS以外的正则对象\nconsole.log(reg.test(\"Bdfgs\"));  //输出 true 因为该字符串中BS外还有其他字符\nconsole.log(reg.test(\"AHYGdfsb\")); //输出 true\nconsole.log(reg.test(\"B\"));  // 输出false\n元字符\n\t\t\t/*\n\t\t\t * \\w\n\t\t\t * \t- 任意字母、数字、_  [A-z0-9_]\n\t\t\t * \\W\n\t\t\t * \t- 除了字母、数字、_  [^A-z0-9_]\n\t\t\t * \\d\n\t\t\t * \t- 任意的数字 [0-9]\n\t\t\t * \\D\n\t\t\t * \t- 除了数字 [^0-9]\n\t\t\t * \\s\n\t\t\t * \t- 空格\n\t\t\t * \\S\n\t\t\t * \t- 除了空格\n\t\t\t * \\b\n\t\t\t * \t- 单词边界\n\t\t\t * \\B\n\t\t\t * \t- 除了单词边界\n\t\t\t */\nvar reg = /\\w/;  //创建一个规则为包含任意字母，数字，_的正则对象；\nconsole.log(reg.test(\"!###@\"));  //输出 false\nconsole.log(reg.test(\"#$$%asdf432\"));  //输出 true\n\nvar reg = /\\s/; //创建一个规则为包含空格的正则对象；\nconsole.log(reg.test(\"hsdjhsch\"));   //输出 false\nconsole.log(reg.test(\"fgdsjk jkjlko\"));  //输出 true\n\nvar reg = /\\b\\w&#123;3&#125;\\b/;  //创建一个包含单词边界的正则对象；\nconsole.log(reg.test(\"sdfdsf\")); //输出 false\nconsole.log(reg.test(\" jhf jsd h fkgjksfdjfio\"));  //输出 true\n量词\n/*\n\t\t\t * 量词\n\t\t\t * \t- 通过量词可以设置一个内容出现的次数\n\t\t\t * \t- 量词只对它前边的一个内容起作用\n\t\t\t * \t- &#123;n&#125; 正好出现n次\n\t\t\t * \t- &#123;m,n&#125; 出现m-n次\n\t\t\t * \t- &#123;m,&#125; m次以上\n\t\t\t * \t- + 至少一个，相当于&#123;1,&#125;\n\t\t\t * \t- * 0个或多个，相当于&#123;0,&#125;\n\t\t\t * \t- ? 0个或1个，相当于&#123;0,1&#125;\n\t\t\t */\nvar reg = /[ab]&#123;3&#125;/;  //创建一个规则为连续出现三次字符a或者字符b的正则对象\nconsole.log(reg.test(\"adsd\"));  //输出 false\nconsole.log(reg.test(\"aabbbsd\"));  //输出 true\n\nvar reg = /s&#123;1,3&#125;/;  //创建一个规则为连续出现1到三次的字符s的正则对象\nconsole.log(reg.test(\"fgfdhg\"));  //输出 false\nconsole.log(reg.tets(\"dddssgf\")); // 输出 true\nconsole.log(reg.test(\"ssss\"));  //输出 true  -- 当虽然这里有4个s字符，但是在未开启全局模式时\n\t\t\t\t\t\t\t//还没开始检测第四个字符就会返回true\n\t\t\t\t\t\t\t//如果要求严格控制在1到3次，需要开启全局匹配模式\n\n\t\t\t/*\n\t\t\t * \t^ 表示开头\n\t\t\t * \t$ 表示结尾\n\t\t\t */\nvar reg = /^a|b$/;  //创建一个规则为以a字符开头或者b字符结尾的正则对象\nconsole.log(reg.test(\"dfdffsf\"));  //输出 false\nconsole.log(reg.test(\"adsdjjd\"));  //输出 true\nconsole.log(reg.test(\"dsfsb\"));   //输出 true\nRegExp方法\n\t\t\t/*\n\t\t\t * split()\n\t\t\t * \t- 可以将一个字符串拆分为一个数组\n\t\t\t * \t- 方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串\n\t\t\t * \t- 这个方法即使不指定全局匹配，也会全都插分\n\t\t\t */\nvar str = \"helloworld\";\nvar result = str.split(/[lr]/);  //根据字母lr来拆分字符串；\nconsole.log(result);  //输出  ['he', '', 'owo', '', 'd']\nconsole.log(result instanceof Array); //输出true\n\n\t\t\t/*\n\t\t\t * search()\n\t\t\t * \t- 可以搜索字符串中是否含有指定内容\n\t\t\t * \t- 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1\n\t\t\t * \t- 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串\n\t\t\t * \t- serach()只会查找第一个，即使设置全局匹配也没用\n\t\t\t */\nvar str = \"heooljsdhfuhdsftFFDDDhnduhasui\";\nconsole.log(str.search(/f[adHt]f/i));  //输出 14\n\n\t\t\t/*\n\t\t\t * match()\n\t\t\t * \t- 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来\n\t\t\t * \t- 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索\n\t\t\t * \t\t我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容\n\t\t\t * \t\t可以为一个正则表达式设置多个匹配模式，且顺序无所谓\n\t\t\t * \t- match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果\n\t\t\t */\nvar str = \"heooljsdhfuhdsftFFDDDhnduhasui\";\nconsole.log(str.match(/f[adHt]f/i));//输出 ['ftF', index: 14, input:'heooljsdhfuhdsftFFDDDhnduhasui']\n\n\t\t\t/*\n\t\t\t * replace()\n\t\t\t * \t- 可以将字符串中指定内容替换为新的内容\n\t\t\t *  - 参数：\n\t\t\t * \t\t1.被替换的内容，可以接受一个正则表达式作为参数\n\t\t\t * \t\t2.新的内容\n\t\t\t *  - 默认只会替换第一个\n\t\t\t */\nvar str = \"heooljsdhfuhdsftFFDDDhnduhasui\";\nconsole.log(str.replace(/f[adHt]f/gi,\"@\")); //输出 heooljsdhfuhds@FDDDhnduhasui","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"数组-Date-Math","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/21/数组-Date-Math/","content":"数组（Array）\t数组也是一个对象，功能和普通对象类似，不同的是普通对象是使用字符串来作为属性名的，而数组使用数字索引来操作元素；\n\t索引是从0开始的，数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据；\n    \n    //创建数组对象；\n    var arr = new Array();\n\tconsole.log(typeof arr);  //输出 object ；\n\t\n\t//向数组中添加元素\n\tarr[0] = 1;\n\tarr[1] = 2;\n\n\t//读取数组中的元素值 如果读取不存在的索引，不会报错而是返回 undefined；\n\tconsole.log(arr[0]); //输出 1\n\tconsole.log(arr[2]); //输出undefined\n\n\t//获取数组的长度 -- 使用 数组名.length 来获取数组的长度\n\t //对于非连续的数组，使用length会获取到数组的最大的索引+1，尽量不要创建非连续的数组\n\tconsole.log(arr.length); //输出 2\n\t\n\t//修改length 如果修改的length值大于数组现有长度，则多出的部分会空出来，否则多出的元素会被删除；\n\tarr.length = 3;\n\tconsole.log(arr);  //输出 1,2， empty\n\t\n\tarr.length = 1;\n \tconsole.log(arr); //输出 1 ；\n\n\t//向数组最后一个位置添加元素\n\tarr[arrlength] = 2;\n\tconsole.log(arr); //输出 1,2；\n\tconsole.log(arr.length); //输出 2；\n\n使用字面量来常见数组；\nvar arr = [];  //使用字面量创建一个名为 arr 的空数组；\n//创建一个数组数组中只有一个元素10\narr = [10];\nconsole.log(arr instanceof Array);  //输出 true\n\n//使用字面量创建数组时，可以在创建时就指定数组中的元素\nvar arr = [1,2,3,4,5,10];\n\n//使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作文构造函数的参数传递\n//元素之间使用,隔开\nvar arr2 = new Array(10,20,30);\nconsole.log(arr2); //  输出 Array[3] \n//使用构造函数创造数组是只传入一个参数时，这个参数会被作为设置数组的长度，而不是成为数组的第一个元素；\n//创建一个长度为10的数组\narr2 = new Array(10);\nconsole.log(arr2);  //输出 (10) [empty × 10]\n\n//数组中的元素可以是任意的数据类型，可以是五种基本数据类型，也可以是对象，函数；\nvar obj = &#123;\n    name:\"LK\"\n&#125;\nfunction fun()&#123;\n    console.log(\"ffff\");\n&#125;\narr = [\"hello\",1,true,null,undefined,obj,fun];\nconsole.log(arr[5]); //输出 &#123;name: 'LK'&#125;\n\n//数组中也可以放数组，如下这种数组我们称为二维数组\narr = [[1,2,3],[3,4,5],[5,6,7]];\nconsole.log(arr[1]);  //输出 [3,4,5]\n数组元素的插入删除方法\t\t\t/*\n\t\t\t * push()\n\t\t\t * \t- 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度\n\t\t\t * \t- 可以将要添加的元素作为方法的参数传递，\n\t\t\t * \t\t这样这些元素将会自动添加到数组的末尾\n\t\t\t * \t- 该方法会将数组新的长度作为返回值返回\n\t\t\t */\nvar arr = [1,2,3];\nvar length = arr.push(4,5);\nconsole.log(arr); // 输出 [1,2,3,4,5]\nconsole(lenght); //输出 5\n\n\t\t\t/*\n\t\t\t * pop()\n\t\t\t * \t- 该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回\n\t\t\t */\nvar value = arr.pop();\nconsole.log(arr);  //输出 [1,2,3,4]\nconsole.log(value);  //输出 5\n\n\t\t\t/*\n\t\t\t * unshift()\n\t\t\t * \t- 向数组开头添加一个或多个元素，并返回新的数组长度\n\t\t\t * \t- 向前边插入元素以后，其他的元素索引会依次调整\n\t\t\t */\nlength = arr.unshift(6,7);\nconsole.log(arr);  //输出 [6,7,1,2,3,4]\nconsole.log(length);  //输出 6\n\n\t\t\t/*\n\t\t\t * shift()\n\t\t\t * \t- 可以删除数组的第一个元素，并将被删除的元素作为返回值返回\n\t\t\t */\nvalue = arr.shift();\nconsole.log(arr);  //输出 [7,1,2,3,4]\nconsole.log(value);  //输出 6；\nforEach()除了使用for循环去遍历数组，还可以使用forEach()方法遍历数组，该方法只支持IE8以上的浏览器；\n\nforEach()方法需要传入一个函数作为参数\n\t这种由我们创建但不是我们主动调用的函数称为回调函数；\n    在forEach()函数中，数组有几个元素该函数就会被执行几次；\n    可以在传入的回调函数书写自己的业务，可以在回调函数中传入3个参数，\n    \t第一个参数 -- 当前正在遍历的元素\n        第二个元素 -- 当前正在遍历的元素的索引\n        第三个元素 -- 正在遍历的完整数组；\n        \n var arr = [1,2,3,4,5];\narr.forEach(function(value,index,obj)&#123;\n    //value是当前遍历到的数组元素\n    //index是当前正在遍历的元素索引\n    //obj是当前传入的整个数组对象\n    ...业务逻辑;\n    ...\n&#125;);\nslice()\t\t\t/*\n\t\t\t * slice()\n\t\t\t * \t- 可以用来从数组提取指定元素\n\t\t\t * \t- 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回\n\t\t\t * \t- 参数：\n\t\t\t * \t\t1.截取开始的位置的索引,包含开始索引\n\t\t\t * \t\t2.截取结束的位置的索引,不包含结束索引\n\t\t\t * \t\t\t- 第二个参数可以省略不写,此时会截取从开始索引往后的所有元素\n\t\t\t * \t\t- 索引可以传递一个负值，如果传递一个负值，则从后往前计算\n\t\t\t * \t\t\t-1 倒数第一个\n\t\t\t * \t\t\t-2 倒数第二个\n\t\t\t */\n\nvar arr = [1,2,3,4,5];\nvar results = arr.slice(1,3);\nconsole.log(arr);  //返回 Array(5) [1,2,3,4,5]\nconsole.log(results);  //返回Array(2) [2,3]\nconsole.log(typeof results); //返回 Object\nsplice()\t\t\t/*\n\t\t\t * splice()\n\t\t\t * \t- 可以用于删除数组中的指定元素\n\t\t\t * \t- 使用splice()会影响到原数组，会将指定元素从原数组中删除\n\t\t\t * \t\t并将被删除的元素作为返回值返回\n\t\t\t * \t- 参数：\n\t\t\t * \t\t第一个，表示开始位置的索引\n\t\t\t * \t\t第二个，表示删除的数量\n\t\t\t * \t\t第三个及以后。。\n\t\t\t * \t\t\t可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边\n\t\t\t * \t\n\t\t\t */\nvar arr = [1,2,3,4,5,6];\nvar results = arr.splice(1,3,7,8);\nconsole.log(arr);  //返回 Array(5) [1,7,8,5,6]\nconsole.log(results);  //返回 Array(3) [2,3,4]\nconcat()\t\t\t/*\n\t\t\t * concat()可以连接两个或多个数组，并将新的数组返回\n\t\t\t * \t- 该方法不会对原数组产生影响\n\t\t\t */\nvar arr = [1,2,3];\nvar arr2 = [4,5,6];\nvar results = arr.concat(arr2);\nconsole.log(arr); //返回 Array(3) [1,2,3]\nconsole.log(arr2); //返回 Array(3) [4,5,6]\nconsole.log(results);  //返回 Array(6) [1,2,3,4,5,6]\njoin()\t\t\t/*\n\t\t\t * join()\n\t\t\t * \t- 该方法可以将数组转换为一个字符串\n\t\t\t * \t- 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回\n\t\t\t * \t- 在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符\n\t\t\t * \t\t如果不指定连接符，则默认使用 , 作为连接符\n\t\t\t */\nvar arr = [\"hello\",\"world\",\"LK\"];\nvar results = arr.join(\"-\");\nconsole.log(arr);  //返回原数组\nconsole.log(results);  //返回字符串 hello-world-LK\nconsole.log(typeof results); // 返回 string\nreverse()\t\t\t/*\n\t\t\t * reverse()\n\t\t\t * \t- 该方法用来反转数组（前边的去后边，后边的去前边）\n\t\t\t * \t- 该方法会直接修改原数组\n\t\t\t */\nvar arr = [1,2,3,4,5,6];\narr.reverse();\nconsole.log(arr); //返回 Array(6)  [6,5,4,3,2,1]\nsort()\t\t\t/*\n\t\t\t * sort()\n\t\t\t * \t- 可以用来对数组中的元素进行排序\n\t\t\t * \t- 也会影响原数组，默认会按照Unicode编码进行排序\n\t\t\t */\nvar arr = [1,3,2,6,4,7,5];\narr.sort();\nconsole.log(arr);  //返回  Array(7) [1,2,3,4,5,6,7]\narr = [11,2,5,34,3,6];\narr.sort();\nconsole.log(arr);  //返回 Array(5) [11, 2, 3, 34, 5, 6]  可知sort方法使用Unicode编码进行比较排序\n\n\t\t\t/*\n\t\t\t * 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，\n\t\t\t * \t所以对数字进排序时，可能会得到错误的结果。\n\t\t\t * \n\t\t\t * 我们可以自己来指定排序的规则\n\t\t\t * \t我们可以在sort()添加一个回调函数，来指定排序规则，\n\t\t\t * \t\t回调函数中需要定义两个形参,\n\t\t\t * \t\t浏览器将会分别使用数组中的元素作为实参去调用回调函数\n\t\t\t * \t\t使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边\n\t\t\t * \t- 浏览器会根据回调函数的返回值来决定元素的顺序，\n\t\t\t * \t\t如果返回一个大于0的值，则元素会交换位置\n\t\t\t * \t\t如果返回一个小于0的值，则元素位置不变\n\t\t\t * \t\t如果返回一个0，则认为两个元素相等，也不交换位置\n\t\t\t * \n\t\t\t * \t- 如果需要升序排列，则返回 a-b\n\t\t\t * \t\t如果需要降序排列，则返回b-a\n\t\t\t */\narr = [5,4,2,1,3,6,8,7];\narr.sort(function(a,b)&#123;\n    //升序排列\n\t//return a - b;\n\t\t\t\t\n\t//降序排列\n\treturn b - a;\n&#125;);\nconsole.log(arr);  //返回 Array(8) [8, 7, 6, 5, 4, 3, 2, 1]\ncall()和apply()\t\t\t/*\n\t\t\t * call()和apply()\n\t\t\t * \t- 这两个方法都是函数对象的方法，需要通过函数对象来调用\n\t\t\t * \t- 当对函数调用call()和apply()都会调用函数执行\n\t\t\t * \t- 在调用call()和apply()可以将一个对象指定为第一个参数\n\t\t\t * \t\t此时这个对象将会成为函数执行时的this\n\t\t\t * \t- call()方法可以将实参在对象之后依次传递\n\t\t\t * \t- apply()方法需要将实参封装到一个数组中统一传递\n\t\t\t * \n\t\t\t * \t- this的情况：\n\t\t\t * \t\t1.以函数形式调用时，this永远都是window\n\t\t\t * \t\t2.以方法的形式调用时，this是调用方法的对象\n\t\t\t * \t\t3.以构造函数的形式调用时，this是新创建的那个对象\n\t\t\t * \t\t4.使用call和apply调用时，this是指定的那个对象\n\t\t\t */\nvar name  = \"Hello\";\nvar obj = &#123;\n    name:\"LK\"\n&#125;\nvar obj2  = &#123;\n    name:\"ZK\"\n&#125;\nfunction fun()&#123;\n    console.log(this.name);\n&#125;\nfun();  // 输出 Hello\nfun.call(obj); //输出 LK\nfun.apply(obj2);  //输出 ZK\n\nfunction  fun2(a,b)&#123;\n    console.log(this.name);\n    console.log(\"a = \"+a);\n    console.log(\"b = \"+b);\n&#125;\nfun2.call(obj,1,2);  //输出 LK a = 1, b = 2\nfun2.apply(obj2,[1,2]);  //输出 ZK a = 1, b = 2\narguments\t\t\t/*\n\t\t\t * 在调用函数时，浏览器每次都会传递进两个隐含的参数：\n\t\t\t * \t1.函数的上下文对象 this\n\t\t\t * \t2.封装实参的对象 arguments\n\t\t\t * \t\t- arguments是一个类数组对象,它也可以通过索引来操作数据，也可以获取长度\n\t\t\t * \t\t- 在调用函数时，我们所传递的实参都会在arguments中保存\n\t\t\t * \t\t- arguments.length可以用来获取实参的长度\n\t\t\t * \t\t- 我们即使不定义形参，也可以通过arguments来使用实参，\n\t\t\t * \t\t\t只不过比较麻烦\n\t\t\t * \t\t\targuments[0] 表示第一个实参\n\t\t\t * \t\t\targuments[1] 表示第二个实参 。。。\n\t\t\t *\t\t- 它里边有一个属性叫做callee，\n\t\t\t * \t\t\t这个属性对应一个函数对象，就是当前正在指向的函数的对象\n\t\t\t * \t\t\n\t\t\t */\nfunction fun()&#123;\n    console.log(arguments[0]);   // 输出 1\n    console.log(arguments[1]);   // 输出 2\n    console.log(arguments.callee);\n    //输出：\n    /*  \n    ƒ fun()&#123;\n\t\t\t\tconsole.log(arguments[0]);\n\t\t\t\tconsole.log(arguments[1]);\n\t\t\t\tconsole.log(arguments.callee);\n\t\t\t&#125;\n\t*/\n&#125;\nfun(1,2);\nDateDate 对象 --- 在JS中表示一个时间\n\n//创建一个Date对象 -- 使用构造函数 ，不传参数 ，默认封装为当前代码的执行时间\nvar time = new Date();\nconsole.log(time);  // 返回 Tue Mar 22 2022 10:49:26 GMT+0800 (中国标准时间)\nconsole.log(typeof time);  //返回 object\n\n//创建一个指定时间对象，需要在构造函数中传递一个时间字符串作为参数 月份/日/年 时:分:秒\nvar time = new Date(\"6/7/2018 09:00:00\");\n//获取当前对象是多少号\nconsole.log(time.getDate());  //返回 7 -- 表示为这个月的7号\n//获取当前对象的月份\nconsole.log(time.getMonth());  //返回 5 -- 表示 6月 一月为0\n//获取当前对象是周几\nconsole.log(time.getDay());  //返回 4 表示是周4 每个星期从周日开始，从0开始\n//获取当前对象的年份\nconsole.log(time.getFullYear());  //返回 2018\n\n\t\t\t/*\n\t\t\t * getTime()\n\t\t\t * \t- 获取当前日期对象的时间戳\n\t\t\t * \t- 时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒\n\t\t\t * \t\t到当前日期所花费的毫秒数（1秒 = 1000毫秒）\n\t\t\t * \t- 计算机底层在保存时间时使用都是时间戳\n\t\t\t */\nconsole.log(time.getTime());  //返回 1528333200000\nMathMath和其他对象不同，它不是一个构造函数，属于一个工具类，不需要创建对象，可以直接调用其身上的相关方法；\n\nconsole.log(Math.PI);  //返回 3.141592653589793\nconsole.log(Math.E);  //返回 底数 e 2.718281828459045\n\nconsole.log(Math.abs(-1));  //返回 -1 的绝对值  1\n\n\t\t\t/*\n\t\t\t * Math.ceil()\n\t\t\t * \t- 可以对一个数进行向上取整，小数位只要有值就自动进1\n\t\t\t * Math.floor()\n\t\t\t * \t- 可以对一个数进行向下取整，小数部分会被舍掉\n\t\t\t * Math.round()\n\t\t\t * \t- 可以对一个数进行四舍五入取整\n\t\t\t */\nconsole.log(Math.ceil(1.0000001));  //返回 2\nconsole.log(Math.floor(1.9999999));  //返回 1\nconsole.log(Math.round(1.49999999));  // 返回 1\nconsole.log(Math.round(1.500000001));  // 返回 2\n\n\t\t\t/*\n\t\t\t * Math.random()\n\t\t\t * \t- 可以用来生成一个0-1之间的随机数  包含0 不包含1\n\t\t\t *  - 生成一个0-10的随机数\n\t\t\t * \t- 生成一个0-x之间的随机数\n\t\t\t * \t\tMath.round(Math.random()*x)\n\t\t\t * \n\t\t\t * \t- 生成一个1-10\n\t\t\t * \t- 生成一个x-y之间的随机数\n\t\t\t * \t\tMath.round(Math.random()*(y-x)+x)\n\t\t\t \n\t\t\t Math.random()*n --- 相当于将（0到1，包括0，不包括1）之间的数扩大n倍，此时能表示的范围为（0到n，包括0，但是不包括n）\n\t\t\t Math.random()*(y-x) -- 相当于将（0到1，包括0，不包括1）之间的数扩大（y-x）倍，此时能表示的范围为（0到 y-x ，包括0，但是不包括y-x）\n\t\t\t Math.random()*(y-x)+x -- 相当于将（0到 y-x）之间的数增大x，此时能表示的范围是（x到y，包括x，但是不包括y）\n\t\t\t Math.round(Math.random()*(y-x)+x) -- 相当于将（x到y，包括x，但是不包括y）之间的数进行四舍五入，此时能表示的范围是（x到y之间的所有整数，包括 x 和 y）\n\t\t\t */\n//随机生成 10 个 0到1的数\nfor(var i = 0; i &lt; 10 ; i++)&#123;\n   console.log(Math.random()); \n&#125;\n//随机生成 10 个 1到10 的数（不包含10）\nfor(var i = 0; i &lt; 10 ; i++)&#123;\n   console.log(Math.random()*10); \n&#125;\n//随机生成0到10的整数(包含1和10)\nfor(var i = 0; i &lt; 10 ; i++)&#123;\n   console.log(Math.round(Math.random()*10)); \n&#125;\n//随机生成一个 1 到 9 的数\nfor(var i = 0; i &lt; 10 ; i++)&#123;\n   console.log(Math.round(Math.random()*(9-1)+1)); \n&#125;\n\n\t\t\t/*\n\t\t\t * max() 可以获取多个数中的最大值\n\t\t\t * min() 可以获取多个数中的最小值\n\t\t\t */\nconsole.log(Math.max(1,45,43,33,5,4,226));  // 输出 226\nconsole.log(Math.min(1,45,43,33,5,4,226)); // 输出 1\n\n\t\t\t/*\n\t\t\t * Math.pow(x,y)\n\t\t\t * \t返回x的y次幂\n\t\t\t */\nconsole.log(Math.pow(2,3));  //返回 8\n\n\t\t\t/*\n\t\t\t * Math.sqrt()\n\t\t\t *  用于对一个数进行开方运算\n\t\t\t */ \nconsole.log(Math.sqrt(9));  //返回 3\n包装类\t\t\t/*\n\t\t\t * 基本数据类型\n\t\t\t * \tString Number Boolean Null Undefined\n\t\t\t * 引用数据类型\n\t\t\t * \tObject\n\t\t\t * \n\t\t\t * 在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象\n\t\t\t * \tString()\n\t\t\t * \t\t- 可以将基本数据类型字符串转换为String对象\n\t\t\t * \tNumber()\n\t\t\t * \t\t- 可以将基本数据类型的数字转换为Number对象\n\t\t\t *  Boolean()\n\t\t\t * \t\t- 可以将基本数据类型的布尔值转换为Boolean对象\n\t\t\t * \t但是注意：我们在实际应用中不会使用基本数据类型的对象，\n\t\t\t * \t\t如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果\n\t\t\t */\n//创建一个Number类对象 num\nvar num = new Number();\nnum.number = 1;\nconsole.log(num.number);  //输出 1\n//创建一个String类对象 str\nvar str = new String();\nstr.strs = \"hello\";\nconsole.log(str.strs);  //输出 hello\n//创建一个Boolean类对象 bool\nvar bool =  new Boolean();\nbool.flag = true;\nconsole.log(bool.flag); //输出 true\n\n\t\t\t/*\n\t\t\t * 可以给对象添加方法和属性，但是不能给基本数据类型添加属性和方法\n\t\t\t * \t当我们对一些基本数据类型的值去调用属性和方法时，\n\t\t\t * \t\t浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法\n\t\t\t * \t\t调用完以后，在将其转换为基本数据类型\n\t\t\t */\n\nvar a = 123;\na = a.toString();\nconsole.log(a);  //输出字符串 123\nconsole.log(typeof a);  //输出 string\n//这里之所以可以调用基本数据类型的额方式，其实是解析器在背后先将为number类型的a隐含的转换成Number类对象，并调用其身上的方法toString(),之后将将转换string‘值再返回给a，而不是返回Number对象；","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"this-构造函数-原型对象-原型","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/21/this-构造函数-原型对象-原型/","content":"this\t浏览器的解析器在每次调用函数时都会向函数内部传递一个隐含的参数 --- this ，this 指向一个对象 --- 函数执行的上下文（context）对象；\n\t根据函数的调用方式不同，this会指向不同的对象；\n    \t1.以函数的形式调用时，this指向window；\n        2.以方法的形式调用时，this指向当前调用方法的对象；\n        \n  function fun()&#123;\n      consolo.log(this);\n  &#125;\n\nfun();  //输出window；\n\nvar obj = &#123;\n    name:'LK',\n    fun:fun\n&#125;\nobj.fun();  //输出obj对象；\n\n在调用对象的方法时，可以在方法中通过this获取当前对象的其他属性值；\n\nvar obj2 = &#123;\n    name:\"obj2\",\n    fun:function()&#123;\n        console.log(this.name);\n    &#125;\n&#125;\nobj2.fun();  //输出obj2 ；\n\n工厂方法创建对象使用工厂方法可以快速创建对象；\n\t//定义一个可以生成包含name，age，gender属性值的对象的函数，返回值是对象；\n\tfunction createPerson(name,age,gender)&#123;\n        var obj = new Object();\n        obj.name = name;\n        obj.age = age;\n        obj.gender = gender;\n        obj.sayName = function()&#123;\n            console.log(this.name);\n        &#125;\n        return obj;\n    &#125;\n\n\tfunction createDog(name,age)&#123;\n        var obj = new Object();\n        obj.name = name;\n        obj.age = age;\n        obj.sayHello = function()&#123;\n            console.log(\"旺旺\");\n        &#125;\n        return obj;\n    &#125;\n\t\n\t//创建一个人的对象\n\tvar objPerson = createPerson(\"LK\",18,\"man\");\n\t//创建一个狗的对象\n\tvar objDog = createDog(\"lily\",1);\n\tconsole.log(objPerson);\n\tconsole.log(objDog);\n\t控制台输出均是Object，若不展开无法区分它们的区别；\n构造函数构造函数就是一个普通的函数，创建方法和普通函数一样，有一点不同的是构造函数的命名通常会首字母大写；\n\n在JS中直接调用的可以看成是普通函数，一旦使用 new 关键字就会把普通函数当成构造函数使用；\n\n构造函数的执行流程：\n\t1.首先创造一个对象；\n    2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象；\n    3.依次执行构造函数的代码；\n    4.将新建的对象作为返回值返回（构造函数是默认返回返回当前的新建对象的，即使不书写return也会返回；）；\n    \n 使用构造函数创建的对象，称为一类对象，也将一个构造函数称为一个类；我们将通过一个构造函数创建的对象称为是该类的实例；\n \n this的情况：\n\t\t\t * \t1.当以函数的形式调用时，this是window\n\t\t\t * \t2.当以方法的形式调用时，谁调用方法this就是谁\n\t\t\t * \t3.当以构造函数的形式调用时，this就是新创建的那个对象\n \n //定义一个Person类\n function Person(name,age,gender)&#123;\n     this.name = name;\n     this.age = age;\n     this.gender = gender;\n     this.sayName = function()&#123;\n         console.log(this.name);\n     &#125;\n     return this; //这一句有无都可以，构造函数默认返回this；但如果是当成普通函数调用的话，此时的this指向的是window；也就是说调用这个函数会往window身上设置name，age，gender等属性；\n &#125;\n\n//定义一个Dog类\nfunction Dog(name,age)&#123;\n    this.name = name;\n    this.age = age;\n    this.sayHello() = function()&#123;\n        console,log(\"旺旺\");\n    &#125;\n    return this;\n&#125;\n\n//创建一个Person类的实例 使用new关键字\nvar person = new Person(\"LK\",18,\"man\");\n//创建一个Dog类的实例\nvar dog = new Dog(\"lily\",1);\nconsole.log(person);\nconsole.log(dog);\n\n输出：\nPerson &#123;name: 'LK', age: 18, gender: 'man', sayName: ƒ&#125;\nDog &#123;name: 'lily', age: 1, sayHello: ƒ&#125;\n\n构造函数与工厂方式创建对象的不同在于可以看出构造函数创建的对象所属的类名；\n\n\t\t\t/*\n\t\t\t * 使用instanceof可以检查一个对象是否是一个类的实例\n\t\t\t * \t语法：\n\t\t\t * \t\t对象 instanceof 构造函数\n\t\t\t * 如果是，则返回true，否则返回false\n\t\t\t */\nconsole.log(person instanceof Person);  //输出true；\nconsole.log(person instanceof Dog);\t\t//输出false；\n原型 – prototype\t\t\t我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype\n\t\t\t * \t\t这个属性对应着一个对象，这个对象就是我们所谓的原型对象\n\t\t\t * \t如果函数作为普通函数调用prototype没有任何作用\n\t\t\t * \t当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性\n\t\t\t * \n\t\t\t * \t原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，\n\t\t\t * \t\t我们可以将对象中共有的内容，统一设置到原型对象中。\n\t\t\t * \n\t\t\t * 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，\n\t\t\t * \t如果没有则会去原型对象中寻找，如果找到则直接使用\n\t\t\t * \n\t\t\t * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，\n\t\t\t * \t这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了\n\n//声明一个全局作用函数\nfunction myClass()&#123;\n    \n&#125;\n//访问函数中的隐含属性prototype\nconsole.log(myClass.prototype);\n输出：\n&#123;constructor: ƒ&#125;\nconstructor: ƒ myClass()\n[[Prototype]]: Object\n可知函数身上确实有该prototype隐含属性；\n\n//声明Person类构造函数\n //定义一个Person类\n function Person(name,age,gender)&#123;\n     this.name = name;\n     this.age = age;\n     this.gender = gender;\n     this.sayName = function()&#123;\n         console.log(this.name);\n     &#125;\n     //默认返回this\n &#125;\n//向Person类的原型对象身上添加属性\nPerson.prototype.myName = \"我是Person类的原型对象的myName\";\n//向Person类的原型对象身上添加方法\nPerson.prototype.fun = function()&#123;\n    console.log(\"我是Person类原型对象身上的fun方法\");\n&#125;\n//创建一个Person类实例\nvar person1 = new Person(\"LK\",12,\"man\");\nvar person2 = new Person(\"Lily\",12,\"female\");\n//访问person1 和 person2 身上myName属性值\nconsole.log(person1.myName);\nconsole.log(person2.myName);\n输出：\n我是Person类的原型对象的myName\n我是Person类的原型对象的myName\n\n可知设置在构造函数的原型对象身上的属性和方法，同一个类（同一个构造函数）的实例都可以访问到；\n类的原型对象可以通过 实例的__proto__属性进行访问；该属性是在创建类实例是隐含添加的，同一个类的所有实例对象的__proto__属性值的指针都指向同一个原型对象，也就是一个类只有一个原型对象，也可以说是同一个类的所有实例对象共享同一个原型对象；\n\n//访问person1和person2对象上的__proto__属性\nconsole.log(person1.__proto__);\nconsole.log(person2.__proto__);\n均输出：\n&#123;myName: '我是Person类的原型对象的myName', fun: ƒ, constructor: ƒ&#125;\nfun: ƒ ()\nmyName: \"我是Person类的原型对象的myName\"\nconstructor: ƒ Person(name,age,gender)\n[[Prototype]]: Object\n\n//判断person1和person2对象的__proto__是否是同一个\nconsole.log(person1.__proto__ == person2.__proto__);\n输出 ： true；\n\n//判断Person类的原型对象和Person类实例对象的原型对象是否相等\nconsole.log(Person.prototype == person2.__proto__);\t\t\n输出 ： true；\n\n//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true\nconsole.log(\"toString\" in person1);  //输出true\n//可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性\n//使用该方法只有当对象自身中含有属性时，才会返回true\nconsole.log(person1.hasOwnProperty(\"toString\")); //输出false\n\n\t\t\t/*\n\t\t\t * 原型对象也是对象，所以它也有原型，\n\t\t\t * \t当我们使用一个对象的属性或方法时，会现在自身中寻找，\n\t\t\t * \t\t自身中如果有，则直接使用，\n\t\t\t * \t\t如果没有则去原型对象中寻找，如果原型对象中有，则使用，\n\t\t\t * \t\t如果没有则去原型的原型中寻找,直到找到Object对象的原型，\n\t\t\t * \t\tObject对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined\n\t\t\t */\nconsole.log(person1.__proto__.__proto__.hasOwnProperty(\"toString\")); //输出true\n\n\n优化构造函数中的方法  – 通用函数放在全局作用域声明//定义一个Person类\nfunction Person(name,age,gender)&#123;\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n    this.sayName = function()&#123;\n        console.log(this.name);\n    &#125;\n    //默认返回this\n&#125;\n\n在此构造函数中定义了一个sayName方法，在构造函数每执行一次创建一个新对象时，就会为这个新对象创建一个独属于自己的sayName方法，不同的对象实例需要在内存中占用不一样的堆内存区域，但其实每个Person实例对象的sayName方法的代码都是一致的，这样会导致内存资源的极大消耗；\n所以可以将通用的类方法放在全局作用域中声明；之后在类的构造函数中引用该全局作用域的函数；可以认为在创建每一个类实例对象时，它的身上都有一个sayName方法属性，但是它的sayName方法指针是指向全局作用域声明的sayName函数；\n   //声明全局的sayName函数\n   function sayName()&#123;\n       console.log(this.name);\n       //若将全局作用域声明的函数在类实例中使用时，此时的this不是指向window，而是此时调用该方法的类实例对象；\n   &#125;\n //定义一个Person类\nfunction Person(name,age,gender)&#123;\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n    //在类中使用全局的函数\n    this.sayName = sayName;\n    //默认返回this\n&#125;\n\n//创建一个Person类实例 \nvar person = new Person(\"LK\",17,\"man\");\n//调用person实例上的方法\nperson.sayName();\n输出 LK ；\n优化构造函数中的方法 – 通用函数在原型对象上声明将类的方法定义在全局作用域中，会污染全局作用域的命名空间，应该把类通用方法声明在类的原型对象身上；\n //定义一个Person类\n function Person(name,age,gender)&#123;\n     this.name = name;\n     this.age = age;\n     this.gender = gender;\n     //在类中使用全局的函数\n     this.sayName = sayName;\n     //默认返回this\n &#125;\n//向原型中添加sayName方法\n\t\t\tPerson.prototype.sayName = function()&#123;\n\t\t\t\talert(\"Hello大家好，我是:\"+this.name);\n\t\t\t&#125;;\n修改原型的toString方法//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值\n//如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法\n\tfunction Person(name , age , gender)&#123;\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.age = age;\n\t\t\t\tthis.gender = gender;\n\t\t\t&#125;\n//修改Person原型的toString\n\t\t\tPerson.prototype.toString = function()&#123;\n\t\t\t\treturn \"Person[name=\"+this.name+\",age=\"+this.age+\",gender=\"+this.gender+\"]\";\n\t\t\t&#125;;\n垃圾回收/*\n * 垃圾回收（GC）\n * \t- 就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾\n * \t\t这些垃圾积攒过多以后，会导致程序运行的速度过慢，\n * \t\t所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾\n *  - 当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，\n * \t\t此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，\n * \t\t所以这种垃圾必须进行清理。\n * \t- 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，\n * \t\t我们不需要也不能进行垃圾回收的操作\n * \t- 我们需要做的只是要将不再使用的对象设置null即可\n * \n */\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"对象-函数","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/20/对象-函数/","content":"对象重温JS的五种基本数据类型：\n\t1.String；\n    2.Number； --- NaN也属于Number类型；\n\t3.Boolean；\n    4.undefined；\n    5.NULL； --- typeof null 输出object，null为object的衍生；\n    \n    基本数据类型都是单一的值，值和值之间没有联系；\n    对象属于一种复合数据类型，在对象中可以保存多个不同数据类型的属性；\n    \n    对象的分类：\n    \t1.内建对象：由ES标准定义的对象，在任何ES的实现中都可以使用，比如 Math，String，Number，Boolean，Function，Object等；\n        2.宿主对象：由JS的运行环境提供的对象，目前主要指浏览器提供的对象，比如BOM，DOM；\n        3.自定义对象：由开发人员自己创建的对象；\n        \n     创建对象：\n     \t使用 new 关键字调用对象的构造函数\n\t\tvar obj = new Object();\n\t\t\n\t\t在对象中保存的值称为属性，向对象添加属性，语法：对象.属性名 = 属性值;\n\t\tobj.name = \"LK\";\n\n\t\t读取对象中的属性值，语法：对象.属性名\n\t\tconsole.log(obj.name);\n\t\t如果读取对象中没有的属性值，不会报错而是返回undefined；\n        \n        修改对象的属性值，语法：对象.属性名 = 新的属性值；\n        obj.name = \"ZK\";\n\t\t\n\t\t删除对象的属性，语法：delete 对象.属性值;\n\t\tdelete obj.name;\n\n\t属性名：对象的属性名不强制要求遵守标识符的规范；\n    \t如果要是用特殊的属性名，需要使用另一种方式读取属性值：\n        \t语法：对象[\"属性名\"]\n\t属性值：对象的属性值可以是任何类型的数据类型，5种基本数据类型，对象，函数等\n    \tin 运算符：可以通过该运算符检查一个对象中是否含有指定的属性，返回值为Boolean；\n\t\tconsole.log(\"name\" in obj);\n\t\t\n基本数据类型与引用数据类型在新建基本数据类型的变量时，都是直接在内存的栈中开辟内存空间存放数据；\n\tvar a = 123; //此时程序在栈顶开辟一个内存区域存放变量名 a 和变量值 123，此时栈顶指针上移一位；\n\tvar b = a; //此时程序在栈顶开辟一个内存区域存放变量名 b 和变量值 123，此时栈顶指针上移一位；\n\ta = 456; //在程序的内存区域中寻找变量a的存放地址，并修改其变量值为 456；\n\tconsole.log(\"a = \"+a); //输出 a = 456；\n\tconsole.log(\"b = \"+ b); //输出 b = 123;\n\t可知内存中存放的基本数据类型变量都是单独存放的，值与值之间不会影响；\n \n在新建引用型变量 -- 对象时，会在内存的栈区存放对象名和对象的堆内存地址，在堆内存中存放对象的数据信息；\n\tvar obj = new Object(); //创建一个名为 obj 的对象，在栈顶申请内存空间存放对象名和该对象的堆内存地址，此时obj已经申请了堆内存空间，但还未存放信息；\n\tobj.name = \"LK\"; //给obj新建属性name，值为 LK，数据信息将存储在obj的堆内存区域；\n\tvar obj2 = obj; //新建一个obj2 对象，在栈内存区域申请空间存放对象名 obj2 和它的堆内存地址，此时obj2的堆内存地址和obj的堆内存地址相同，也就是这两个对象的堆内存指针指向同一块内存区域；\n\tobj.name = \"ZK\"; //修改obj的name属性值；\n\tconsole.log(obj.name);\n\tconsole.log(obj2.name);\n\t均输出 ZK ；//可知对象如果保存的是同一个对象的地址引用，则通过一个对象修改属性值时，另一个也会受到影响；\n    \n    \t\t/*\n\t\t\t * 当比较两个基本数据类型的值时，就是比较值。\n\t\t\t * 而比较两个引用数据类型时，它是比较的对象的内存地址，\n\t\t\t * \t\t如果两个对象是一摸一样的，但是地址不同，它也会返回false\n\t\t\t */\n    \n对象字面量在日常开发中，使用对象字面量创建一个对象比较常用；\n\tvar obj = &#123;&#125;; //创建一个名为 obj 的空对象；\n\n\t\t\t/*\n\t\t\t * 使用对象字面量，可以在创建对象时，直接指定对象中的属性\n\t\t\t * 语法：&#123;属性名:属性值,属性名:属性值....&#125;\n\t\t\t * \t对象字面量的属性名可以加引号也可以不加，建议不加,\n\t\t\t * \t如果要使用一些特殊的名字，则必须加引号\n\t\t\t * \n\t\t\t * 属性名和属性值是一组一组的名值对结构，\n\t\t\t * \t名和值之间使用:连接，多个名值对之间使用,隔开\n\t\t\t * \t如果一个属性之后没有其他的属性了，就不要写,\n\t\t\t */\n\t\t\tvar obj2 = &#123;\n\t\t\t\t\n\t\t\t\tname:\"猪八戒\",\n\t\t\t\tage:13,\n\t\t\t\tgender:\"男\",\n\t\t\t\ttest:&#123;name:\"沙僧\"&#125;\n\t\t\t\t\n\t\t\t&#125;;\n枚举对象中的属性枚举对象中的属性 -- 遍历对象中的属性；\n\t使用 for ... in 语句\n\t\t语法:\n\t\t\tfor(var 变量 in 对象名)&#123;\n                要执行的语句；\n                ...\n            &#125;\n                \n            * for...in语句 对象中有几个属性，循环体就会执行几次\n\t\t\t * \t每次执行时，会将对象中的一个属性名赋值给变量\n\t\t\t */\n\t\t\t\n\t\t\tfor(var n in obj)&#123;\n\t\t\t\tconsole.log(\"属性名:\"+n);\n\t\t\t\t\n\t\t\t\tconsole.log(\"属性值:\"+obj[n]);\n\t\t\t&#125;\n\n\n函数\t\t\t/*\n\t\t\t * 函数 function\n\t\t\t * \t- 函数也是一个对象\n\t\t\t * \t- 函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）\n\t\t\t * \t- 函数中可以保存一些代码在需要的时候调用\n\t\t\t * \t- 使用typeof检查一个函数对象时，会返回function\n\t\t\t */\n创建函数：\n\t方法1，使用构造函数来创建一个函数对象（开发中基本不使用）\n    \t//将要封装的代码以字符串的形式传递给构造函数；\n    \tvar func = new Function(\"console.log('创建一个名为func的函数！')\");\n\n\t方法2，使用函数声明来创建一个函数\n    \t语法：\n        \tfunction 函数名([形参1，形参2，...])&#123;\n                语句;\n                ...\n            &#125;\n         \n      方法3，使用函数表达式来创建一个函数\n      \tvar 函数名 = function([形参1，形参2,...])&#123;\n            语句；\n            ...\n        &#125;\n            \n 调用函数：\n \t函数名();\n函数的参数可以在函数的()中来指定一个或多个形参（形式参数），多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值；\n\t\t/*\n\t\t * 在调用函数时，可以在()中指定实参（实际参数）\n\t\t * \t实参将会赋值给函数中对应的形参\n\t\t */\n\t\t/*\n\t\t * 调用函数时解析器不会检查实参的类型,\n\t\t * \t所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查\n\t\t * 函数的实参可以是任意的数据类型\n\t\t */\n\t\t/*\n\t\t * 调用函数时，解析器也不会检查实参的数量\n\t\t * \t多余实参不会被赋值\n\t\t * 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined\n\t\t * \n\t\t */\n函数的返回值* 可以使用 return 来设置函数的返回值\n* \t语法：\n* \t\treturn 值\n* \n* \treturn后的值将会会作为函数的执行结果返回，\n* \t\t可以定义一个变量，来接收该结果\n* \n*  在函数中return后的语句都不会执行\n* \n* \t如果return语句后不跟任何值就相当于返回一个undefined，\n* \t如果函数中不写return，则也会返回undefined\n* \n* \treturn后可以跟任意类型的值\n\n立即执行函数/*\n * 立即执行函数\n * \t函数定义完，立即被调用，这种函数叫做立即执行函数\n * \t立即执行函数往往只会执行一次\n */\n/*(function()&#123;\n\talert(\"我是一个匿名函数~~~\");\n&#125;)();*/\n\n(function(a,b)&#123;\n\tconsole.log(\"a = \"+a);\n\tconsole.log(\"b = \"+b);\n&#125;)(123,456);\n输出 a = 123;\n\tb = 456;\n对象中的函数//对象的属性值可以是任何的数据类型，也可以是个函数\nobj.sayName = function()&#123;\n\t\t\t\tconsole.log(obj.name);\n\t\t\t&#125;;\n\n\t\t\t/*\n\t\t\t * 函数也可以称为对象的属性，\n\t\t\t * \t如果一个函数作为一个对象的属性保存，\n\t\t\t * \t那么我们称这个函数时这个对象的方法\n\t\t\t * \t调用这个函数就说调用对象的方法（method）\n\t\t\t * \n\t\t\t * 但是它只是名称上的区别没有其他的区别\n\t\t\t * \n\t\t\t */\n作用域（scope）\t\t\t/*\n\t\t\t * 作用域\n\t\t\t * \t- 作用域指一个变量的作用的范围\n\t\t\t * \t- 在JS中一共有两种作用域：\n\t\t\t * \t\t1.全局作用域\n\t\t\t * \t\t\t- 直接编写在script标签中的JS代码，都在全局作用域\n\t\t\t * \t\t\t- 全局作用域在页面打开时创建，在页面关闭时销毁\n\t\t\t * \t\t\t- 在全局作用域中有一个全局对象window，\n\t\t\t * \t\t\t\t它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用\n\t\t\t * \t\t\t- 在全局作用域中：\n\t\t\t * \t\t\t\t创建的变量都会作为window对象的属性保存\n\t\t\t * \t\t\t\t创建的函数都会作为window对象的方法保存\n\t\t\t * \t\t\t- 全局作用域中的变量都是全局变量，\n\t\t\t * \t\t\t\t在页面的任意的部分都可以访问的到\n\t\t\t * \n\t\t\t * \t\t2.函数作用域\n\t\t\t * \n\t\t\t */\n\nvar a = 123;\nconsole.log(window.a); //输出 123 ；\n\nfunction func()&#123;\n    console.log(\"hello\");\n&#125;\nwindow.func();  //输出 hello；\n变量的提前声明\t\t\t/*\n\t\t\t * 变量的声明提前\n\t\t\t * \t- 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），\n\t\t\t * \t\t但是如果声明变量时不适用var关键字，则变量不会被声明提前\n\t\t\t * \n\t\t\t * 函数的声明提前\n\t\t\t * \t- 使用函数声明形式创建的函数 function 函数()&#123;&#125;\n\t\t\t * \t\t它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数\n\t\t\t * \t   使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用\t\n\t\t\t */\n\n&lt;script>\n    console.log(a);\n\tvar a = 123;\n\t输出 undefined ； 此时 a已经被提前声明，但是为赋值，所以为undefined；\n&lt;/script>\n\n&lt;script>\n    func(); //输出 \"我是一个fun函数\" ；因为fun() 已经被完全声明， 声明fun()的所有代码已经被全部执行；\n\tfun2();  // 报错 Uncaught TypeError: fun2 is not a function\n\t//函数声明，会被提前创建\n\tfunction fun()&#123;\n\t\t\t\tconsole.log(\"我是一个fun函数\");\n\t\t\t&#125;\n\t//函数表达式，不会被提前创建\n\t\t\tvar fun2 = function()&#123;\n\t\t\t\tconsole.log(\"我是fun2函数\");\n\t\t\t&#125;;\n\n&lt;/script>\n函数的作用域\t\t\t/*\n\t\t\t * 函数作用域\t\n\t\t\t * \t- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁\n\t\t\t * \t- 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的\n\t\t\t * \t- 在函数作用域中可以访问到全局作用域的变量\n\t\t\t * \t\t在全局作用域中无法访问到函数作用域的变量\n\t\t\t * \t- 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用(如果在函数中需要使用同名的全局变量，可以使用window.变量名获取)；\n\t\t\t * \t\t如果没有则向上一级作用域中寻找，直到找到全局作用域，\n\t\t\t * \t\t如果全局作用域中依然没有找到，则会报错ReferenceError\n\t\t\t * \t- 在函数中要访问全局变量可以使用window对象\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * 在函数作用域也有声明提前的特性，\n\t\t\t * \t使用var关键字声明的变量，会在函数中所有的代码执行之前被声明\n\t\t\t * \t函数声明也会在函数中所有的代码执行之前执行（函数中的函数）\n\t\t\t */\n\n* 在函数中，不适用var声明的变量都会成为全局变量\nfunction fun5()&#123;\n\t\t\t\t//d没有使用var关键字，则会设置为全局变量\n\t\t\t\td = 100;\n\t\t\t&#125;\n\t\t\tfun5();\n\t\t\t//在全局输出c\n\t\t\tconsole.log(\"d = \"+d);\n输出 d = 100;\n\n* 定义形参就相当于在函数作用域中声明了变量\nvar e = 23;\nfunction fun6(e)&#123;\n\t\t\t\talert(e);\n\t\t\t&#125;\nfun6(); \n//输出 undefined； 定义函数时定义了形参相当于声明了函数作用域中的变量e，所以在调用函数时不会往函数外的全局作用域寻找变量e；调用时未传入参数则输出undefined；\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"流程控制语法","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/19/流程控制-循环/","content":"流程控制语句JS中代码按照从上到下的顺序执行，通过流程控制语句可以控制程序的执行流程，流程控制语句分为 ：\n​        （1）条件判断语句；\n​        （2）条件分支语句；\n​        （3）循环语句；\n条件判断语句 — if语句语法一： if(条件表达式)&#123;\n    语句；\n    ....\n&#125;\nif语句在执行时，一旦括号里的条件表达式为true时，就执行其下的代码块；\n\n语法二： if(条件表达式)&#123;\n    \t\t语句；\n    \t\t...\n\t\t&#125;else if(条件表达式)&#123;\n            语句；\n            ....\n        &#125;else&#123;\n            语句;\n            ....\n        &#125;\n  当执行该语句时，会从上依次判断if后面的条件表达式，在该语句中，只有一个代码块会执行，一旦进入某个代码块，执行完毕后将结束整个if语句，不会继续往下判断if条件表达式；当所有的if条件表达式均为false时，将进入else代码块；\n条件分支语句 — switch语句语法 ： \n\tswitch(条件表达式)&#123;\n        case 表达式1:\n            语句；\n            ...\n            break;\n        case 表达式2::\n        \t语句；\n            ...\n            break;\n            \n            ....\n            \n         default:\n            语句；\n            ...\n            break;\n    &#125;\n\n\t在执行时会依次将case后面的表达式与switch后的条件表达式进行 全等比较（===） ,只有比较结果为true时才会执行当前case后的语句；\n\t在case语句后的代码块中最后需要写入 break 关键字，否则当前case执行完以后会继续执行后面的case语句（不用判断直接执行）；\n\t若所有的case语句的表达式与switch中的条件表达式比较均为false，则执行default语句（也可以不书写default语句，此时将结束switch语句）；\n    \n    if语句和switch语句功能上两者可互相代替；\n循环语句 — while循环循环语句： 通过循环语句可以反复执行一段代码多次；\n\nwhile循环  语法：\n\twhile(条件表达式)&#123;\n          语句；\n          ...\n          &#125;\n     \n     while语句在执行时先对条件表达式进行求值判断，若条件表达式为true，则进入循环体，循环体代码块执行完毕以后再判断条件表达式是否成立，是否需要进入下一次循环；否则终止循环；\n     \n   do...while 循环 语法\n     do&#123;\n         语句；\n         ...\n     &#125;while(条件表达式)\n         \n     do...while语句在执行时会先执行循环体，循环体执行完以后在对while的条件表达式进行判断，结果为true则继续执行循环体否则结束循环；\n         \n     这两个循环语句功能类似，while语句是先判断再循环，do...while语句是先执行再判断，所以do...while语句至少执行一次；\n循环语句 — for循环for 循环 语法：\n\tfor(初始化表达式;条件表达式;更新表达式)&#123;\n        语句;\n        ...\n    &#125;\n        \n    for循环执行流程：\n    \t1.执行初始化表达式，初始化变量（初始化表达式只会执行一次）；\n        2.执行条件表达式，判断是否进入循环；\n     \t3.执行更新表达式，更像表达式执行完以后在继续执行第二步；\n        \n        for循环的三个部分都可以省略，也可以写在外部，如果在for循环中不写任何表达式只写两个 ;  此时循环会是一个死循环会一直执行下去；\n        \n for循环可以嵌套使用；\nbreak和continue\tbreak关键字可以用来退出switch或循环语句，但是不能单在if语句中只用，break关键字会立即终止离它最近的那个循环语句；\n   \t可以为循环语句创建一个label，来标识当前的循环；\n    \tlabel:循环语句\n        在使用break语句时，可以在break后跟着一个label，这样break就会结束指定的循环而不是最近的循环；\n        \n     continue关键字可以跳过本次循环，同样continue也是默认只会离它最近的循环起作用；\n     \n     outer:\n\t\t\tfor(var i=0 ; i&lt;5 ; i++)&#123;\n\t\t\t\tconsole.log(\"@外层循环\"+i)\n\t\t\t\tfor(var j=0 ; j&lt;5; j++)&#123;\n\t\t\t\t\tbreak outer; //这里的break指定了结束外部的循环体\n\t\t\t\t\tconsole.log(\"内层循环:\"+j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n输出：外层循环0\n\n\n\t\t\touter:\n\t\t\tfor(var i=0 ; i&lt;5 ; i++)&#123;\n\t\t\t\tconsole.log(\"@外层循环\"+i)\n\t\t\t\tfor(var j=0 ; j&lt;5; j++)&#123;\n\t\t\t\t\tbreak; //这里的break会结束内部的循环体\n\t\t\t\t\tconsole.log(\"内层循环:\"+j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n输出：\n @外层循环0\n @外层循环1\n @外层循环2\n @外层循环3\n @外层循环4\n\n\t\touter:\n\t\t\tfor(var i=0 ; i&lt;5 ; i++)&#123;\n\t\t\t\tconsole.log(\"@--->\"+i);\n\t\t\t\tfor(var j=0 ; j&lt;5 ; j++)&#123;\n\t\t\t\t\tif(j == 3)&#123;\n\t\t\t\t\t\tcontinue; //这里的continue会结束内部for循环的档次循环；\n\t\t\t\t\t&#125;\t\n\t\t\t\t\tconsole.log(\"-->\"+j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\touter:\n\t\t\tfor(var i=0 ; i&lt;5 ; i++)&#123;\n\t\t\t\tconsole.log(\"@--->\"+i);\n\t\t\t\tfor(var j=0 ; j&lt;5 ; j++)&#123;\n\t\t\t\t\tif(j == 3)&#123;\n\t\t\t\t\t\tcontinue outer;// 这里的continue指定结束外部for循环的当次循环；\n\t\t\t\t\t&#125;\t\n\t\t\t\t\tconsole.log(\"-->\"+j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n输出：\n04.break和continue.html:65 @--->0\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n04.break和continue.html:65 @--->1\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n04.break和continue.html:65 @--->2\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n04.break和continue.html:65 @--->3\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n04.break和continue.html:65 @--->4\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n练习 \t\t\t/*\n\t\t\t * 对于成绩大于60分的，输出'合格'。低于60分的，输出'不合格'\n             */\n\t\t  var score = 61;\n            switch (true)&#123;\n                case score >= 60 :\n                    console.log(\"合格\");\n                    break;\n                default :\n                    console.log(\"不合格\");\n            &#125;\n            console.log(typeof !!score);\n            console.log(!!score);\n\n输出：\n合格\nboolean\ntrue\n\nJS的switch中表达式可以是boolean值，但是java中不可以！！！在这里若把switch的表达式的 true 改为 score 则将只能执行default，因为switch中的表达式并不会自动进行类型转换，而是将switch的表达式与case的表达式进行全等比较（===）；\n\n\n\t\t\t/*\n\t\t\t * 从键盘接收整数参数，如果该数为1-7，打印对应的星期，否则打印非法参数。\n\t\t\t */\n\n             var day =parseInt(prompt(\"请输入数字（1~7）:\"));\n             switch (day)&#123;\n                 case 1:\n                     console.log(\"今天星期一\");\n                     break;\n                case 2:\n                     console.log(\"今天星期二\");\n                     break;\n                case 3:\n                     console.log(\"今天星期三\");\n                     break;\n                case 4:\n                     console.log(\"今天星期四\");\n                     break;\n                case 5:\n                     console.log(\"今天星期五\");\n                     break;\n                case 6:\n                     console.log(\"今天星期六\");\n                     break;\n                case 7:\n                     console.log(\"今天星期天\");\n                     break;\n      使用prompt()函数获取用户输入的参数，可传入一个字符串作为输入的提示，函数的返回值为string类型；\n      \n      \n      \t\t/*\n\t\t\t * 假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年\n\t\t\t */\n\n             var money = 1000;\n             var year = 0;\n             while(money &lt; 5000)&#123;\n                money = money * 1.05;\n                year++;\n             &#125;\n             console.log(\"需要\"+year+\"年\");\n                     \n             /* \n              质数练习\n             */\n                     \n            console.time(\"clock\");\n            for(var i = 2;i &lt;= 10000 ; i++)&#123;\n                var flag = true;\n                for(var j = 2; j &lt;= Math.sqrt(i); j++)&#123;\n                    if(i % j == 0)&#123;\n                        flag = false;\n                        break;\n                    &#125;\n                &#125;\n                if(flag)&#123;\n                    console.log(i+\"是质数\");\n                &#125;\n            &#125;\n            console.timeEnd(\"clock\");\n                     \n     console.time()函数开启一个计时器，需要传入一个字符串作为计时器的名字，\n     console.timeEnd()函数结束一个计时器，需要传入需要结束计时的计时器名称，将自动在控制台输出本次计时器所经历的时间；\n     Math.sqrt()函数可以获取一个数值的平方根，需要传入需要开方的数字，返回值为number类型中的浮点数；\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"运算符","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/18/运算符/","content":"运算符通过运算符可以对一个或多个值进行运算，并获取运算结果；\n一元运算符一元 : 只需要一个操作数；\n\" + \"号，正号不会对数字（number）产生任何影响；\n\" - \"号，负号可以对数字进行算术取反；\n\t对于非Number类型的数据来说，使用一元运算符时，会将其转换成number类型 --- 原理和使用Number()一致；\n自增和自减自增 ++ ；\n\t自增分为两种，前++和后++，这两者都会使原变量的值自增1；但是 i++ 和 ++i 的值是不一样的；\n    var i = 1;\n\tconsole.log(\"i++ = \" + i++);  //输出 i++ = 1;\n\ti = 1;\n\tconsole.log(\"++i = \" + ++i);  //输出 ++i = 2；\n\t可知 i++ 等于原变量的值，但是 ++i等于原变量自增1后的值；\n    即若 a = i++ ;  //即是将 a = i ；然后 i = i + 1； 即后加加是先使用原变量的值，之后原变量的值再自增1；\n\t\ta = ++i ; //即是将 i = i + 1 ； 然后 a = i ；即前加加是先原变量的值自增1，之后再将使用自增后的值；\n\t\t理解： 后加加（i++）里变量在前，+号在后，所以先使用原变量，之后原变量再自增；\n\t\t\t\t前加加（++i）里+号在前，变量在后，所以先变量自增1，之后再使用变量；\n\n自减 -- ；\n自减也分为两种 ，前-- 和 后-- ，这两者都会是原变量的值自减1， 但是 i-- 和 --i的值是不一样的；\n\t具体使用和 ++ 一致；\n\n\n算术运算符1.加法 \"+\" ：如果对两个字符串进行加法运算，会进行字符串的拼接，任何值和字符串相加都会想转换成字符串，然后进行字符串的拼接操作；\n   \t可以用利用这一特点进行任何数据类型进行字符串的隐式转换 ---- 实际上也是调用String()函数返回；\n    \tvar a = 123;\n \t\tconsole.log(a + '');  //输出字符串的“123”\n\n2.\"-\" , \"*\" , \"/\" , 任何值 做减法 ，乘法， 除法 运算时都会自动转换成Number类型；\n   \t可以利用这点将任何数据类型进行Number的隐式转换；\n       var a = \"123\";\n\tconsole.log(a-0);  //输出number类型的 123\n\n3.模运算 \"%\" : 求余数运算；\n逻辑运算符&amp;&amp; --- 与\n\t两个值中只要有一个false时就返回false，只有两个值为true时才返回true，如果第一个值为false则直接返回false不会往下检查；\n\n|| --- 或\n\t两个值中只要有一个true时就返回true，只有两个值均为false时才返回false，如果第一个值为true时直接返回true不会继续往下检查；\n    \n! --- 非\n\t对布尔值进行取反运算；\n    \t如果对非布尔值进行取反，则会将其转换为布尔值然后再取反；\n        可以利用对非布尔值去两次反，这样就可以实现将其他任意的数据类型进行布尔值的隐式转换；\n赋值运算符可以将符号右侧的值赋给符号左侧的变量；\n关系运行符通过关系运算符可以比较两个值之间ed大小关系；\n对于非数值使用关系运算符比较的情况：会将其转换成数字然后进行比较；\n\t如果比较的两侧都是字符串的时候，不会将其转换成数字比较，而是依次比较字符串中每一个字符的Unicode编码，一个一个字符进行比较，相比较的字符编码大，则该字符串就大，不会继续往下比较，若一个字符串是另一个字符串的前缀，则字符串长度长的大；\n编码在字符串中使用转义字符输入Unicode编码 --- \\u字符编码 -- \\u2620 ;\n在网页中使用Unicode编码是使用 &amp;#字符编码 编码需要转换成10进制；\n相等运算符使用 == 运算符来比较两侧的值是否相等；\n使用 != 运算符来比较两侧的值是否不相等；\n\n== 和 != 在比较不同的类型的值时，会自动将其转换成相同类型进行转换，之后再比较；\nconsole.log( null == 0); //输出false ；\nnull 比较特殊，比较运算符  >=   &lt;=   >   &lt; 会对其进行数据类型转换； 相等运算符 == != 不会对其进行数据类型转换。\n\nundefined衍生自 null ，所以这两个值做相等判断时，返回true；\nconsole.log( undefined == null );  //返回true；\n\nNaN不和任何值相等 ， 包括它本身；\nconsole.log( NaN == NaN );   //返回 false；\n要判断 变量的值是否为 NaN，可使用 isNaN() 函数；\nconsole.log(isNaN(NaN));  //返回 true；\n\n使用 === 和 !== 来判断两侧的值是否相等，但是它不会进行类型转换，若比较的数据两者类型不同，则直接判断为不相等；\n条件运算符（三元运算符）语法：  条件表达式?语句1:语句2;\n\t先执行条件表达式，若表达式值为true，则执行语句1，否则执行语句2；\n    如果条件表达式执行后值不是布尔值，会将其转换成布尔值后再执行后面的语句；\n   var a = 1;\n\tvar b = \"hello\";\n    a > b ? alert(\"a大\") : alert(\"b大\");  //执行语句2；\n运算符的优先级\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"JS-数据类型与转换","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/16/JS-数据类型与转换/","content":"Hello WorldJavaScript中常用的信息输出方法：\n\t1. alert(\"这是一条提示语句！\");   ---- 该方法在执行时将在浏览器弹出一个提示框；\n\n\t2.console.log(\"这是一条提示语句！\");  ---- 该方法在执行时将在浏览器的控制台输出信息；\n\n\t3.document.write(\"这是一条插入body标签的信息\"); ---- 该方法在执行的时候将在网页的body标签中输出信息；\n\t\t\t该方法默认将信息插入到body标签的开头；\nJavaScript编写原则1. 内部代码 ---- JavaScript代码要求写在&lt;script>&lt;/script>标签体内；\n\n2. 外部代码 ---- 将JS代码写在其他的js文件中，之后通过&lt;script src=\"../index.js\">&lt;/script>引入外部js文件；\n\t用于引入外部js文件的script标签体内书写的代码不再进行解析；\n   \n3. 简单业务可直接写在html的标签中，但是耦合性太高，日常开发不推荐使用；--- 在按钮与超链接中的使用：\n\t\t&lt;button onclick=\"alert(\"我是点击按钮的提示信息！\")\">按钮&lt;/button>\n\t\t&lt;a href=\"javascript: alert(\"点击超链接的提示信息！\")\">我是一个超链接&lt;/a>\n\n4. JS代码中严格区分大小写；\n\n5. JS中每一条语句结束使用 ; 结尾，若未使用时浏览器在解析时会自动添加上，但这会消耗一定的浏览器性能。而且自动添加时可能会添加错地方；\n\n6. JS中会忽略多个空格和换行；\n变量与标识符字面量 --- 不可改变的值 如 1,2，3 ....  字面量是可以直接使用的，但在实际开发中我们不会直接使用字面量；\n\n变量 --- 变量可以用来保存字面量，而且变量的值是可以随便改变的，更加方便使用，可以使用变量对字面量进行描述；\n\n\t\t声明变量 --- var a;  &#x2F;&#x2F; 声明了一个名字为 a 的变量；\n\t\t变量赋值 --- a &#x3D; 123; &#x2F;&#x2F; 将变量 a 的值设置为 123 --- number类型；\n\t\t声明变量并赋值 --- var b &#x3D; 123; &#x2F;&#x2F; 声明一个变量名为 b 并直接赋值为 123 --- number类型；\n\n标识符 --- JS中所有可以自主命名的都称为标识符（为方便开发给变量取得名字）\n\t\t\t变量名 函数名 属性名 都属于标识符；\n            命名标识符是需要遵循的规则：\n            \t（1）标识符中可以含有字母，数字，_ ,$;\n\t\t\t\t(2)标识符不能以数字开头；\n                  (3)标识符不能是ES中关键字或者是保留字；\n                （4）标识符一般采用驼峰命名法 --- 首字母小写，其余单词的仅首字母大写；\n\t\tJS底层中保存标识符实际采用Unicode编码，所以理论上使用中文命名变量也是可行的，但是不推荐使用；\n基本数据类型JS中共有6中数据类型： String，Number，Boolean，Undefined， NULL，Object；\n\t其中前五种属于基本数据类型；\n    Object属于引用数据类型；\n    \n    1.String --- 字符串\n\t\t使用引号引起来的数据，可以使用单引号或者双引号，但是不能两者混合使用（一边单引号一边双引号）；\n        在字符串中使用 \\  作为转义字符\n        \t\\&#39;表示 &#39; , \\&quot; 表示 &quot; , \\n 表示换行， \\t 制表符(Tab缩进) \n     \n    2.Number --- 数值（整数，浮点数）\n\t\tNumber.MAX_VALUE --- 表示Number类型能表示ed最大值；\n\t\tNumber.MIN_VALUE --- 表示Number能表示的大于0的最小正数\n\t\tInfinity --- 表示正无穷；\n\t\t-Infinity --- 表示负无穷；\n\t\tNaN --- 一个特殊的数值 ---Not a Number\n        \n可以使用 运算符 typeof 来检查变量的数据类型 ---- typeof NaN 返回 number；\n\t若使用两个字符串进行相乘时，返回的是一个NaN\n    \t如：var a &#x3D; &quot;abc&quot; * &quot;def&quot;  -- 此时 console.log(a) 控制台打印NaN\n        \n        JS中整数的运算基本可以保证精确度（不溢出的话），但是浮点数的计算不能保证很高的精确度（因为所有的数值在计算中计算时都会转换成二进制进行计算，但是有些小数使用二进制是永远不能精确表示的 例如 0.1 就不能使用二进制精确表示）\n\n      3.Boolean --- 布尔值\n\t\t\t布尔值只有 true 和false 两个值，true -- 真，false -- 假\n        \n       4.NULL --- 空值\n\t\t\tNULL类型只有一个值 --- null --- 表示一个空的对象\n\t\t\t使用 typeof null --- 返回 object 原因如下：\n    1995年JavaScript语言的第一版，所有值都设计成32位，其中最低的3位用来表述数据类型，object对应的值是000。当时，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值）,完全没考虑null，只把它当作object的一种特殊值，32位全部为0。 这是typeof null返回object的根本原因。\n               \n       5.Undefined -- 未定义\n       \t\t该类型只有一个 --- undefined ；\n            使用 typeod undefined -- 返回undefined\n强制类型转换强制类型转换 --- 指将一个数据类型强制转换为其他的数据类型，这里主要讲String，Number，Boolean三种基本数据类型的转换；\n转换成String类型方法一：调用基本数据类型的toString()方法，该方法将返回一个string类型的结果，不影响原变量；\n\tNumber类型：  var a &#x3D; 123;\n\t\t\t\tvar b &#x3D; a.toString();\n\t\t\t\tconsole.log(b);\n\t\t\t\tconsole.log(typeof b);\n\t\t\t控制台输出字符串 &quot;123&quot; 类型为string；\n            \n     Boolean类型： var a &#x3D; true;\n\t\t\t\tvar b &#x3D; a.toString();\n\t\t\t\tconsole.log(b);\n\t\t\t\tconsole.log(typeof b);\n\t\t\t控制台输出字符串 &quot;true&quot; 类型为string；\n            \n      null和undefined这两个基本数据类型身上没有 toString() 方法，调用将导致报错；\n      \n方法二：调用String() 方法，并将需要转换的的数据作为参数传入；\n\t\tString()传入Number，Boolean这两个基本数据类型是，其实就是调用这两者身上的toString()方法；\n        \n        String()传入null和undefined时，直接返回字符串 &quot;null&quot; &quot;undefined&quot;\n\t\t\tvar a &#x3D; null;\n\t\t\tvar b &#x3D; String(a);\n\t\t\tconsole.log(b);\n\t\t\tconsole.log(typeof b);\n\t\t控制台输出 字符串 :&quot;null&quot; 和 string\n转换成Number类型方法一：使用Number函数 --- 将要转换的数据传入\n\t\tString类型： 如果是纯数字的字符串，则转换结果是数字\n        \t\t\t如果字符串中包含其他非数字内容，转换结果是NaN\n                    如果字符串是一个空串或者是全是空格的字符串，转换结果是 0 \n\t\tvar a &#x3D; &quot;123&quot;;\n\t\ta &#x3D; Number(a);\n\t\tconsole.log(a);\n\t\tconsole.log(typeof a);\n\t控制台输出 数值 123, 为number类型；\n\n\t\tvar a &#x3D; &quot;123sddfe&quot;;\n        a &#x3D; Number(a);\n\t\tconsole.log(a);\n\t\tconsole.log(typeof a);\n\t控制台输出 NaN ，为number类型；\n    \n    \tvar a &#x3D; &#39;&#39;;\n\t\ta &#x3D; Number(a);\n\t\tconsole.log(a);\n\t\tconsole.log(typeod a);\n\t控制台输出 数值 0，为number类型；\n    \n方法二：parseInt() --- 把一个字符串转换为一个整数；\n\t\tparseFloat() --- 把一个字符串转换为一个浮点数；\n\n\t\tparseInt() ,parseFloat() 方法均是在遇到字母时停止转换，返回一个NaN值\n        \n        var a &#x3D; &quot;123dfhgdsh&quot;;\n\t\ta &#x3D; parseInt(a);\n\t\tconsole.log(a);\n\t控制台输出 数值 123；\n    \t\n    \tvar a &#x3D; &quot;d2323bsdhfgb&quot;\n        a &#x3D; parseInt(a);\n\t\tconsole.log(a);\n\t控制台输出 NaN --parseInt()在执行时依次解析每一个字符，一旦遇到非数字以外的字符将停止继续解析，解析后若没有数值将返回NaN值；\n    \n    parseFloat() --- 解析时遇到第一次小数点时不会停止解析，若遇到数数字和小数点外的字符则停止解析，或者是第二次遇到小数点就停止解析，若解析后没有数值则返回NaN；\n\n\t\tvar a &#x3D;&quot;.41564efdwe&quot;\n        a &#x3D; parseFloat(a);\n\t\tconsole.log(a);\n\t控制台输出浮点数 0.41564；\n    \n    \tvar a &#x3D; &quot;..4234sfdf32423&quot;\n        a &#x3D; parseFloat(a);\n\t\tconsole.log(a);\n\t控制点输出 NaN ；\n    \n    \n    如果parseInt()和parseFloat()中穿入的是非字符串是，它会将传入的参数先转换成字符串之后转进行转换成number类型；\n\t\t\n转换成Boolean类型使用Boolean()方法将其他的数据类型转换成Boolean类型；\n\t\t数字 ---&gt; Boolean  ， 除了 0 和 NaN ，其他数据都是转换成true；\n        字符串 ---&gt; Boolean ， 除了 空串，其他的字符串都是转换成true；\n        null 和 undefined 都会转换成 false；\n        object 数据类型也会转换成true；\n其他进制的数字在js中，16进制数字需要以0x开头，8进制数字以0开头，2进制数字需要以0b开头；\n​        可以在parseInt()中传递第二个参数，用来指定数字的进制\n​        var a = parseInt(0xff,16);\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"媒体查询","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/15/媒体查询/","content":"响应式布局响应式布局 --- 网页根据浏览设备会窗口的大小呈现出不同的效果\n\t\t使用响应式布局是一个页面适用于所有设备\n\t\t通过媒体查询 -- 可以为不同的设备，或者设备的不同状态来分别设置样式\n媒体查询语法： @media 查询规则&#123;&#125;\n\t\t媒体类型：all -- 所有设备\n\t\t\t\tprint -- 打印设备（只有页面在打印时样式才呈现出来）\n\t\t\t\tscreen -- 带屏幕的设备\n\t\t\t\tspeech -- 屏幕阅读器\n\t\t可以使用 , 连接多个媒体类型 表示一个 或 的关系\n\t也可以在媒体类型前添加一个 only 表示只有 （为了兼容一些老版本浏览器）\n\n\t\t媒体特性：width -- 视口宽度\n\t\t\t\theight -- 视口高度\n\t\t\t\tmin-width -- 视口的最小宽度（当视口的宽度大于这个宽度时生效）\n\t\t\t\tmax-width -- 视口的最大宽度（当视口的宽度小于这个宽度时生效）\n\n\t\t断点 --- 样式切换到额分界点 --- 网页样式发生变化的点\n\t\t常用断点：\n\t\t\t\t小于768 -- 超小屏幕 -- max-width = 768px\n\t\t\t\t大于768 -- 小屏幕 -- min-width = 768px\n\t\t\t\t大于992 -- 中型屏幕 -- min-width = 992px\n\t\t\t\t大于1200 -- 大屏幕 -- min-width = 1200px\n\n&lt;style>\n @media only screen and (min-width: 500px) and (max-width:700px)&#123;\n     /*\n     \t当视口的宽度大于500px且视口的宽度小于700px时 body的样式如下：\n     */\n             body&#123;\n                background-color: #bfa;\n             &#125;\n         &#125;\n  &lt;/style>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"像素-视口-移动端","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/14/移动端/","content":"像素前端开发中像素分成两种，CSS像素和物理像素；\n\n\t物理像素 --- 屏幕中一个个的发光小点，分辨率就是指横向和纵向上屏幕的发光小点个数；\n\n\tCSS像素 --- 在编写网页时，我们使用的就是CSS像素，浏览器在解析网页时需要把CSS像素转换成物理像素来显示；\n\t\t一个CSS像素最终由几个物理像素显示由浏览器决定：\n\t\t\t默认情况下PC端网页的一个CSS像素等于一个物理像素；\n视口（viewport）视口 --- 屏幕中用来显示网页的区域\n\t\t可以通过查看视口的大小来确定CSS像素和物理像素的比值；\n\n\t默认情况下，在不同的屏幕中，单位像素是不同的，像素越小屏幕会越清晰；\n移动端移动端默认的视口大小是980px（CSS像素），默认情况是移动端的像素比是 980/（移动设备宽度）\n\t在编写移动页面时，要确保有一个比较合理的像素比：\n\t\t设备像素比：一个设备的物理像素与逻辑像素之比\n\t\t2个物理像素 ：1css像素 或者  3个物理像素 ：1css像素 \n\n可以通过设置meta标签来设置视口大小，每一款移动设备在设计时都会有一个最佳的像素比 ---- 完美视口\n\n将网页的视口设置为完美视口，写入如下代码：\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\twidth：该属性被用来控制视窗的宽度，可以将width设置为320这样确切的像素数，也可以设为device-width这样的关键字，表示设备的实际宽度，一般为了自适应布局，普遍的做法是将width设置为device-width。\n\n\theight：该属性被用来控制视窗的高度，可以将height设置为640这样确切的像素数，也可以设为device-height这样的关键字，表示设备的实际高度，一般不会设置视窗的高度，这样内容超出的话采用滚动方式浏览。\n\n\tinitial-scale：该属性用于指定页面的初始缩放比例，可以配置0.0～10的数字，initial-scale=1表示不进行缩放，视窗刚好等于理想视窗，当大于1时表示将视窗进行放大，小于1时表示缩小。这里只表示初始视窗缩放值，用户也可以自己进行缩放，例如双指拖动手势缩放或者双击手势放大。\n\n\tmaximum-scale：该属性表示用户能够手动放大的最大比例，可以配置0.0～10的数字。\n\n\tminimum-scale：该属性类似maximum-scale，用来指定页面缩小的最小比例。通常情况下，不会定义该属性的值，页面太小将难以浏览。\n\n\tuser-scalable：该属性表示是否允许用户手动进行缩放，可配置no或者yes。当配置成no时，用户将不能通过手势操作的方式对页面进行缩放。\nvw适配不同设备的完美视口大小不一样，不同设备视口和像素比不同，所以同样的375个像素在不同设备下意义不同；\n\n所以在移动端开发时，不能再使用px来进行布局；\n\n移动端开发使用 vw -- 视口宽度（viewport width）来进行布局；\n\t100vw = 一个视口的宽度\n\t1 vw = 1% 视口宽度\n\tvw 永远相对于视口宽度进行计算\n\n设计图的宽度一般都为 750px 或者 1125px （因为早期iPhone6的宽度为375px，所以一般会让CSS像素是设备像素的2到3倍）\n\n现在大部分移动web页面采用更加完善的rem或者vw加flex的方案来进行适配。\n\n\tRem适配方案是当下流行并且兼容性最好的移动端适配解决方案，它支持大部分的移动端系统和机型，Rem实际上是一个字体单位，即rem（font size of the root element）是指相对于根元素的字体大小的单位，简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 所以Rem适配方案的适配原理就是：将我们之前写px的单位换成rem单位，然后根据屏幕大小动态设置根元素&lt;html>的font-size大小，那么只要跟元素的font-size改变，对应的元素的大小就会改变，从而达到在不同屏幕下的适配的目的。\n    \n           html&#123;\n            /* \n                网页中字体大小最小是12px，不能设置一个比12像素还小的字体\n                    如果我们设置了一个小于12px的字体，则字体自动设置为12px\n\t\t\t\t\n        \t\t这里以设计图宽度为750px为例，则此时有100vw = 750px；\n        \t\t换算：\n                0.1333333vw = 1px\n\n                5.3333vw = 40px  将根元素里的rem增大40倍\n      \n            */\n            font-size: 5.3333vw;\n        \t这里设置根元素的字体大小为 5.3333vw ，也就是 40px ；后续布局中使用的1rem也就等于40px；\n        \t所以后续使用rem布局时，元素的宽度需要除于40 才能得到正确的布局比例vw --- 1rem/40 = 1px；\n        &#125;\n\n        \n参考文章：https://zhuanlan.zhihu.com/p/114562780\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"flex布局","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/14/flex布局/","content":"弹性盒&lt;html>\n&lt;style>\n/*\nFlex --- 弹性盒、伸缩盒\n\t\t- CSS中的一种布局手段 用来代替浮动来完成页面布局\n\t\t- flex 可以使元素具有弹性，让元素可以跟随页面的大小的改变而改变\n\t\t- 弹性容器\n\t\t\t- 要使用弹性盒，必须先将一个元素设置为弹性容器\n\t\t\t- 通过 display ： flex 设置块级弹性容器\n\t\t\t- display：inline-flex 设置为行内的弹性容器\n\t\t- 弹性元素\n\t\t\t- 弹性容器的子元素是弹性元素（弹性项）\n\t\t\t- 弹性元素可以同时是弹性容器\n    &lt;/style>\n    &lt;/html>\n弹性容器的属性&lt;htmL>\n    &lt;style>\n        \n  flex-direction 指定容器中弹性元素的排列方式\n                可选值：\n                    row 默认值，弹性元素在容器中水平排列（左向右）\n                        - 主轴 自左向右\n                    row-reverse 弹性元素在容器中反向水平排列（右向左）\n                        - 主轴 自右向左\n                    column 弹性元素纵向排列（自上向下）\n                    column-reverse 弹性元素方向纵向排列（自下向上）\n\n主轴：弹性元素的排列方向称为主轴\n侧轴：与主轴垂直方向的称为侧轴\n        \n        flex-wrap: \n                设置弹性元素是否在弹性容器中自动换行\n                可选值：\n                    nowrap 默认值，元素不会自动换行\n                    wrap 元素沿着辅轴方向自动换行\n                    wrap-reverse 元素沿着辅轴反方向换行\n     /* flex-flow:  wrap 和 direction 的简写属性 */\n            /* flex-flow: row wrap; */\n    \n    justify-content\n                    - 设置浏览器如何沿着主轴上的弹性元素之间和周围分配空间\n                    - 可选值：\n                        flex-start 元素沿着主轴起边排列\n                        flex-end 元素沿着主轴终边排列\n                        center 元素居中排列\n                        space-around 空白分布到元素两侧\n                        space-between 空白均匀分布到元素间\n                        space-evenly 空白分布到元素的单侧\n    \n    \n/* Positional alignment */\njustify-content: center;     /* 居中排列 */\njustify-content: start;      /* Pack items from the start */\njustify-content: end;        /* Pack items from the end */\njustify-content: flex-start; /* 从行首起始位置开始排列 */\njustify-content: flex-end;   /* 从行尾位置开始排列 */\njustify-content: left;       /* Pack items from the left */\njustify-content: right;      /* Pack items from the right */\n\n/* Baseline alignment */\njustify-content: baseline;\njustify-content: first baseline;\njustify-content: last baseline;\n\n/* Distributed alignment */\njustify-content: space-between;  /* 均匀排列每个元素\n                                   首个元素放置于起点，末尾元素放置于终点 */\njustify-content: space-around;  /* 均匀排列每个元素\n                                   每个元素周围分配相同的空间 */\njustify-content: space-evenly;  /* 均匀排列每个元素\n                                   每个元素之间的间隔相等 */\njustify-content: stretch;       /* 均匀排列每个元素\n                                   'auto'-sized 的元素会被拉伸以适应容器的大小 */\n\n/* Overflow alignment */\njustify-content: safe center;\njustify-content: unsafe center;\n\n/* Global values */\njustify-content: inherit;\njustify-content: initial;\njustify-content: unset;\n        \n    ul&#123;\n            width: 800px;\n            height: 200px;\n            border: 10px solid red;\n            display: flex;\n            text-align: center;\n            flex-wrap: nowrap;\n            /* 2.设置弹性元素不在弹性容器中自动换行 \n            当弹性容器的宽度不足时且弹性元素的伸缩系数均设置为0时\n                此时弹性元素的宽度会溢出弹性容器\n            */\n            flex-wrap: wrap;\n            /* 3.设置弹性容器的中弹性元素自动换行 弹性容器的宽度不足时\n                弹性元素会在弹性容器中换行 沿辅轴方向（此时主轴方向为水平自左向右 则辅轴方向为自上向下）\n            */\n            flex-wrap: wrap-reverse;\n            /* 4.设置弹性容器的中的弹性元素沿辅轴反方向自动换行 （自下向上）*/\n            justify-content: flex-start;\n            /* 5.设置弹性容器分配主轴上的空白空间 --- flex-start 弹性元素沿主轴起边排列 */\n            justify-content: flex-end;\n            /* 6.弹性元素沿主轴的终边摆列 -- 只影响有空白空间的元素 不影响已沾满一行的弹性元素 */\n            justify-content: center;\n            /* 弹性元素在空白中居中排列 */\n            justify-content: space-around;\n            /* 空白分布到弹性元素的两侧 两弹性元素间的间隔和弹性元素距离边框的距离不一定相等*/\n            justify-content: space-between;\n            /* 空白均匀分布到弹性元素的间隔中 弹性元素与边框间不分布空白*/\n            justify-content: space-evenly;\n            /* 空白均匀分到弹性元素间的两侧 弹性元素间和弹性元素到边框的距离相等 */\n        &#125;\n        ul li:nth-child(odd)&#123;\n            background-color: #bfa;\n            width: 300px;\n            height: 50px;\n        &#125;\n        ul li:nth-child(even)&#123;\n            background-color: skyblue;\n            flex-shrink: 0;\n             /* 1.此时增大奇数项的宽度 且让其的收缩系数变为0 即不让其缩小 */   \n            height: 50px;\n            width: 200px;\n        &#125;\n        \n        \n       align-content : 设置了浏览器如何沿着弹性布局的辅轴在内容项之间和周围分配空间。\n\t\t\n/* 基本位置对齐 */\n/*align-content不采用左右值 */\nalign-content: center;     /* 将项目放置在中点 */\nalign-content: start;      /* 最先放置项目 */\nalign-content: end;        /* 最后放置项目 */\nalign-content: flex-start; /* 从起始点开始放置flex元素 */\nalign-content: flex-end;   /* 从终止点开始放置flex元素 */\n\n/* 默认对齐 */\nalign-content: normal;\n\n/*基线对齐*/\nalign-content: baseline;\nalign-content: first baseline;\nalign-content: last baseline;\n\n/* 分布式对齐 */\nalign-content: space-between; /* 均匀分布项目\n                                 第一项与起始点齐平，\n                                 最后一项与终止点齐平 */\nalign-content: space-around;  /* 均匀分布项目\n                                 项目在两端有一半大小的空间*/\nalign-content: space-evenly;  /* 均匀分布项目\n                                 项目周围有相等的空间 */\nalign-content: stretch;       /* 均匀分布项目\n                                 拉伸‘自动’-大小的项目以充满容器 */\n\n/* 溢出对齐 */\nalign-content: safe center;\nalign-content: unsafe center;\n\n/* 全局属性 */\nalign-content: inherit; /* 继承 */\nalign-content: initial;  /* 初始值 */\nalign-content: unset; /* 未设置 */\n\n    &lt;/style>\n&lt;/htmL>\n弹性元素的属性&lt;html>\n    &lt;style>\n    弹性元素的属性：\n                    flex-grow 指定弹性元素的伸展的系数 默认值为0\n                    - 当父元素有多余空间的时，子元素如何伸展\n                    - 父元素的剩余空间，会按照比例进行分配\n                    flex-shrink 指定弹性元素的收缩系数 默认值为1\n                    - 当父元素中的空间不足以容纳所有的子元素时，如果对子元素进行收缩\n    \n     ul&#123;\n            width: 600px;\n            height: 100px;\n            border: 10px red solid;\n            text-align: center;\n            /* 此时ul的高度由内容撑开 */\n            /* 1.给元素开启fles布局 */\n            display: flex;\n            /* 2.ul一开启弹性布局 它里面的子元素都变成弹性元素 此时li在ul里横向排列 */\n            flex-direction: row;\n            /* 3.设置弹性元素的排列方式 flex-direction : row ---默认值 横向排列；自左向右 */\n            flex-direction: column;\n            /* 4.将弹性元素的排列方式改为纵向排列 自上向下 */\n            flex-direction: row-reverse;\n            /* 5.将弹性元素的排列方式改为反向的横向排列 此时主轴方向为水平自右向左 */\n            flex-direction: column-reverse;\n            /* 6.将弹性元素的排列方式改为反向的纵向排列 此时主轴方向为垂直自下向上 */\n            flex-direction: row;\n        &#125;\n        ul li:nth-child(odd)&#123;\n            background-color: #bfa;\n            width: 200px;\n            flex-grow: 1;\n            /* 7.设置奇数项的li的弹性伸展系数 -- 此时若将ul的高度变高 \n                父元素高度变高后 多出来的空白区域将均分成2份 有第1个和第3个li伸展\n            */\n            /* 9.将父元素的宽度调小后 子元素的宽度将自动调整\n                父元素的不够的宽度将由里面的所有子元素共同承担 -- 即若父元素宽度变小200px 则此时父元素里的4个子元素各自减少50px\n                (前提是每个子元素都没有单独设置收缩系数 flex-shrink)\n            */\n            flex-shrink: 2;\n            /* 10.给奇数项设置弹性系数为2 则此时200px均分成6份 奇数项li缩小 200px*(1/3) = 133.33px */\n        &#125;\n        ul li:nth-child(even)&#123;\n            background-color: skyblue;\n            width: 200px;\n            /* 此时元素在ul中纵向排列 */\n            flex-grow: 2;\n            /* 8.此时将偶数项的li弹性伸展系数设置为2 则之前的空白将均分成6份 此时偶数项li各占2份，奇数项li各占1份 */\n            /* flex-shrink: 1; */\n        &#125;\n        \n        align-items: \n                - 元素在辅轴上如何对齐\n                - 元素间的关系\n                    - 可选值：\n                        stretch 默认值，将元素的长度设置为相同的值\n                        flex-start 元素不会拉伸，沿着辅轴起边对齐\n                        flex-end 沿着辅轴的终边对齐\n                        center 居中对齐\n                        baseline 基线对齐\n        \n        \n/* Basic keywords */\nalign-items: normal;\nalign-items: stretch;\n\n/* Positional alignment */\nalign-items: center; /* Pack items around the center */\nalign-items: start; /* Pack items from the start */\nalign-items: end; /* Pack items from the end */\nalign-items: flex-start; /* Pack flex items from the start */\nalign-items: flex-end; /* Pack flex items from the end */\nalign-items: self-start;\nalign-items: self-end;\n\n/* Baseline alignment */\nalign-items: baseline;\nalign-items: first baseline;\nalign-items: last baseline; /* Overflow alignment (for positional alignment only) */\nalign-items: safe center;\nalign-items: unsafe center;\n\n/* Global values */\nalign-items: inherit;\nalign-items: initial;\nalign-items: unset;\n        \n        ul&#123;\n            width: 600px;\n            height: 900px;\n            border: 10px red solid;\n            display: flex;\n            /* 设置ul开启弹性布局 */\n            flex-flow: row wrap;\n            /* 设置ul开启横向排列 且自动换行 （自动换行要生效需要把li的收缩属性关闭） */\n            align-items: stretch;\n            /* 设置弹性元素在辅轴上的长度相同 --- 指在同一主轴上的元素 其高度一致 默认值*/\n            align-items: flex-start;\n            /* 设置弹性元素不会拉伸 高度由其自身决定 弹性元素对着辅轴起边对齐 */\n            align-items: flex-end;\n             /* 设置弹性元素不会拉伸 高度由其自身决定 弹性元素对着辅轴终边对齐 */\n             align-items: center;\n              /* 设置弹性元素不会拉伸 高度由其自身决定 弹性元素对着辅轴居中对齐 */\n              align-items: baseline;\n        &#125;\n\n        li&#123;\n            width: 200px;\n            background-color: #bfa;\n            font-size: 50px;\n            text-align: center;\n            line-height: 100px;\n            flex-shrink: 0;            \n        &#125;\n        li:nth-child(1)&#123;\n            /* align-self: 用来覆盖当前弹性元素上的align-items */\n            /* align-self: stretch; */\n        &#125;\n\n        li:nth-child(2)&#123;\n            background-color: pink;\n        &#125;\n\n        li:nth-child(3)&#123;\n            background-color: orange;\n        &#125;\n\n        li:nth-child(4)&#123;\n            background-color: yellow;\n        &#125;\n\n        li:nth-child(5)&#123;\n            background-color: chocolate;\n        &#125;\n        \n        \n        元素基础长度\n\n                flex-basis 指定的是元素在主轴上的基础长度\n                    如果主轴是 横向的 则 该值指定的就是元素的宽度\n                    如果主轴是 纵向的 则 该值指定的是就是元素的高度\n                    - 默认值是 auto，表示参考元素自身的高度或宽度\n                    - 如果传递了一个具体的数值，则以该值为准\n        \n        \n         ul&#123;\n            width: 900px;\n            border: 10px red solid;\n            /* 设置弹性盒 */\n            display: flex;\n            flex-direction: column;\n        \n        &#125;\n\n        li&#123;\n            width: 200px;\n            height: 100px;\n            background-color: #bfa;\n            font-size: 50px;\n            text-align: center;\n            line-height: 100px;\n            /* flex: initial; */\n            flex-basis: 300px;\n        &#125;\n        li:nth-child(1)&#123;\n            /* order 决定弹性元素的排列顺序 */\n            order: 2;\n        &#125;\n\n        li:nth-child(2)&#123;\n            background-color: pink;\n            /* flex-grow: 2; */\n            order: 3;\n        &#125;\n\n        li:nth-child(3)&#123;\n            background-color: orange;\n            /* flex-grow: 3; */\n            order: 1;\n        &#125;\n    &lt;/style>\n&lt;/html>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"less基础语法","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/13/less基础语法/","content":"less介绍/*\n\tless 是一门 css的预处理语言\n\t\t可以看成是css的增强版 用法基本和css一致 在此基础上扩展了一些功能\n\t\t浏览器并不能直接解析less语法 需要使用插件将写好的less文件转换为css文件\n*/\nCSS原生变量与计算函数&lt;style>\n\t html&#123;\n            /* css原生也支持变量的设置 */\n            /* 设置颜色变量和长度变量 \n                语法 --变量名 在使用时需要使用var(--变量名)读取\n            */\n            --color:#ff0;\n            --length:200px;\n        &#125;\n\n        .box1&#123;\n            /* calc()计算函数 --- calculation\n            \t在函数中可以直接输入计算表达式\n            直接输入表达式时 符号与数值之间使用空格间隔开\n            */\n            width: calc(200px*2);\n            height: var(--length);\n            background-color: var(--color);\n        &#125;\n\n        .box2&#123;\n            width: var(--length);\n            height: var(--length);\n            color: var(--color);\n        &#125;\n\n        .box3&#123;\n            width: var(--length);\n            height: var(--length);\n            border: 10px solid var(--color);\n        &#125;\n&lt;/style>\nless基本语法在less文件中可以使用 @import \"XXX.less\" 来引入其他的less文件\n\t在less中所有的数值都可以直接进行计算 + - * /\n    \t在使用除法时 需要使用()将除法的运算表达式包括起来\n 在less 文件中 可使用 // 符号进行行注释 也可以使用 /* */ 符号进行块注释\n    但是使用 // 符号的单行注释不会被解析到 css 文件中，但是 块注释符号会被解析到 css 文件中\n \n    在less文件中父子元素的样式可以直接嵌套写在一起\n    \n    .box1&#123;\n    background-color: #bfa;\n\n    .box2&#123;\n        background-color: #ff0;\n\n        .box4&#123;\n            color: red;\n        &#125;\n    &#125;\n\n    .box3&#123;\n        background-color: orange;\n    &#125;\n        \n        // 这段代码解析成css文件时，可知box1有3个孩子 box2 box3 ，而box2 也有一个孩子 box4 ；\n&#125;\n\nless中的变量 --- 在变量中可以存储一个任意的值；\n\t并且可以在需要的时候任意修改其中的值；\n\t语法： @变量名\n// 定义一个变量名为 a ,值为 200px 的变量；\n\t@a:200px;\n几乎所有数值都可以使用变量表示，类名也可以使用变量来表示：\n// 定义一个类变量，要表示的类名为 box\n\t@c: box;\n\n读取变量值：\n\t当直接使用则以 @变量名 的形式使用即可 --- width : @a;\n当变量作为类名使用时或者变量的值只是作为一部分使用时必须以 @&#123;变量名&#125; 的形式使用\n.@&#123;c&#125;&#123;\n    width: @a;\n&#125;\n\n当变量发生重名时，优先使用比较近的重名变量；\n\n可以先使用变量再定义变量，但不推荐这样使用；\n\nless 4.0 新语法：变量引用\n.widget &#123;\n  color: #efefef;\n  background-color: $color;\n&#125;\n编译成CSS文件后：\n.widget &#123;\n  color: #efefef;\n  background-color: #efefef;\n    //在这里使用 $color 引用之前定义的color的值；\n&#125;\n\n父元素选择器：使用 &amp; 符号选择当前元素的父元素；\n.demo&#123;\n    width: 200px;\n    height: 200px;\n\n    .demo1&#123;\n        width: 100px;\n        height: 100px;\n        background-color: #bfa;\n        &amp;:hover&#123;\n            height: 300px;\n            // 此时 &amp; 在类demo1中 所以使用 &amp; 父元素选择器选中的是类demo1\n        &#125;\n    &#125;\n\n    &amp;:hover&#123;\n        width: 300px;\n        //在这里使用 &amp; ，此时 &amp; 是demo类的直系儿子 所以此时 &amp; 选中的是 demo类\n    &#125;\n&#125;\n// 可知 &amp; 选中的是使用该符号虽在层的父元素 ， 而不是祖先元素；\n\n:extend() 对当前选择器扩展指定选择器的样式 --- 样式扩展\n\n.p1&#123;\n    width: 200px;\n    height: 200px;\n&#125;\n.p2:extend(.p1)&#123;\n    color:red;\n&#125;\n\n编译后的css代码：\n.p2:&#123;\n    width:200px;\n    height:200px;\n    color:red;\n    // 也就是说使用:extend(要扩展的类) --- 效果是在选中的需要的扩展类基础上进行样式的添加，可以看成是类p2在继承类p1的基础上添加新的样式；\n&#125;\n\n.p3&#123;\n    .p1();\n    color:red;\n    //这里是直接对指定的样式进行引用，这里就相当于将类p1的样式在这里进行了复制\n    // 此时类p3 的样式和类p2 一致\n&#125;\n\n\nmixin混合：在使用类选择器的使用在类名后面添加一个()，此时我们就相当于添加了一个mixin混合\n\tmixin混合类在解析时不会被单独解析成一个类，而是在引用该mixin混合类的类类上直接添加mixin类的属性；\n\n.p4()&#123;\n    width: 100px;\n    height: 100px;\n&#125;\n\n.p5&#123;\n    .p4;\n    //这里的引用p4类可以添加括号也可以不添加；效果一致\n&#125;\n\n编译成CSS代码后：\ncss文件中不会单独存在p4类\n.p5 &#123;\n  width: 100px;\n  height: 100px\n&#125;\n\n带参数的混合函数：\n.test(@W:100px,@h:200px,@bg-color:red)&#123;\n    width:@w;\n    height:@h;\n    border:1px solid @bg-color;\n    //此时设置了一个可以传入三个参数的test混合类，传入参数时未声明时需要按照顺序传入参数\n    //若未传入参数则使用默认值；\n    //注意该混合类在解析成css时也不会单独存在；\n&#125;\n.p6&#123;\n    .test(200px,300px,#bfa);\n    //此时p6类引用test混合类，并依次传入三个参数 三个值将依次对应width height color；\n    .test(300px)\n    //此时只传入一个参数 对应width 其他两个参数使用默认值；\n    .test(@bg-color:red,@h:100px,@w:200px);\n    //此时指定混合函数传入的三个参数，依次对应color，height，width 此时不用按照顺序传入参数也可；\n&#125;\n\naverage() ---- 颜色平均函数 该函数用来求输入的两个颜色数值的平均数\nspan&#123;\n    color: average(red,blue);\n&#125;\n编译成CSS代码后\nspan &#123;\n  color: #800080\n&#125;\n\ndarken() ---- 颜色深度改变函数 该函数用改变输入颜色的深浅\nbody:hover&#123;\n    background-color: darken(#bfa,50%);\n&#125;\n编译成CSS代码后\nbody:hover &#123;\n  background-color: #2a0\n&#125;","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"平移-旋转-缩放","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/12/平移-旋转-缩放/","content":"元素的变形包括平移，旋转，缩放；\n平移通过开启 transform 属性中的 translateX(),translateY(),translateZ() 开启元素的平移效果；\n\ttranslateX() --- 开启元素的水平平移；\n\ttranslateY() --- 开启元素的垂直平移；\n\ttranslateZ() --- 开启元素的视距方向的平移（需要设置网页视距 perspective）\n\t\n  .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 开启元素的水平平移 */\n            transform: translateX(50%) translateY(50%);\n            /* 可知元素的平移是以自身的大小为标准计算，按照当前元素在文档流中的位置进行平移，而且平移的元素不脱离文档流\n                也不影响其他元素 可以看成是提高了层级\n                元素若还有其他的平移 直接写在同一个transform 里面 使用空格将每一个平移计算隔开\n            */\n        &#125;\n\n     width: 300px;\n            height: 300px;\n            background-color: #bfa;\n            margin: 50px auto;\n            /* 开启元素的Z轴平移 */\n            transform: translateZ(200px);\n            /* 在html设置网页视距perspective无效 \n                需要在body标签设置perspective\n                perspective一般在800px 到 1200px间\n            */\n        &#125;\n旋转通过开启 transition 的rotateX() rotateY() rotateZ() 实现元素的 旋转效果；\n\trotateX() --- 水平旋转 （想象成网页平面上的元素围绕着水平线旋转 是空间上的旋转 body标签开启perspective属性后 立体效果比较明显）\n\trotateY() --- 垂直旋转 （想象成网页平面上的元素围绕着竖直线旋转）\n\trotateZ() --- 围绕Z轴旋转（因为Z轴是指向我们的脸，所以此时网页平面上的元素旋转为在网页上的平面旋转 相当于俯视视角 此时无立体效果）\n\n.demo&#123;\n            width: 320px;\n            height: 320px;\n            margin: 200px auto;\n            transition:  all 5s;\n        &#125;\n        .demo img&#123;\n            width: 320px;\n            height: 320px;\n        &#125;\n body:hover .demo&#123;\n\n            /*\n                通过旋转可以使元素沿着x y 或 z旋转指定的角度\n                    rotateX()\n                    rotateY()\n                    rotateZ()\n            */\n            /* transform: rotateZ(.25turn); */\n            /* transform: rotateY(180deg) translateZ(400px); */\n            /* transform: translateZ(400px) rotateY(180deg) ; */\n            transform: rotateX(1turn);\n            /* 是否显示元素的背面 */\n            /* backface-visibility: hidden; */\n        &#125;\n缩放通过开启 transition 中的 scaleX() scaleY() scale() 开启元素的缩放\n\tscaleX() --- 水平方向上的缩放；\n\tscaleY() --- 垂直方向上的缩放；\n\tscale() --- 双方向上的缩放；\n\n .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            display: inline-block;\n            /* margin: 20px auto; */\n        &#125;\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            display: inline-block;\n        &#125;\n        .demo:hover&#123;\n            transform: scaleX(120%);\n            /* 设置元素垂直方向上放大为自己的20% \n                可知此时元素的缩放不影响别的元素 也不脱离文档流\n            \t即此时的元素缩放不影响其他元素的所在文档流的位置\n            */\n        &#125;\n\n&lt;div class=\"demo\">&lt;/div>\n&lt;div class=\"demo1\">&lt;/div>\n\n transform-style: preserve-3d;\n            /* 只有开启transform-style 才能看出3D立体效果 */\n\n注意：在测试时发现 translateZ() 也就是在视距方向上平移时 值为%表示不生效；","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"过渡与动画","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/11/动画/","content":"过渡通过过渡指定一个属性发生变化时的切换方式；\n\ntransition-property : 属性指定要执行的过渡属性（大部分属性都支持过渡效果，注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡，若属性值是 auto 则过渡无法生效）;\n\ttransition-property : height,width,all; 多个属性值使用逗号隔开，all 关键字则指定所有可计算的属性；\n\ntransition-duration ： 指定过渡效果的持续时间 单位 ： s 和 ms ；\n\ntransition-timing-function ：过渡的时序函数 --- 指定过渡的执行速度方式；\n\t可选值：\n\t\tease 默认值 --- 慢速开始 先加速后再减速\n\t\tlinear 匀速运动\n\t\tease-in 加速运动\n\t\tease-out 减速运动\n\t\tease-in-out 先加速后减速\n\t\tcubic-bezier() 来指定时序函数  \n\t\tsteps() 分布执行过渡效果 --- 可以设置两个值（步数，end&#x2F;start）\n\t\t\tend --- 在时间结束时执行过渡（默认值）\n\t\t\tstart --- 在时间开始时执行过渡\n\t即使指定不一样的过渡时序函数执行时间都是按transition-duration指定\n\ntransition-delay ： 过渡效果的延迟，等待一段时间后再执行过渡，单位 ： s ms \n\n\n .demo&#123;\n           width: 700px;\n           height: 700px;\n           background-color: grey;\n           overflow: hidden;\n        &#125;\n        .demo1&#123;\n            width: 100px;\n            height: 100px;\n            background-color: #bfa;\n            &#x2F;* 设定demo1开始的位置 *&#x2F;\n            margin-left: 0;\n            &#x2F;* 设置demo1过渡的属性 --- margin-left *&#x2F;\n            transition-property: margin-left;\n            &#x2F;* 设置demo1的过渡持续效果 *&#x2F;\n            transition-duration: 2s;\n            &#x2F;* 设置demo1的过渡时序函数 --- 默认值*&#x2F;\n            transition-timing-function: ease;\n        &#125;\n        .demo:hover div&#123;\n            margin-left: 600px;\n        &#125;\n        .demo2&#123;\n            width: 100px;\n            height: 100px;\n            margin-top: 200px;\n            background-color: #bfa;\n            &#x2F;* 设定demo1开始的位置 *&#x2F;\n            margin-left: 0;\n            &#x2F;* 设置demo1过渡的属性 --- margin-left *&#x2F;\n            transition-property: margin-left;\n            &#x2F;* 设置demo1的过渡持续效果 *&#x2F;\n            transition-duration: 2s;\n            &#x2F;* 设置demo1的过渡时序函数 --- 使用曲线定义*&#x2F;\n            transition-timing-function: cubic-bezier(0,1.65,1,-0.77);\n            &#x2F;* 设置demo2延迟两秒再开始过渡 *&#x2F;\n            transition-delay: 2s;\n        &#125;\n        .demo3&#123;\n            width: 100px;\n            height: 100px;\n            margin-top: 200px;\n            background-color: #bfa;\n            &#x2F;* 设定demo1开始的位置 *&#x2F;\n            margin-left: 0;\n            &#x2F;* 设置demo1过渡的属性 --- margin-left *&#x2F;\n            transition-property: margin-left;\n            &#x2F;* 设置demo1的过渡持续效果 *&#x2F;\n            transition-duration: 2s;\n            &#x2F;* 设置demo1的过渡时序函数 --- steps*&#x2F;\n            transition-timing-function: steps(3,end);\n            &#x2F;* 指定过渡的时序为步骤的话 过渡效果会将整个默认过程均分为几个步骤 只展现那几步的状态\n            *&#x2F;\n        &#125;\n\ntransition 属性可以同时设置过渡的相关属性，只要求持续时间要写在延迟时间之前，其他属性顺序随便；\n动画动画：动画和过渡类似，都可实现一些动态的效果；\n\t两者不同的是过渡需要在某个属性发生变化时才触发执行，而动画可以自动触发执行；\n\nanimation-name : 要对当前元素生效的关键帧名字；\nanimation-duration ：动画执行的时间；\nanimation-delay ： 动画执行的延迟时间；\nanimation-timing-function ：动画执行的时序函数；\nanimation-iteration-count ：动画的执行次数；\n\t可选值：次数（具体数值）；  infinite（无限执行）；\nanimation-direction ：指定动画的执行方向；\n\t可选值：normal --- 默认值 从from 到 to 关键帧执行 每次都是这样；\n\t\t\treversal --- 从 to 到 from 关键帧执行 每次都是这样；\n\t\t\talternate --- 从 from 到 to 执行关键帧 重复执行时反向执行上一次的动画；\n\t\t\talternate-reverse --- 从 to 到 from 运行 重复执行动画时反向执行；\nanimation-play-state ： 设置动画的执行状态；\n\t可选值： running --- 默认值 动画执行； paused --- 动画暂停；\nanimation-fill-mode ： 动画的填充模式；\n\t可选值：none --- 默认值 动画执行完毕后元素回到原位置；\n\t\t\tforwards --- 动画执行完毕元素停在结束的位置；\n\t\t\tbackwards --- 动画延时等待时，元素就会处于开始位置；\n\t\t\tboth --- forwards 和 backwards 结合\n\n.demo&#123;\n            width: 700px;\n            height: 700px;\n            background-color: #bfa;\n        &#125;\n         /* 设置关键帧 */\n         @keyframes demo1-move&#123;\n                /* from表示动画开始的位置和状态 */\n                from&#123;\n                    margin-left: 0;\n                    background-color: aqua;\n                &#125;\n                /*  to 表示动画结束的位置 也可以用100% 表示 */\n                to&#123;\n                    background-color: orange;\n                    margin-left: 600px;\n                &#125;\n            &#125;\n        .demo1&#123;\n            width: 100px;\n            height: 100px;\n            background-color: skyblue;\n            /* 使用刚设置的关键帧 */\n            animation-name: demo1-move;\n            /* 设置动画的执行时长 */\n            animation-duration: 3s;\n            /* 设置动画的执行次数 迭代次数*/\n            animation-iteration-count: 3;\n            /* 设置动画的执行时序函数 */\n            animation-timing-function: ease;\n            /* 设置动画的执行方向 交替反向执行*/\n            animation-direction: alternate;\n            /* 设置动画的启动延时 */\n            animation-delay: 1s;\n            /* 设置动画的执行状态 */\n            /* animation-play-state: paused; */\n            /* 设置动画的执行填充  执行完以后停在执行结束的位置 */\n            animation-fill-mode: both;\n        &#125;\n\nanimation 属性：简写形式 除了执行时长必须要写在延时启动时间之前 其他属性设置顺序随意；","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"小米网站首页练习","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/10/小米网站首页练习/","content":"顶部导航栏\n\t小米首页的布局都是在一个外部容器宽占100%中放入一个内部容器布局，其中内部大容器的宽度都是一致 1226px ，这样可以通过设置水平的margin为auto达到内部元素水平居中；\n\t\n\t导航栏布局较简单：\n\t内部容器为一个大的div\n\t\t里面划分为3个ul\n\t\t\t左边的ul 开启 float:left\n\t\t\t右边的两个ul均开启 float:right; (注意float的先后顺序)\n\t\t每一个ul里的li元素均开启float:left使li元素可排列在同一排\n\t在开发中应设置li中的a标签转换为 block 元素 以使其高度与外部的div一致 增大a标签的可点击范围；\n\t\n\n导航栏设置主要难度在弹出层的设置：在鼠标移入 下载app 的li标签时 其下部应该展示下载的二维码，具体设置如下：\n\t\n1.应该设置弹出层的div放在a标签里面，这样才能确保在鼠标移入a标签时弹出层出现且在鼠标移入弹出层时a标签依旧保持hover效果，而且网页中的弹出层是可以点击的；\n\t\t\t&lt;li>\n                    &lt;a href=\"javascript:;\" class=\"app\">下载app\n                        &lt;div class=\"qrcode\">\n                            &lt;img src=\"./mi_images/download.png\">\n                            &lt;span>小米商城APP&lt;/span>\n                        &lt;/div>\n                    &lt;/a>\n                &lt;/li>\n\n2.a标签开启相对定位（此时弹出层div为其子元素），所以弹出层div要开启绝对定位来设置弹出的位置；\n\n3.弹出层的过渡效果通过设置弹出层div的高度开始为0，当鼠标移入a标签时，弹出层div高度逐渐增大到正常高度，使用transition属性设置，transition属性的开启设置在要变化的元素身上！！！\n\n4.购物车的弹出层实现方法和上述相似，我这里的购物车是一个单独的ul，而且这个ul里面只有一个li，所以我将弹出层和a标签放置在同级，为兄弟关系；\n&lt;!-- 右侧购物车 -->\n            &lt;ul class=\"shop-cart\">\n                &lt;li>\n                    &lt;a href=\"javascript:;\">\n                        &lt;i class=\"fas fa-shopping-cart\">&lt;/i>\n                        购物车（0）\n                    &lt;/a>\n                    &lt;div class=\"mycart\">\n                        &lt;span>购物车中还没有商品，赶紧选购吧！&lt;/span>\n                    &lt;/div>\n                &lt;/li>\n            &lt;/ul>\n\n5.弹出层的小三角箭头：通过绝对定位这是一个宽高均为0，但是有边框的div，再将不需要的边框设为透明可以实现小三角；\n&lt;style>\n.app::after&#123;\n    display: none;\n    content: '';\n    border: 8px solid transparent;\n    border-bottom-color: white;\n    height: 0;\n    width: 0;\n    /* 要设置宽度才能实现居中 */\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n&#125;\n&lt;/style>\n\n注意要设置弹出层的层级 z-index；  \nlogo栏\nlogo栏布局也是一个大的div中划分为三个部分，其中左侧div中是两个a标签，中间的是商品分类，采用ul布局，右侧的搜索框中是一个输入框和按钮；\n\n主要的难度是logo区图片的切换：\n\t外层的div实现设置好大小，且开启overflow：hidden，以此隐藏div外的图片；\n\t外层div开启相对定位，内部的两个a标签开启绝对定位，当鼠标移入div时，通过改变图片的left偏移量来实现图片的平移，通过给两个a标签开启transition属性实现过渡效果；\n\n中间的ul布局中的li中的a标签应该同父元素高度一致，ul中的最后一个li放的是弹出层，弹出层的绝对定位通过外部容器的相对定位来定位，以此实现弹出层的宽度为100%；\n\nul中的第一个li为隐藏元素，该元素里面有一个纵向的导航栏，该导航栏的绝对定位相对于这第一个隐藏元素li的相对定位；\n录播图区块\n轮播图区块设置主要在切换按钮的雪碧图和右下角的小圆点按钮\n\n雪碧图和小圆点均是开启绝对定位，相对于放入img元素的父元素的相对定位；\n伪元素边框\n该元素的边框均是通过给div中的li元素添加伪元素；\n&lt;style>\n     .home-shop-wrapper .shortcut li::before&#123;\n        content: '';\n        width: 64px;\n        height: 1px;\n        background-color: #665e57;\n        /* background-color: red; */\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        margin: 0 auto\n    &#125;\n    .home-shop-wrapper .shortcut li::after&#123;\n        content: '';\n        width: 1px;\n        height: 70px;\n        background-color: #665e57;\n        /* background-color: red; */\n        position: absolute;\n        left: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto 0;\n    &#125;\n&lt;/style>\n固定工具栏\n使用固定定位一个ul列表；其右侧的弹出层相对于它的每一个li元素定位，当鼠标移入li时，a标签的下一个兄弟元素展示；\n广告卡片展示\n卡片均开启相对定位，当鼠标移入时修改卡片的top属性，加上阴影box-shadow实现卡片效果；\n\n总结/*\n\t这次的小米首页布局历时了几天才完成，虽然内容不多，但是算得上是第一次完成比较完整的网页布局，开发网页都需要先考虑好元素的摆放布局，之后再考虑样式问题；\n\t这个网页使用了相对布局，绝对布局，固定布局，也是第一次接触到transition过渡属性；\n\t在练习时发现了类选择器的优先级问题，写的详细的类选择器优先级较高；\n\t总的来说这次练习再次复习了一下之前所学的知识，对布局的等式有了进一步理解；\n*/\n\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"011-表格-表单","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/06/011-表格-表单/","content":"1.表格使用 table 标签 在网页中创建表格\n\ttr 标签表示表格中的一行\n\ttd 标签表示表格中的一个单元格\n\t\t可在table标签中设置表格的边框属性 默认为没有边框\n\t\ttable是块元素 但是其默认的宽度不会是占满一行 而是由内容撑开 其他的由浏览器自动调整margin-right\n\n&lt;!-- 创建一个表格 -->\n    &lt;!-- 在table标签中 设置border边框属性 -->\n    &lt;table border=\"1px\" >\n        &lt;tr>\n            &lt;td>学号&lt;/td>\n            &lt;td>姓名&lt;/td>\n            &lt;td>年龄&lt;/td>\n        &lt;/tr>\n        &lt;tr>\n            &lt;td>001&lt;/td>\n            &lt;td>gbfdhsj&lt;/td>\n            &lt;!-- 使用rowspan属性合并行单元格 -->\n            &lt;td  rowspan=\"2\">man&lt;/td>\n        &lt;/tr>\n        &lt;tr>\n            &lt;td>001&lt;/td>\n            &lt;td>Kods&lt;/td>\n            \n        &lt;/tr>\n        &lt;tr>\n            &lt;td>001&lt;/td>\n            &lt;!-- 使用colspan属性设置列单元格合并 -->\n            &lt;td colspan=\"2\">Kods&lt;/td>\n        &lt;/tr>\n    &lt;/table>\n\n\n表格可以分为三个部分 thead -- 头部 ； tbody -- 主体 ； tfoot -- 底部 ；\n\t在行中使用th来表示表格的首行的单元格 此时用于表示表格的列值名称 th表示的单元格文字默认加粗\n\n&lt;table border=\"1px\" width=\"400px\" style=\"margin:20px auto;\">\n        &lt;thead>\n            &lt;tr>\n                &lt;th>学校&lt;/th>\n                &lt;th>名字&lt;/th>\n                &lt;th>分数&lt;/th>\n                &lt;th>专业&lt;/th>\n            &lt;/tr>\n        &lt;/thead>\n        &lt;tbody>\n            &lt;tr>\n                &lt;td>惠州学院&lt;/td>\n                &lt;td>hjihu&lt;/td>\n                &lt;td>111&lt;/td>\n                &lt;td>计算机&lt;/td>\n            &lt;/tr>\n            &lt;tr>\n                &lt;td>惠州学院&lt;/td>\n                &lt;td>hjihu&lt;/td>\n                &lt;td>111&lt;/td>\n                &lt;td>计算机&lt;/td>\n            &lt;/tr>\n            &lt;tr>\n                &lt;td>惠州学院&lt;/td>\n                &lt;td>hjihu&lt;/td>\n                &lt;td>111&lt;/td>\n                &lt;td>计算机&lt;/td>\n            &lt;/tr>\n            &lt;tr>\n                &lt;td>惠州学院&lt;/td>\n                &lt;td>hjihu&lt;/td>\n                &lt;td>111&lt;/td>\n                &lt;td>计算机&lt;/td>\n            &lt;/tr>\n        &lt;/tbody>\n    &lt;/table>\n\nborder-spacing: 指定边框之间的距离 此时指两边框间的距离 不是边框重合\nborder-spacing: 0px; 两边框相邻间隔为0\nborder-collapse: collapse; 设置边框的合并 此时指两边框合并为一条边框 \n\n table&#123;\n            width: 500px;\n            margin: 30px auto;\n            border: 1px solid black;\n            /* 此时在css文件中设置table的边框样式只有外边框 单元格此时没有边框 */\n            border-spacing: 0px;\n            /* 2.利用border-spacing属性设置边框间的间隔为0px\n                此时的边框为2px\n            */\n            border-collapse: collapse;\n            /* 3.设置边框重合 此时边框只有1px*/\n        &#125;\n        td&#123;\n            border: 1px solid black;\n            /* 4.此时给每一个单元格设置外边框 加上table的外边框此时呈现双边框效果 */\n            text-align: center;\n            /* 5.设置单元格中文字居中 */\n            /* 单元格中的元素默认垂直居中 */\n            /* vertical-align: top; */\n        &#125;\n        table  tr:nth-child(odd)&#123;\n            background-color: #bfa;\n            /* 在写代码时若我们没有使用tbody 浏览器在解析时也会自动加上tbody' */\n            /* 设置奇数行背景颜色 */\n        &#125;\n        table tr:nth-child(even)&#123;\n            background-color: aliceblue;\n        &#125;\n2.表单在网页中使用 form 标签创建表单\n\t在action中值为处理表单收集到的信息发送的服务器地址\n\t表单中输入的信息可选input标签 通过选择type类型来设置输入类型\n\t\ttext -- 文本\n\t\tpassword -- 密码\n\t\tradio -- 单选框（单选框需要使用同一组name值来限定）\n\t\tcheckbox -- 多选框\n\t\tcolor -- 颜色选择器\n\t表单元素必须指定name属性\n\treadonly 将表单项设置为只读，数据会提交\n\tdisabled 将表单项设置为禁用，数据不会提交\n    autofocus 设置表单项自动获取焦点\n\nautocomplete=\"off\" 关闭自动补全\n\t\t\n  &lt;form action=\"target.html\">\n        &lt;div class=\"title\">\n            &lt;h1>用户注册&lt;/h1>\n        &lt;/div>\n        &lt;div class=\"info-input\">\n            &lt;label for=\"username\">姓名&lt;/label>\n            &lt;input type=\"text\" id=\"username\" name=\"username\" placeholder=\"请输入用户名\" autocomplete=\"off\" value=\"1212\" readonly autofocus>\n        &lt;/div>\n        &lt;div class=\"info-input\">\n            &lt;label for=\"password\">密码&lt;/label>\n            &lt;input type=\"password\" id=\"password\" name=\"password\" placeholder=\"请输入密码\" value=\"1212\" disabled>\n        &lt;/div>\n        &lt;div>\n            &lt;label for=\"sex\">性别&lt;/label>\n            &lt;input type=\"radio\" value=\"1\" name=\"sex\" id=\"sex\" checked>男\n            &lt;input type=\"radio\" id=\"sex\" value=\"2\" name=\"sex\">女\n        &lt;/div>\n        &lt;div>\n            &lt;label for=\"major\">专业&lt;/label>\n            &lt;select id=\"major\" name=\"major\">\n                &lt;option value=\"1\">计算机&lt;/option>\n                &lt;option value=\"2\" selected>数学&lt;/option>\n            &lt;/select>\n        &lt;/div>\n        &lt;div>\n            &lt;label for=\"hobby\">爱好&lt;/label>\n            &lt;input type=\"checkbox\" name=\"bobby\" id=\"hobby\" value=\"1\">篮球\n            &lt;input type=\"checkbox\" name=\"bobby\" id=\"hobby\" value=\"2\">足球\n            &lt;input type=\"checkbox\" name=\"bobby\" id=\"hobby\" value=\"3\">跑步\n        &lt;/div>\n        &lt;input type=\"color\" name=\"\" id=\"\">\n        &lt;input type=\"submit\" value=\"注册\">\n    &lt;/form>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"010-背景-颜色渐变","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/05/010-背景/","content":"1.背景background-color 设置背景颜色\n\nbackground-image 设置背景图片\n\t可以同时设置背景颜色和背景图片 此时背景颜色会成为背景图片的背景色\n\t\t1.如果背景图片小于当前的元素大小 背景图片会自动在元素中平铺\n\t\t2.如果背景图大于元素 将会溢出父元素 溢出元素的背景无法显示\n\t\t3.若背景图片和元素一样大 则会直接正常显示\n\n background-repeat 用来设置背景的重复方式\n         可选值：\n                repeat 默认值 ， 背景会沿着x轴 y轴双方向重复\n                repeat-x 沿着x轴方向重复\n                repeat-y 沿着y轴方向重复\n                no-repeat 背景图片不重复\n\n background-position 用来设置背景图片的位置\n                    设置方式：\n                        通过 top left right bottom center 几个表示方位的词来设置背景图片的位置\n                            使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center\n\n                        通过偏移量来指定背景图片的位置：\n                            水平方向的偏移量 垂直方向变量\n\n.demo&#123;\n            width: 300px;\n            height: 300px;\n            background-color: #bfa;\n\n            /* 设置背景图片 */\n            background-image: url('./img/1.png');\n            /* 1.原背景图片 大小为  128* 128 此时背景图小于元素\n                此时背景图默认在元素中重复平铺展示\n            */\n\n            /* width: 100px;\n            height: 100px; */\n            /* 2.将元素大小修改成小于背景图 此时溢出元素的背景无法显示 */\n\n            /* width: 128px;\n            height: 128px; */\n            /* 3.此时元素与背景图大小一致 正常显示 */\n\n            background-repeat: repeat;\n            /* 4.设置背景图的重复方式 此时背景图小于元素 \n            且重复方式为 repeat默认值 此时背景图水平垂直方向上均重复*/\n\n            /* background-repeat: repeat-x; */\n            /* 5.设置背景图重复方式为水平重复 此时垂直方向上无重复 */\n\n            /* background-repeat: repeat-y; */\n            /* 6.设置背景图垂直重复 此时背景图水平方向上无重复 */\n\n            background-repeat: no-repeat;\n            /* 7.设置背景图水平垂直方向上均无重复 */\n\n            background-position: 0 0;\n            /* 8.设置背景图偏移量来设置背景图的位置 此时 0 0 为默认值 \n                为父元素文档流中的位置 元素的内边距区开始计算\n            */\n\n            background-position: 10px 20px;\n            /* 9.第一个值为水平方向上的偏移（正值时图片向右移动）\n                第二个值为垂直方向上的偏移（正值时图片向下移动）\n            */\n\n            background-position: center center;\n            /* 10. 通过方位词来设置背景图的位置 */\n\n        &#125;\n\nbackground-clip 设置背景范围\n\t可选值 : border-box 默认值 此时背景图会出现在边框的下边\n\t\t\tpadding-box 此时背景不会出现在边框下边 但会出现在内容区和内边距区\n\t\t\tcontent-box 此时背景只会出现在内容区\n\n.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n\n            border: 10px transparent solid;\n            /* 给元素添加10px 的透明边框  */\n            padding: 10px;\n            /* 给元素添加 10 px 的内边距区 */\n            background-clip: border-box;\n            /* 1.此时的background-clip 值为border-box 默认值 此时背景会出现在边框区 和 内边距区*/\n            background-clip: padding-box;\n            /* 2.设置background-clip 值为 padding-box \n            此时背景颜色不会出现在边框区 此时元素的外边框因背景透明不可见 */\n            background-clip: content-box;\n            /* 3.设置背景颜色只出现在内容区 此时内边距区因背景透明不可见 */\n\n        &#125;\n\nbackgroung-origin 设置背景图偏移量（background-position）的计算原点\n\t可选值： padding-box 默认值 此时计算原点从内边距区处开始计算\n\t\t\tcontent-box 背景图偏移量计算原点从内容区开始\n\t\t\tborder-box 背景图偏移量的计算原点从边框处开始计算\n\nbackground-size 设置背景图的大小 第一个值表示宽 第二个值表示高\n\t若只写一个值 则默认第二个值是auto\n\tcover --- 图片的比例不变 将元素铺满\n\tcontain --- 图片比例不变 将图片在元素中完整显示\n\nbackground-attachment 设置背景是否会跟随元素移动\n\t可选值 : scroll 默认值此时背景图会跟随元素移动\n\t\t\tfixed 背景图会固定在页面中 不会跟随元素移动\n\n.demo1&#123;\n            width: 1920px;\n            height: 1000px;\n            background-color: #bfa;\n            background-image: url('./img/2.jpg');\n            /* 此时背景图远大于元素 溢出部分无法显示 */\n\n            background-size: 500px;\n            /* 1.通过设置background-size 设置背景图的宽为500px 此时高等比例缩小\n            此时背景图在元素内平铺 效果和 contain 一致\n            */\n\n            background-size: cover;\n            /* 2.图片的比例不变 将元素铺满 */\n            /* background-size: contain; */\n            /* 3.图片的比例不变 将图片在元素中完整显示 可能会出现重复平铺 */\n            background-repeat: no-repeat;\n            /* 4.设置背景图不重复平铺 */\n\n            border: 10px solid red;\n            padding: 20px;\n            /* 设置外边框个内边距 此时背景图延伸到内边距区 */\n\n            background-origin: padding-box;\n            /* 5.设置背景图的偏移计算原地为内边距区 */\n            /* background-position: 10px 10px; */\n            \n            background-origin: content-box;\n            /* 6.设置背景图的偏移计算原点为内容区 */\n\n            background-origin: border-box;\n            /* 7.设置背景图偏移量计算原点为外边框区 */\n\n            background-attachment: scroll;\n            /* 8.设置背景图跟随元素移动 scroll 为默认值 */\n\n            background-attachment: fixed;\n            /* 9.设置背景图以原图大小固定在在页面中元素文档流的位置 \n                溢出的背景不可见 滑动页面元素移动时背景不会动\n                想象是移动画框 画固定在原地\n            */\n        &#125;\n2.背景色渐变1.水平垂直线性渐变渐变 ： 一个颜色向其他颜色过渡的效果 \nPS： 渐变是图片！！ 需通过background-image 来设置\n\tlinear-gradient 线性渐变 颜色沿着一条直线发生变化\n\t线性渐变的开头 可以指定一个渐变的方向\n\t\tto left ； to right ； to bottom ； to top ； to top left ...\n\t\tdeg --- 度数 ； turn --- 圈数 ；\n\t渐变可以同时指定多个颜色 多个颜色情况下平均分布；\n\t\t可以手动指定渐变的分布情况；\n\n.box2&#123;\n            width: 200px;\n            height: 200px;\n            background-image: linear-gradient(red,green);\n            /* 设置线性渐变 从红色到绿色 默认情况上是 从上到下渐变 各占一半分布 */\n\n            background-image: linear-gradient(to right,red,yellow);\n            /* 设置从左到右的线性渐变 从红色到绿色 */\n\n            background-image: linear-gradient(to left, red,yellow 50px,gold 100px ,orange 150px,grey 200px);\n            /* 设置从左到右由红色开始渐变到黄色占50px \n                再由黄色渐变到金色 占50px\n                再由金色渐变到橘色 占50px\n                再由橘色渐变到灰色 占50px\n            */\n\n            background-image: linear-gradient(90deg, red,yellow );\n            /* 0度 时为从下到上渐变 90deg为顺时针旋转90度 此时为由红色到黄色 从左到右水平线性渐变*/\n\n            background-image: linear-gradient(0.25turn,red,yellow);\n            /* 0turn为从下到上渐变  0.25turn相当于顺时针旋转90度*/\n        &#125;\n2.径向渐变background-image：radial-gradient（） 可设置径向渐变（放射性效果）\n\t默认情况下径向渐变的形状根据元素的形状来计算 正方形 --- 圆形； 长方形 --- 椭圆形；\n\t也可以手动指定径向渐变的大小\n\t\t1.circle ； 2.ellipse ； \n\t指定渐变的位置\n\t\tradial-gradient（大小 at 位置 ， 颜色 位置， 颜色 位置，颜色 位置）\n\t\t\t\t大小：circle 圆形；ellipse 椭圆形；closest-side 近边；closest-corner 近角； \n\t\t\t\t\tfarthest-side 远边； farthest-corner 远角；\n .box2&#123;\n            width: 200px;\n            height: 200px;\n            background-image: radial-gradient(circle at 50px 50px,red,yellow);\n            /* 设置径向渐变  */\n        &#125;\n详见参考官方文档  ： https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/radial-gradient()","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"009-字体和图标","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/02/009-字体和图标/","content":"1.默认字体格式设置网页字体属性 \n\t1. color 设置元素的字体颜色\n\t2. font-size 设置字体的大小 单位 px em（以父元素为标准） rem（以根元素body为标准）\n\t\t1em / 1rem =1默认字体大小\n\t3. font-family 字体族 设置字体的样式 \n\t\t可选值 ： serif 衬线字体 ； sans-serif 非衬线字体 ； monospace 等宽字体 ；\n\t\tfont-family 可同时指定多个字体 多个字体间用 , 隔开 字体生效时优先使用第一个 往后以此类推\n\t4. font-weight 字重 设置字体的加粗\n\t\t可选值 ： normal 默认值； bold 加粗； \n\t5. font-style 字体风格\n\t\t可选值 ： normal 默认值； italic 斜体；\n\t\t\n.demo1&#123;\n            border: 2px red solid;\n            /* 设置demo1 字体颜色 */\n            color: skyblue;\n            /* 设置demo1 字体大小 */\n            font-size: 18px;\n            /* 设置demo1 字体样式 非衬线字体*/\n            font-family: sans-serif;\n        &#125;\n        .demo2&#123;\n            border: 2px red solid;\n            color: green;\n            font-size: 1em;\n            font-family: monospace;\n        &#125;\n        .demo3&#123;\n            border: 2px red solid;\n            color: aqua;\n            font-size: 2rem;\n            font-family: serif;\n        &#125;\n\n\n字体的简写格式\nfont 可以设置字体相关的所有属性 语法： font: 字体大小/行高 字体族 行高 可以省略不写 如果不写使用默认值\n\t p&#123;\n            border: 2px red solid;\n            font: 30px/40px monospace;\n            /* 将字体设置为 大小为 30px 行高为40px 字体族为等宽字体 */\n            font: italic bold 30px serif;\n            /* 将字体设置为 斜体 粗体 大小为30px 行高默认 字体族为衬线字体 */\n        &#125;\n&lt;p>遇沉沉不语之士，且莫输心；见悻悻自好之人，应须防口。 --菜根谭·概论&lt;/p>\n2.使用自定义字体格式在 &lt;style> 标签中导入自已的字体样式资源\n\n\t@font-face&#123;\n        /* 指定字体在网页中使用时的名字 */\n        font-family: '自己起的字体名字';\n        src: url('字体所在的路径') format(\"truetype\")\n&#125;\n.demo4&#123;\n            border: 2px red solid;\n            color: black;\n            font-size: 1em;\n            /* 使用自定义字体样式 */\n            font-family: myfont;\n        &#125;\n3.矢量图标–Awesome的使用1.下载 https://fontawesome.com/\n            2.解压\n            3.将css和webfonts移动到项目中\n            4.将all.css引入到网页中\n            5.使用图标字体\n                - 直接通过类名来使用图标字体\n                    class=\"fas fa-bell\"\n                    class=\"fab fa-accessible-icon\"\nPS ： class 中 只有fas 和 fab 是免费的 当图标字体加载不出来的应在fas 和 fab 中切换尝试\n\n&lt;link rel=\"stylesheet\" href=\"./fa/css/all.css\">\n\n方法1：\n &lt;!-- 通过直接在标签类名使用图标 -->\n    &lt;i class=\"fas fa-spider\" style=\"font-size: 40px; color: red;\">&lt;/i>\n\n方法2：\n &lt;!-- 通过使用实体编码使用图标  &amp;#x实体编码; -->\n    &lt;i class=\"fas\" style=\"font-size: 25px;\">&amp;#xf6be;&lt;/i>\n\n方法3：在伪元素选择器中使用图标\np::before&#123;\n            /* 使用 \\ 加实体编码 作为图标的表示 */\n            content: '\\f0a4';\n            font-size: 30px;\n            /* 必须指定图标族名 Font Awesome 5 Brands/Free 二选一 */\n            font-family: 'Font Awesome 5 Free';\n        &#125;\n        p::after&#123;\n            content: '\\f0a5';\n            font-size: 30px;\n            font-family: 'Font Awesome 5 Free';\n        &#125;\n    &lt;p>\n        好一似今朝沦落人，且回首往昔荣华日。 --鼻子\n    &lt;/p>\n4.阿里字体库使用–iconfont1.在阿里图标库官网选择需要的图标 添加至项目 下载项目并解压\n2.将文件放入网页静态资源中 通过 link 引入样式 iconfont.css 文件\n3.使用方法和Awesome基本一致 在标签中使用时类名均为 iconfont\n\t&lt;link rel=\"stylesheet\" href=\"./MyiconFont/iconfont.css\">\n\n方法1：\n\t&lt;!-- 使用标签类名使用图标 -->\n    &lt;i class=\"iconfont icon-a-1\">&lt;/i>\n\n方法2：\n    &lt;!-- 使用实体编码使用图标 -->\n    &lt;i class=\"iconfont\">&amp;#xe733;&lt;/i>\n\n方法3：\n p::before&#123;\n     \t\t/* 转义编码为实体编码&amp;#x 后的字符 */\n            content: '\\e73f';\n            font-family: 'iconfont';\n            font-size: 100px;\n        &#125;\n \t&lt;p>\n        万物皆有裂痕，那是光照进来的地方。 --颂歌\n    &lt;/p>\n5.行高行高指文字占有的实际高度 可通过 line-height 指定行高\n行高可以直接指定一个大小（px em）\n                        也可以直接为行高设置一个整数\n                            如果是一个整数的话，行高将会是字体的指定的倍数\n 行间距 = 行高 - 字体大小\n 字体框 - 字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度\n \t\t\t行高会在字体框的上下平均分配\n\n.demo&#123;\n            /* 设置字体大小 */\n            font-size: 50px;\n            /* 设置边框 */\n            border: 2px red solid;\n            /* 设置行高 */\n            line-height: 50px;\n            /* 1.此时文字和行高一致 若此时文字的行高小于字体大小的话 文字将叠在一起 */\n            line-height: 60px;\n            /* 2.此时行高大于字体大小 即实际上文字的高度小于文字所在行的高度 此时可见文本行间距较大 */\n        &#125;\n&lt;div class=\"demo\">\n        但使文章有风骨，岂凭时间庸人辱。 --知乎Lorem ipsum, dolor sit amet consectetur adipisicing elit. Corrupti iste reiciendis aliquid consectetur porro autem aut recusandae odit, sint, quis adipisci odio obcaecati quas maxime ducimus exercitationem est! Repellat, ad.\n    &lt;/div>\n6.文本的样式1.文本水平，垂直对齐text-align 属性可设置文本的水平对齐方式\n\t可选值：left 左对齐；right 右对齐；center 居中对齐； justify 两端对齐；\n.demo&#123;\n            border: 2px red solid;\n            font: 30px monospace;\n            text-align: center;\n            /* 1.居中对齐 */\n            text-align: left;\n            /* 2.居左对齐 */\n            text-align: justify;\n            /* 3.两端对齐 */\n            text-align: right;\n            /* 4.居右对齐 */\n        &#125;\n\nvertical-align 属性设置元素的垂直对齐方式\n\t可选值： baseline 默认值 基线对齐\n\t\t\ttop 顶部对齐\n\t\t\tbottom 底部对齐\n\t\t\tmiddle 居中对齐\n\n\t\t.demo1&#123;\n            font: 50px monospace;\n            border: 2px red solid;\n        &#125;\n        span&#123;\n            border: 1px blue solid;\n            font: 30px serif;\n            vertical-align: baseline;\n            /* 1.设置基线对齐 默认值 */\n            vertical-align: top;\n            /* 2.设置垂直顶部对齐 此时span元素在行间以父元素的顶部对齐 */\n            vertical-align: bottom;\n            /* 3.设置垂直底部对齐 此时span 元素在行间以父元素的底部对齐 底部对齐低于基线对齐 */\n            vertical-align: middle;\n            /* 4.设置垂直居中对齐 此时span元素在行间以父元素中的x的中心点为基准对齐*/\n        &#125;\n&lt;div class=\"demo1\">\n        上善若水，水善利万物而不争。x&lt;span>Hellox督导室覅女卫&lt;/span> --老子·道经·第八章\n    &lt;/div>\n2.文本修饰text-decoration 设置文本修饰\n\t可选值：none 什么都没有； underline 下划线； line-through 删除线； overline 上划线；\n\n .demo1&#123;\n            font: 30px monospace;\n            text-decoration: none;\n            /* 1.text-decoration : none 此时文本无效果 */\n            text-decoration: line-through;\n            /* 2.删除线效果 */\n            text-decoration: underline;\n            /* 3.下划线效果 */\n            text-decoration: overline;\n            /* 4上划线效果 */\n        &#125;\n&lt;div class=\"demo1\">\n        凡事都有一个与一望而知不同的真相 --约翰·勒卡雷\n    &lt;/div>\n\nwhite-space 设置网页如何处理空白\n\t可选值： normal 正常 默认值； nowrap 不换行； pre 保留空白；\n\n .demo2&#123;\n            font: 30px sans-serif;\n            white-space: normal;\n            /* 1.normal 正常 此时网页解析时 多个空格解析成一个空格 */\n            white-space: nowrap;\n            /* 2.nowrap 不换行 此时网页解析时文本段不换行 */\n            white-space: pre;\n            /* 3.pre 保留空白 此时网页解析时按照编辑器里文本的格式解析*/\n        &#125;\n&lt;div class=\"demo2\">没有人愿意承认自己是孤独的，孤独很可耻。            \n           --此间的少年Lorem ipsum dolor sit amet consectetur adipisicing elit. Nobis eos praesentium repellendus, facilis iure ullam accusamus? Quis, culpa numquam itaque voluptatem ullam magni tenetur, asperiores consequuntur necessitatibus nostrum ut dolores!\n        &lt;/div>\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"008-position布局","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/01/008-position布局/","content":"1.position布局​    定位（position）是一种布局手段 通过定位可以将元素摆放到任意位置\n​        使用position属性来开启定位：\n​                可选值  1.static 默认值 此时元素为不开启定位\n​                            2.relative 开启元素相对定位\n​                            3.absolute 开启元素绝对定位\n​                            4.fixed 开启元素固定定位\n​                            5.sticky 开启元素粘滞定位\n      偏移量（offset）：元素开启定位后 可以通过偏移量来设置元素的位置\n\n​                        top —  定位元素和定位位置上边的距离 top值越大 定位元素越靠下\n​                        bottom — 定位元素和定位位置下边的距离 bottom值越大 定位元素越靠上\n​                        left —  定位元素和定位位置左侧的距离 left值越大 定位元素越靠右\n​                        right —  定位元素和定位位置右侧的距离 right值越大 定位元素越靠左\n2.相对定位当元素的position属性为 relative 时 开启相对定位 \n\t- 相对定位的特点：\n                            1.元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化\n                            2.相对定位是参照于元素在文档流中的位置进行定位的\n                            3.相对定位会提升元素的层级\n                            4.相对定位不会使元素脱离文档流\n                            5.相对定位不会改变元素的性质块还是块，行内还是行内\n.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 1.初始三个div垂直排列 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            position: relative;\n            /* 2.demo2开启相对定位 但是还未设置偏移量\n                开启相对定位的元素不会脱离文档流 所以demo3的位置不会发生变化\n            */\n            left: 0px;\n            right: 0px;\n            /* 3.给元素的相对定位偏移量设置为 left 0 right 0 让其回到参照原点 可知\n                相对定位的参照原点为其在文档流时候的位置\n            */\n            left: 200px;\n            top: -200px;\n            /* 4.给元素依照参照原点 向右移动200px 向上移动200px 使其与demo1水平相邻排列*/\n            left: 70px;\n            /* 5.将元素demo2向右水平移动的距离改为70px 可见现在demo2遮盖住了demo1 所以可知相对定位会提升元素的层级\n                应为开启相对定位的元素未脱离文档里 不会改变元素的块级元素性质 而且开启相对定位的元素 其文档流后的元素不会因为其移动为改变布局\n            */\n        &#125;\n        .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: green;\n            /* demo3全程不移动 虽然demo已经移走 但是demo2还占据文档流中的位置 */\n        &#125;\n\t&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3&lt;/div>\n3.绝对定位当元素的position属性值为 absolute 时 元素开启绝对定位\n\t- 绝对定位的特点：\n                    1.开启绝对定位后，如果不设置偏移量元素的位置不会发生变化\n                    2.开启绝对定位后，元素会从文档流中脱离\n                    3.绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开\n                    4.绝对定位会使元素提升一个层级\n                    5.绝对定位元素是相对于其包含块进行定位的\n包含块( containing block )\n                        - 正常情况下：\n                            包含块就是离当前元素最近的祖先块元素\n                            &lt;div> &lt;div>&lt;/div> &lt;/div>\n                            &lt;div>&lt;span>&lt;em>hello&lt;/em>&lt;/span>&lt;/div>\n\n                        - 绝对定位的包含块:\n                            包含块就是离它最近的开启了定位的祖先元素，\n                                如果所有的祖先元素都没有开启定位则根元素就是它的包含块\n\n                        - html（根元素、初始包含块）\n.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            /* 1.初始demo1和demo2垂直相邻排列 */\n            position: absolute;\n            /* 4.demo2 开启绝对定位 demo2脱离文档流 所以demo3向上移动部位\n                但是demo2还未设置偏移量 所以demo2位置不发生变化\n                但是明显demo2遮挡住了demo3 可知开启绝对提升了元素的层级\n            */\n            top: 0;\n            left: 0;\n            /* 5.让demo2回到定位参照原点 可知此时demo2回到了最左上角 */\n            /* 8. 可知demo2此时的包含块是html根标签 所以回到最左上角 */\n        &#125;\n        .demo3&#123;\n            width: 400px;\n            height: 400px;\n            background-color: greenyellow;\n        &#125;\n        .demo4&#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n            position: relative;\n            /* 6.demo4 开启相对定位  未设置偏移量 此时demo4位置不发生变化*/\n        &#125;\n        .demo5&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            /* 2.初始demo3里包含demo4，demo4包含demo5 */\n            position: absolute;\n            /* 3.demo5开启绝对定位 还未设置偏移量 页面布局不发生变化 */\n            top: 0;\n            left: 0;\n            /* 7.让demo5回到定位参照原点 可见demo5回到了demo4文档流所在位置\n                可知绝对定位的参照原点是距其最近的开启了定位的包含块\n                    若元素的祖先们均未开启定位 则该元素的定位参照原点为html根包含块\n            */\n        &#125;\n\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4\n            &lt;div class=\"demo5\">5&lt;/div>\n        &lt;/div>\n    &lt;/div>\n\nPS：实际开发中 使用绝对定位和相对定位较多\n4.固定定位元素的position属性值为 fixed 时 元素开启固定定位\n\t特点：固定定位为绝对定位的一种 用法性质基本和绝对定位一致 \n\t\t\t唯一不同的是固定定位的参照原点一直都是浏览器的视口\n\t\t\t固定定位的元素不会随网页的滚动条移动\n .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 250px;\n            height: 250px;\n            background-color: skyblue;\n            position: fixed;\n            /* 2.demo2开启固定定位 */\n            top: 0;\n            left: 0;\n            /* 3. demo2回到定位参照原点 此时demo2位于页面最左上角 demo2此时脱离文档流 demo3上移*/\n        &#125;\n        .demo3&#123;\n            width: 300px;\n            height: 300px;\n            background-color: yellowgreen;\n            position: relative;\n            /* 4.demo3开启相对定位 */\n        &#125;\n        .demo4&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            position: fixed;\n            /* 1.demo4开启固定定位 此时未设置偏移量时 demo4固定在网页的这个位置不动 */\n            top: 0;\n            left: 0;\n            /* 5.demo4也回到定位参照原点 可知 此时demo4也会在demo2所在位置\n                可知固定定位的参照原点是浏览器的网页视口\n            */\n             left: 400px;\n            /* 让demo4从参照原点向右移动400px */\n        &#125;\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4&lt;/div>\n    &lt;/div>\n\n5.粘滞定位粘滞定位\n                    - 当元素的position属性设置为sticky时则开启了元素的粘滞定位\n                    - 粘滞定位和相对定位的特点基本一致，\n                        不同的是粘滞定位可以在元素到达某个位置时将其固定\n粘滞定位只能调整top 和 left 且调整top是不影响元素的原位置 只有在滑动元素要离开这一页面时才生效\n\n  .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: beige;\n        &#125;\n        .demo2&#123;\n            width: 250px;\n            height: 250px;\n            background-color: skyblue;\n            position: sticky;\n            /* 1.demo1 开启粘滞定位 特点和相对定位差不多 元素不脱离文档流 */\n            left: 0;\n            top: 0;\n            /* 2.demo2 回到参照原点  此时网页下滑时demo2在浏览器视口位置保持不动*/\n            left: 200px;\n            /* 3. demo2 向左移动200px 此时网页下滑时 demo2在浏览器视口向左移动200px的位置保持不变 */\n            top: 20px;\n            /* 4. 未滑动时demo2位置不发生变化 可知设置top未滑动页面时不影响元素原位置 \n                在页面下滑时 页面会停留在参照浏览器视口而偏移的位置\n            */\n        &#125;\n        .demo3&#123;\n            width: 100px;\n            height: 100px;\n            background-color: dodgerblue;\n        &#125;\n\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3&lt;/div>\n6.绝对定位元素的布局开启绝对定位以后 水平方向的布局的等式需要再加入 left right 两个值\n left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块的内容区的宽度\n此时规则和之前一样只是多添加了两个值：\n                            当发生过度约束：\n                                如果9个值中没有 auto 则自动调整right值以使等式满足\n                                如果有auto，则自动调整auto的值以使等式满足\n\n                        - 可设置auto的值\n                            margin width left right\n\n                        - 因为left 和 right的值默认是auto，所以如果不指定left和right\n                            则等式不满足时，会自动调整这两个值\n\n 垂直方向布局的等式的也必须要满足\n   bottom + top + margin-top/bottom + padding-top/bottom + border-top/bottom + height = 包含块的高度\n\n .demo1&#123;\n            width: 300px;\n            height: 300px;\n            background-color: #bfa;\n            position: relative;\n            /* 4.demo1开启相对定位 因此demo2的包含块更改为demo1所在的文档流位置 */\n        &#125;\n        .demo2&#123;\n            width: 100px;\n            height: 100px;\n            background-color: skyblue;\n            /* 1.此时demo1 和 demo2 上边距重叠 */\n            position: absolute;\n            /* 2.demo2开启绝对定位 */\n            left: 0;\n            top: 0;\n            /* 3.demo2回到定位参照原点 此时其父元素还没开启定位 所以其包含块应该是html根元素*/\n            right: 0;\n            /* 5.设置 right == 0 但是水平的等式 过度约束仍然成立 此时浏览器自动调整right不为0以满足等式 */\n            margin-left: auto;\n            /* 6.设置demo2 的margin-left为auto 此时等式不成立是 浏览器优先调整margin-left为最大值以满足等式 */\n            margin-right: auto;\n            /* 7.此时demo2 的margin-right 也为auto 此时浏览器自动调整水平两边的margin值相等 达到居中 */\n            bottom: 0;\n            margin: auto;\n            /* 8.此时demo2的水平 垂直方向上margin 均为 auto 所以浏览器优先调整margin 达到水平垂直居中 */\n        &#125;\n &lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n\n\nPS： 在绝对定位中 若定位元素未设置宽高时 且此时的margin == auto（四个方向），right=left=top=bottom=0 时 此时浏览器自动优先调整元素宽高为父元素大小以满足等式\n\t即margin与宽高均为auto时（元素开启绝对定位后 脱离文档流 元素的宽高默认被内容撑开 可看作为auto）此时宽高将被调整成最大值\n7.元素的层级对于开启了定位元素，可以通过z-index属性来指定元素的层级\n                    z-index需要一个整数作为参数，值越大元素的层级越高\n                        元素的层级越高越优先显示\n\n                    如果元素的层级一样，则优先显示靠下的元素\n\n                    祖先的元素的层级再高也不会盖住后代元素\n\n .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            position: relative;\n            /* 1.开启相对定位 */\n            z-index: 1;\n            /* 11.给demo1设置层级 此时demo1层级变为最高 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            position: absolute;\n            /* 2.开启绝对定位 */\n            top: 20px;\n            left: 40px;\n            /* 5. 此时移动demo2的位置 此时demo2 的参照原点是html根元素 可知demo2 的层级高于demo1 */\n        &#125;\n        .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            /* 3.此时demo3移动到demo2下面 因为demo2已脱离文档流 且demo2此时的层级高于demo3*/\n            position: absolute;\n            /* 4.demo3也开启绝对定位 越靠后的元素层级越高 所以此时demo3层级高于demo2 */\n            left: 80px;\n            top: 40px;\n            /* 6. 此时移动demo3的位置 此时demo3 的参照原点是html根元素 可知demo3 的层级高于demo2 */\n            z-index: 2;\n            /* 12.给demo3设置层级 此时demo3层级高于demo1 demo3的层级此时最高 但可知祖先的层级再高也不会遮挡后代元素 */\n        &#125;\n        .demo4&#123;\n            width: 100px;\n            height: 100px;\n            background-color: green;\n            /* 7.demo4 完全被包含在demo3中 */\n            position: absolute;\n            /* 8.demo4开启绝对定位 还没设置偏移量 所以位置不变 且demo4已没有元素 */\n            top: 0;\n            left: 0;\n            /* 9.此时demo4回到定位参照原点 可知此时demo4的包含块是demo3 */\n            top: 120px;\n            left: 140px;\n            /* 10.移动 demo4的位置 可知此时demo4 的层级高于demo3 此时层级为 demo1 &lt; demo2 &lt; demo3 &lt; demo4 */\n        &#125;\n &lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4&lt;/div>\n    &lt;/div>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"007-float布局","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/01/007-float布局/","content":"1.浮动布局（Float）浮动： 使用 float 属性设置 默认值为none； left 元素向左移动； right 元素向右移动；\n\tPS：一旦元素开启了float属性 此元素将脱离文档流 水平布局的等式便不再强制成立\n\t\t不占用文档流的元素浮动后 还在文档流的元素将自动补上\n\n .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 此时没开启float时 块级元素独占一行 盒子的可见框大小为 200px * 200px 浏览器将自动调整margin-right */\n            float: left;\n            /* 开启float 后 margin-right == 0 元素脱离文档流*/\n        &#125;\n        .demo1&#123;\n            width: 205px;\n            height: 205px;\n            background-color: green;\n            /* 此时demo1自动补上文档流中的demo离开的位置 此时demo1完全被浮动的demo遮挡 不可见 */\n        &#125;\n&lt;div class=\"demo\">&lt;/div>\n&lt;div class=\"demo1\">&lt;/div>\n\n浮动的特点： 按元素的浮动顺序排列 排在后面的浮动元素所在高度不会超过其前面浮动元素的所在高度\n                                排在前面的浮动元素越接近父元素的边界 但无法超出父元素\n2.浮动布局与文字浮动布局最早用来解决文字环绕问题 浮动元素不会遮住文字 文字会自动环绕在浮动元素周围\n.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 开启float后 div上浮 但不会遮住span中的文本 */\n        &#125;\n.content&#123;\n           \n            float: left;\n            /* 可知行内元素开启float 脱离文档流后 特点变得和块元素一样 */\n        &#125;\n\n &lt;span class=\"content\">Lorem ipsum dolor sit amet consectetur adipisicing elit. Molestiae enim officia dolore non dolor eligendi maxime et quis, accusamus laborum pariatur praesentium, saepe dolores ipsa est libero delectus itaque ullam!&lt;/span>\n &lt;div class=\"demo\">&lt;/div>\n\n.test1&#123;\n            background-color: #bfa;\n            /* 未开启float时 div默认独占一行 不主动设置宽高的时候 div宽度默认100% 高度由内容撑开 */\n            float: left;\n            /* 开启float 后 块级元素div 脱离文档流 此时元素的宽高默认由内容撑开 */\n        &#125;\n &lt;div class=\"test1\">\n        我是一个类名为 test1 的div\n        &lt;div class=\"test2\">我是在test1类里的div&lt;/div>\n  &lt;/div>\n\n\n脱离文档流的特点：\n                    块元素：\n                        1、块元素不在独占页面的一行\n                        2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开\n\n                    行内元素：\n                        行内元素脱离文档流以后会变成块元素，特点和块元素一样\n\n                    脱离文档流以后，不需要再区分块和行内了\n\nPPS ： float元素 默认宽高均由内容撑开 但也可以手动设置宽高 此时不再区分块元素和内联元素\n3.高度塌陷问题在普通布局中 外层的块级元素高度默认由内部的块级元素高度撑开 但若父元素内部的子元素开启浮动后 父元素高度将丢失\n\n        .box1&#123;\n            /* 1.不设置宽高 默认其由子元素撑开 */\n            /* 2.设置边框 */\n            border: 5px red solid;\n        &#125;\n        .box2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 3.此时子元素将父元素撑开 */\n            float: left;\n            /* 4.开启子元素浮动后 子元素脱离文档流 将无法撑开父元素高度 */\n        &#125;\n\t &lt;div class=\"box1\">\n        &lt;div class=\"box2\">&lt;/div>\n    &lt;/div>\n4.BFC（块级格式化环境）解决高度塌陷问题 BFC(Block Formatting Context) 块级格式化环境\n                    - BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC\n                        开启BFC该元素会变成一个独立的布局区域\n                    - 元素开启BFC后的特点：\n                        1.开启BFC的元素不会被浮动元素所覆盖\n                        2.开启BFC的元素子元素和父元素外边距不会重叠\n                        3.开启BFC的元素可以包含浮动的子元素\n\n                    - 可以通过一些特殊方式来开启元素的BFC：\n                        1、设置元素的浮动（不推荐）\n                        2、将元素设置为行内块元素（不推荐）\n                        3、将元素的overflow设置为一个非visible的值\n                            - 常用的方式 为元素设置 overflow:hidden 开启其BFC 以使其可以包含浮动元素\n .box1&#123;\n            /* 1.不设置宽高 默认其由子元素撑开 */\n            /* 2.设置边框 */\n            border: 5px red solid;\n            overflow: hidden;\n            /* 5.父元素开启 BFC 使其可以包含浮动元素 此时父元素不会被浮动元素遮挡*/\n            \n        &#125;\n        .box2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 3.此时子元素将父元素撑开 */\n            float: left;\n            /* 4.开启子元素浮动后 子元素脱离文档流 将无法撑开父元素高度 浮动的子元素遮挡住了父元素*/\n        &#125;\n &lt;div class=\"box1\">\n        &lt;div class=\"box2\">&lt;/div>\n &lt;/div>\n\n\nBFC   解决外边距重叠问题\n .demo1&#123;\n            width: 400px;\n            height: 400px;\n            background-color: #bfa;\n            overflow: hidden;\n            /* 3.父元素开启BFC 父元素的外边距与子元素的外边距不重叠 实现子元素在父元素中下移 而父元素不下移 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            /* 1.此时子元素与父元素的外边距重叠 */\n            margin-top: 200px;\n            /* 2.此时父元素 与 子元素 一起下移*/\n        &#125;\n\n &lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n5.clear在普通的块级元素的垂直布局中 若文档流中有元素由于浮动脱离文档流后 该元素之后的文档流元素位置将发生移动 \n\t若不希望元素受到浮动的影响 可使用clear 属性清除浮动元素产生的影响\nclear\n                    - 作用：清除浮动元素对当前元素所产生的影响\n                    - 可选值：\n                        left 清除左侧浮动元素对当前元素的影响\n                        right 清除右侧浮动元素对当前元素的影响\n                        both 清除两侧中最大影响的那侧\n\n                    原理：\n                        设置清除浮动以后，浏览器会自动为元素添加一个上外边距，\n                            以使其位置不受其他元素的影响\n\n \t\t.demo1&#123;\n            width: 400px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 1.此时demo1开启浮动 文档流中其后的demo2 和 demo3 位置将发生移动 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            clear: left;\n            /* 2.demo2 开启clear ：left 清除其前面元素demo1 左浮带来的影响 */\n            float: right;\n            /* 3.此时demo2 开启右浮 demo3位置发生改变 */\n        &#125;\n        .demo3&#123;\n            width: 400px;\n            height: 100px;\n            background-color: green;\n            clear: right;\n            /* demo3 开启 clear ： right 消除demo2右浮的影响 */\n        &#125;\n&lt;div class=\"demo1\">1&lt;/div>\n&lt;div class=\"demo2\">2&lt;/div>\n&lt;div class=\"demo3\">3&lt;/div>\n6.clearfix解决高度塌陷.demo&#123;\n            /* 1.demo不设置宽高 默认其的高度由子元素撑开 此时默认width为100% */\n            border: 5px red solid;\n        &#125;\n        .test&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 2.开启子元素浮动 父元素高度塌陷 */\n        &#125;\n        .demo::after&#123;\n            content: '';\n            display: block;\n            clear: both;\n            /* 3.使用伪类选择器 在父元素的最后加入内容\n                    加入的内容为：\n                        1.''空字符串\n                        2.将这个字符串转换成block元素\n                        3.因为这个字符串元素在浮动元素test后面 使用clear 清除浮动影响\n                        使用clear相当于在这个字符串元素身上加上了 margin-top 高度为test的高度 所以此时父元素相当于被这个字符串元素撑开\n            \n            这里也不推荐使用block 推荐使用table\n            */\n        &#125;\n\n&lt;div class=\"demo\">\n\t &lt;div class=\"test\">&lt;/div>\n&lt;/div>\n\n\n最终的clearfix样式：\n/* clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 */\n        .clearfix::before,\n        .clearfix::after&#123;\n            content: '';\n            display: table;\n            clear: both;\n        &#125;\nPS：这里将字符串元素转换成table类型 是因为block不能将父子元素的外边距分离开\n\t而采用table可以实现外间距分离和高度塌陷\n\n\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"006-文档流-盒模型","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/27/006-文档流-盒模型/","content":"1.文档流（normal flow）​    在文档流中，内联元素默认从左到右流，遇到阻碍或者宽度不够的自动换行，继续按照从左到右的方式布局；块级元素独占一行，按照从上到下的方式布局。\n​    文档流是网页的基础 所创建的元素默认在文档流中排列\n元素在文档流中有什么特点：\n        - 块元素\n            - 块元素会在页面中独占一行(自上向下垂直排列)\n            - 默认宽度是父元素的全部（会把父元素撑满）\n            - 默认高度是被内容撑开（子元素）\n\n        - 行内元素\n            - 行内元素不会独占页面的一行，只占自身的大小\n            - 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素\n                则元素会换到第二行继续自左向右排列（书写习惯一致）\n            - 行内元素的默认宽度和高度都是被内容撑开\n2.盒模型（Box Model）盒模型 ： 可以将网页中的任何元素都看成一个矩形\n\t\t每一个盒子都由以下几个部分组成：\n\t\t1.内容区（content）\n\t\t2.内边距（padding）\n\t\t3.边框（border）\n\t\t4.外边距（margin）\n\n\t内容区 内边距 边框 都会影响可见盒模型的大小！！！\n\n\n\n1.内容区（content）内容区的大小由 width 和 height 两个属性设置\n/* 设置 demo 盒子的大小 */\n        .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n2.边框（border）要想在网页的盒子显示边框 必须要设置三个属性 border-width border-color border-style\n\t\tborder-width 和 border-color 有默认值 可省略不写（border-width默认3px border-color默认使用盒子的color）\n\t（1）border-width：可用来指定盒子四个方向的边框宽度 有默认值 3px\n\t\t\t\t值的情况：四个值 ----上 右 下 左 （顺时针）\n\t\t\t\t\t\t三个值 ---- 上 左右 下\n\t\t\t\t\t\t两个值 ---- 上下 左右\n\t\t\t\t\t\t一个值 ---- 上下左右\n\t\tborder-xxx-width： 可单独指定任意一边的宽度 xxx---top right  bottom  left\n\t（2）border-color: 可用来指定盒子边框的颜色 有默认值 使用color值\n\t\t\t\t使用规则与border-width 基本相同\n\t\t\t\t也有border-xxx-color可使用\n\t（3）border-style ： 用来指定边框的样式 没有默认值 none\n\t\t\t\tsolid 表示实线\n                  dotted 点状虚线\n                  dashed 虚线\n                  double 双线\n\t\t\t\nborder简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求\n\t\tborder: red 10px solid (三者顺序任意 需用空格间隔开)\n 除了border以外还有四个 border-xxx\n                       border-top\n                       border-right\n                       border-bottom\n                       border-left   用来单独设置每一条边框的具体样式\n\t\t\t也有 border-xxx-style 可使用\n\n \t\t/* 设置demo1 盒子的边框样式 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n            border-width: 10px;\n            border-color: red;\n            border-style: solid;\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n          /* 设置demo2 盒子的边框样式 */\n          .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n           border: 10px red solid;\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n         /* 设置demo3 盒子的边框样式 */\n         .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n           border-style: solid;\n           \n           border-top-style: double;\n\n           /* 此时边框宽度使用默认值 边框颜色使用默认值 black */\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n\n3.内边距（padding）​    内容区和边框之间的是内边距区 一共有四个方向的内边距 padding-top/right/bottom/left \n​    内边距的设置会影响盒子的大小  背景颜色会延伸到内边距区 内边距区不能单独设置背景颜色\npadding 内边距的简写属性同 border-width 相同 可同时指定四个方向的内边距大小\n\n /* 设置demo1 盒子的外边距 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n\n\n            /* 设置内边距 20px 此时盒子的高度为220px 盒子的背景颜色延伸到内边距区*/\n            /* padding-top: 20px; */\n            /* 内边距区不能单独设置背景颜色 */\n\n            /* 直接设置4个方向的内边距大小 */\n            padding: 10px 20px 30px 40px;\n\n            border: red 10px solid;\n        &#125;\n\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: black;\n            /* demo2盒子在demo1盒子中 大小与demo1的内容区大小一致 此时设置demo1 的内边距 直接影响demo1\n                盒子的整体大小\n                此时demo1的整体高度为240px\n            */\n\n\n\n            padding-top:10px;\n\n            /* 设置demo2 盒子的内边距不影响demo1的盒子大小 此时 设置demo2 内边距 padding-top 10px \n                此时demo2 整个盒子的高度变为210px\n                因为demo1此时边框距demo2 的边框还差 20px 所以两者边框未重叠\n            */\n\n            border: blue 10px solid;\n\n            /* 此时设置；两盒子的边框 demo2 的盒子高度达到230px 此时与demo1 的边框重合 \n                demo2 此时覆盖了demo1 的padding-bottom 30px    \n            */\n        &#125;\n\n\t&lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n\n\n盒子的可见框的大小，由内容区 内边距 和 边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算\n4.外边距（margin）​    外边距不会影响盒子可见框的大小 只影响盒子排放的位置 一共有四个方向的外边距\n                 margin-top\n                            - 上外边距，设置一个正值，元素会向下移动\n                 margin-right\n                            - 默认情况下设置margin-right不会产生任何效果\n                 margin-bottom\n                            - 下外边距，设置一个正值，其下边的元素会向下移动\n                 margin-left\n                            - 左外边距，设置一个正值，元素会向右移动\n                - margin也可以设置负值，如果是负值则元素会向相反的方向移动\n\n                - 元素在页面中是按照自左向右的顺序排列的，\n                    所以默认情况下如果我们设置的左和上外边距则会移动元素自身\n                    而设置下和右外边距会移动其他元素\n\n                - margin的简写属性\n                    margin 可以同时设置四个方向的外边距 ，用法和padding一样\n\n                - margin会影响到盒子实际占用空间\n\n\t\t/* 设置demo1盒子的外边距样式 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n\n            /* 设置外边框 */\n            border: 10px red solid;\n\n            /* 设置外边距大小 */\n            margin: 30px 20px 50px 100px;\n\n            /* 从效果可知此时盒子在设置margin-top 和 margin-left 时才会移动自身的位置 */\n        &#125;\n\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gainsboro;\n\n            /* 调整demo1 的 margin-bottom 时 demo2 的位置会下移 */\n             margin: 10px;\n\n            /* 此处其实有垂直方向上的 两个盒子 的margin-bottom 和 margin-top 重叠 */\n        &#125;\n\n&lt;div class=\"demo1\">&lt;/div>\n&lt;div class=\"demo2\">&lt;/div>\n5.盒模型的水平布局块元素独占一行 元素在其父元素中的水平方向的位置由以下几个属性共同决定\n\t\t\t\t\t  margin-left\n                        border-left\n                        padding-left\n                        width\n                        padding-right\n                        border-right\n                        margin-right\n\t刚好是盒子从外到内在到内 从左到右的水平宽度之和\n一个元素在其父元素的水平布局中必须满足以下等式：\nmargin-left+border-left+padding-left+width+padding-right+border-right+margin-right = 其父元素内容区的宽度 （必须满足）\n\n若以上等式右边之和小于父元素宽度 称为 过度约束 此时等式会自动调整\n\t\t调整原则：1.这七个值中没有为 auto 的值的时候 浏览器自动调整margin-right值使等式成立\n\t\t\t\t2.如果 width margin-left margin-right 三个值中有为 auto 值的 浏览器会自动优先调整auto使等式成立\n\t\t\t\t\t如果 width 和 margin-left/right 均设置为auto 则宽度会默认调整到最大 margin为0\n\t\t\t\t\t如果只有连个外边距为auto width固定值 此时会自动调整到margin-left=margin-right\n\t\t\t\t\t\t\t实现元素在父元素中居中\n\n \t.demo&#123;\n            width: 1000px;\n            height: 400px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 300px;\n            height: 200px;\n            background-color: yellowgreen;\n            /* 此时demo2的宽度300px 就算小于其父元素的1000px\n                两个demo2共同排放在其父元素demo中 也不可能排放在同一排\n\n                此时 过度约束 成立 没有设置auto值 浏览器调整 demo2的margin-right 为 700px 使等式成立 \n\n                此时demo2的宽度总和占满以父元素 所以 demo3 自动被挤出父元素换行\n            */\n        &#125;\n        .demo3&#123;\n            width: 300px;\n            height: 200px;\n            background-color: yellow;\n\n        &#125;\n        .demo4&#123;\n            width: 1000px;\n            height: 400px;\n            background-color: #bfa;\n        &#125;\n        .demo5&#123;\n            /* width 和 margin 均为 auto 此时width为最大 margin为0 */\n            width: auto;\n            margin: auto;\n            height: 200px;\n            background-color: yellowgreen;\n        &#125;\n        .demo6&#123;\n            /* width 为 400px ， margin 均为 auto 此时；水平两边margin值相等 实现元素在父元素中居中 */\n            width: 400px;\n            margin: auto;\n            height: 200px;\n            background-color: yellowgreen;\n        &#125;\n &lt;div class=\"demo\">\n        &lt;div class=\"demo2\">&lt;/div>\n        &lt;div class=\"demo3\">&lt;/div>\n    &lt;/div>\n\n    &lt;hr>\n\n    &lt;div class=\"demo4\">\n        &lt;div class=\"demo5\">&lt;/div>\n        &lt;div class=\"demo6\">&lt;/div>\n    &lt;/div>\n6.盒模型的垂直布局默认情况下父元素的高度被内容撑开\n .demo&#123;\n            width: 500px;\n            background-color: #bfa;\n            /* 父元素不设置高度 */\n        &#125;\n        .test&#123;\n            width: 200px;\n            height: 200px;\n            background-color: green;\n            /* 子元素高度设置为200px 此时父元素的高度被撑开 为200px */\n        &#125;\n&lt;div class=\"demo\">\n        &lt;div class=\"test\">&lt;/div>\n    &lt;/div>\n\n子元素在父元素的内容区中排列 如果子元素大小超过父元素 称子元素从父元素中 溢出（overflow）\n\t使用 overflow 属性处理溢出的子元素\n\n\t\t\t\t可选值：\n                        visible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示\n                        hidden 溢出内容将会被裁剪不会显示\n                        scroll 生成两个滚动条，通过滚动条来查看完整的内容\n                        auto 根据需要生成滚动条\n .demo1&#123;\n            width: 500px;\n            height: 200px;\n            background-color: #bfa;\n           \n\n            /* overflow属性应写在父元素中 */\n             /* overflow: visible;  */\n            /* overflow默认值为 visible 即显示溢出不作处理 */\n            /* overflow: hidden; */\n            /* overflow: scroll; */\n            /* overflow: auto; */\n            \n        &#125;\n        .test1&#123;\n            width: 200px;\n            height: 400px;\n            background-color: yellowgreen;\n            /* 此时子元素高度超过父元素 从中溢出 */\n        &#125;\n&lt;div class=\"demo1\">\n        &lt;div class=\"test1\">&lt;/div>\n    &lt;/div>\n\n还有 \t\t\toverflow-x: 调整水平溢出\n                overflow-y:调整垂直溢出\n7.外边距的折叠盒子的相邻垂直方向外边距（margin）会发生重叠现象\n\t1.兄弟元素 间的相邻垂直外边距取两者之间最大值（当两者都为正值时）\n\t\t相邻两外边距一正一负时取两者之和\n\t\t若两外边距都是负值时取绝对值大的\n\n\t\t.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            margin-bottom: 50px;\n\n            /* 将demo1 的margin-bottom 设置为 负值 */\n            margin-bottom: -30px;\n\n\n            /* 此时两盒子的垂直外边距均为负值 取demo1 的外边距 -30 px （绝对值较大） */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 此时demo1的margin-bottom值为50px\n                设置demo2 的margin-top 为50px\n            */\n            margin-top: 50px;\n            /* 可知发生外边距折叠 此时盒子布局和只设置demo1 margin-bottom 50px 效果一致 */\n\n            margin-top: 100px;\n            /* 若将demo2的 margin-top 设置为100 px 两盒子间的间隔 取demo2\n                    外边距（100px较大）\n            */\n\n            margin-top: -20px;\n            /* 若将demo2 的margin-top 值设置为 -20 px 此时两盒子的间隔为 50px-20px=30px 取两者之和 */\n        &#125;\n\n&lt;div class=\"demo1\">&lt;/div>\n&lt;div class=\"demo2\">&lt;/div>\n\n实际开发中 兄弟间的边距折叠现象是有利的 不用去处理\n\n\t2.父子元素相邻外边距\n\t\t\t子元素的外边距会传递给父元素\n\t\t\t父子外边距折叠会影响页面布局 需要处理\n\n        /* 父子间元素 */\n\n        .demo3&#123;\n            width: 500px;\n            height: 500px;\n            background-color: #bfa;\n            /* 设置父元素的边框 */\n            border: 2px red solid;\n            /* 给父元素设置边框后 就将父子的边框分离开来 此时 子元素的外边距不会传递给父元素 */\n        &#125;\n        .demo4&#123;\n             border: 2px red solid;\n            /* 只设置子元素的边框无法分离父子元素的边框 需要在父元素处设置边框 */\n            width: 250px;\n            height: 250px;\n            background-color: yellowgreen;\n\n            /* 设置子元素的外边距 */\n            margin-top: 50px;\n            /* 可知此时子元素的外边距与父元素的外边距重叠 设置子元素外边距时父元素的外边距也一起变化 */           \n        &#125;\n \t&lt;div class=\"demo3\">\n        &lt;div class=\"demo4\">&lt;/div>\n    &lt;/div>\n8.行内元素的盒模型行内元素不支持设置宽度和高度\n\t行内元素可以设置padding border margin 都是垂直方向均无效 不影响布局\n\t\t.demo1&#123;\n            width: 200px;\n            height: 200px;\n            /* 设置高度和宽度均无效 */\n            background-color: #bfa;\n            margin-top: 1000px;\n            /* 设置垂直外边距无效 */\n            margin-left: 100px;\n            margin-right: 100px;\n            /* 设置水平外边距有效 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            /* 设置高度和宽度均无效 */\n            background-color: yellowgreen;\n            margin-top: 1000px;\n            /* 设置垂直外边距无效 */\n            margin-left: 100px;\n            margin-right: 100px;\n            /* 设置水平外边距有效 相邻水平间距取两者之和*/\n        &#125;\n &lt;span class=\"demo1\">我是类名为demo1 的span&lt;/span>\n &lt;span class=\"demo2\">我是类名为demo2 的span&lt;/span>\n\n行内元素的两个属性：\n\t（1）display 用来设置元素显示的类型\n\t\t\t\t\t  inline 将元素设置为行内元素\n                        block 将元素设置为块元素\n                        inline-block 将元素设置为行内块元素 \n                                行内块，既可以设置宽度和高度又不会独占一行\n                        table 将元素设置为一个表格\n                        none 元素不在页面中显示\n\t（2）visibility 用来设置元素的显示状态\n   \t\t\t\t\t  visible 默认值，元素在页面中正常显示\n                        hidden 元素在页面中隐藏 不显示，但是依然占据页面的位置\t\n\n  .box1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            display: inline;\n            /* div变成行内元素后 宽度和高度设置将失效 */\n        &#125;\n  &lt;div class=\"box1\">我是一个变成行内元素的div&lt;/div>\n  &lt;div class=\"box1\">我是一个变成行内元素的div&lt;/div>\n\n.test1&#123;\n            background-color: #bfa;\n            display: block;\n            /* 将span的display属性设置为 block span将变为块元素 独占一行 */\n        &#125;\n .test2&#123;\n            background-color: palegoldenrod;\n            display: none;\n            /* display 属性设置为 none 元素将隐藏 */\n        &#125;\n .test3&#123;\n            background-color: pink;\n            visibility: hidden;\n            /* visibility属性设置为 hidden 将元素隐藏 但还是在网页占据位置\n                display ： none 元素不再网页中占据位置空间\n            */\n        &#125;\n\t&lt;span class=\"test1\">我是类名为 test1 的span&lt;/span>\n    &lt;span class=\"test2\">我是类名为 test2 的span&lt;/span>\n    &lt;span class=\"test3\">我是类名为 test3 的span&lt;/span>\n9.盒子的尺寸默认情况下 盒子可见框有 content padding border 三者决定\n\tbox-sizing 用来设置盒子尺寸的计算方式（即设置 width 和 height 的作用）\n\t\t可选值：content-box 为默认值 此时设置的 width 和height 均为content大小\n\t\t\t\tborder-box 此时width 和 height 设置整个盒子的可见框大小\n\t\t.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            border: 10px red solid;\n            box-sizing: content-box;\n            /* 默认值 此时width 和 height 为content 大小 */\n        &#125;\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            border: 10px red solid;\n            box-sizing: border-box;\n            /* 此时width 和 height 决定整个盒子可见框大小 */\n        &#125;\n10.轮廓和圆角（1）轮廓：outline 用来设置元素的轮廓线 用法和border一致\n\t\t\t轮廓和边框不同的是轮廓不会影响可见框的大小\n.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* border: 10px red solid; */\n            outline: 10px red solid;\n            /* outline 属性不影响页面布局 \n                outline会遮住下面的行内元素 但是border不会\n            */ \n        &#125;\n&lt;div class=\"demo\">&lt;/div>\n    &lt;span>hello&lt;/span>\n\n（2）阴影：box-shadow 用来设置元素的阴影效果 阴影不会影响页面布局\n\t\t\t   第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动\n                第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动\n                第三个值 阴影的模糊半径\n                第四个值 阴影的颜色\n \t.demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n           box-shadow: 20px 5px 30px rgba(0, 0, 0, .4);\n        &#125;\n（3）圆角： border-radius 用来设置圆角 圆角设置的圆的半径大小\n\t\t\t/* border-top-left-radius:  */\n            /* border-top-right-radius */\n            /* border-bottom-left-radius:  */\n            /* border-bottom-right-radius:  */\n\t border-radius 可以分别指定四个角的圆角\n                    四个值 左上 右上 右下 左下\n                    三个值 左上 右上/左下 右下 \n                    两个个值 左上/右下 右上/左下  \n\t.demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* border-radius: 30px; */\n            /* 50% 为圆形 */\n            /* border-radius: 50%; */\n\n            border-radius: 10px / 55px;\n            /* 设置椭圆角 第一个值为 垂直半轴 第二个值为 水平半轴*/\n        &#125;\n3.练习line-height 值设置为与父元素的height相等时 此时可让子元素中的字体在父元素中垂直居中\ntext-decoration ：none 为去除超链接下划线样式\n\npadding的设置增加的大小属于盒子 margin的设置增加的大小不属于盒子\ndisplay：inline-block 将元素转换成行内块元素\n重温伪元素选择器 ::before&#123;&#125;\n\n设计页面时先考虑整体布局 先实现整体布局效果 再进一步修改每处细节样式\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"005-样式继承-选择器权重-单位-颜色","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/27/005-样式继承-选择器权重-单位-颜色/","content":"1.样式的继承​    为一个元素设置的样式会自动应用到他的所有后代子元素身上\n​    注意：并不是所有样式都会继承，如 背景，布局相关样式都不会继承\n.box&#123;\n           /* box中的颜色样式会自动继承到box的所有子类身上 */\n           color: blue;\n\n           width: 200px;\n           height: 200px;\n\n           /* 背景颜色不会继承到后代中 但是后代子元素的背景默认为透明 所以看上去同父元素背景颜色一致*/\n           background-color: gray;\n       &#125;\n\n       /* 选择box中的所有span字元素 */\n       div > span, div > p >span&#123;\n           /* background-color: red; */\n           /* 调整透明度 */\n           opacity: .5; \n       &#125;\n2.选择器的权重内联样式        1,0,0,0\nid选择器        0,1,0,0\n类和伪类选择器   0,0,1,0\n元素选择器       0,0,0,1\n通配选择器       0,0,0,0\n继承的样式       没有优先级\n\n比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的）,\n      选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器\n                如果优先级计算后相同，此时则优先使用靠下的样式\n\n可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式，\n       注意：在开发中这个玩意一定要慎用！\n\n /* 选择box中的第一个p元素设置样式 */\n         .box :first-child&#123;\n             /* 这里的第一个p元素不生效 但是第二个p元素的span元素样式生效 因为span是p标签的中的第一个子元素 */\n             color: red;\n         &#125;\n         /* 选中id为 demo的span标签 */\n         #demo&#123;\n             /* id选择器优先级高于类选择器和伪类选择器 */\n             color: aqua;\n         &#125;\n\n&lt;div class=\"box\" >\n        我是一个类名叫box的div\n        &lt;!-- p元素中的内联样式优先级最高 -->\n        &lt;p style=\"color: skyblue;\">\n            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deserunt repellat vero, eveniet dolore ducimus temporibus iure inventore. Nihil ea blanditiis delectus repellat fuga corrupti? Minus voluptate commodi asperiores aspernatur quam!\n        &lt;/p>\n\n        &lt;p>\n            &lt;span id=\"demo\">我是p元素中的span&lt;/span>\n            &lt;br>&lt;br>\n            &lt;span>我是p元素中的第二个span元素&lt;/span>\n        &lt;/p>\n    &lt;/div>\n3.像素单位（1）像素 -- px\n（2）百分比 -- %\n（3）em -- 相对于以元素的字体大小来计算 默认字体大小是16px\n\t\t\t1em = 1font-size  em根据所在元素字体大小计算而改变\n（4）rem -- 根据根元素（root -- html）的字体大小来改变\n\n.demo&#123;\n            /* 设计一个box */\n            width: 400px;\n            height: 400px;\n            background-color: green;\n        &#125;\n        .test&#123;\n            /* 这是在demo里的的一个div 大小根据父容器大小改变 */\n            width:50%;\n            height: 50%;\n            background-color: bisque;\n            /* 改变元素字体大小 */\n            font-size: 12px;\n        &#125;\n        .t1&#123;\n            /* em根据所在元素字体大小改变 */\n            font-size: 30px;\n            width: 5em;\n            height: 5em;\n            background-color: blue;\n        &#125;\n        .t2&#123;\n            /* rem根据body根元素的字体大小改变 */\n            width: 5rem;\n            height: 5rem;\n            background-color: red;\n        &#125;\n        html&#123;\n            font-size: 25px;\n        &#125;\n  &lt;div class=\"demo\">\n        &lt;div class=\"test\">\n            &lt;div class=\"t1\">\n                &lt;div class=\"t2\">&lt;/div>\n            &lt;/div>\n        &lt;/div>\n    &lt;/div>\n4.颜色颜色单位：\n                   在CSS中可以直接使用颜色名来设置各种颜色\n                       比如：red、orange、yellow、blue、green ... ...\n                       但是在css中直接使用颜色名是非常的不方便\n\n                   RGB值：\n                       - RGB通过三种颜色的不同浓度来调配出不同的颜色\n                       - R red，G green ，B blue\n                       - 每一种颜色的范围在 0 - 255 (0% - 100%) 之间\n                       - 语法：RGB(红色,绿色,蓝色)\n\n                   RGBA:\n                       - 就是在rgb的基础上增加了一个a表示不透明度\n                       - 需要四个值，前三个和rgb一样，第四个表示不透明度\n                           1表示完全不透明   0表示完全透明  .5半透明\n\n                   十六进制的RGB值：\n                       - 语法：#红色绿色蓝色\n                       - 颜色浓度通过 00-ff\n                       - 如果颜色两位两位重复可以进行简写  \n                           #aabbcc --> #abc\n                   \n                   HSL值 HSLA值\n                       H 色相(0 - 360)\n                       S 饱和度，颜色的浓度 0% - 100%\n                       L 亮度，颜色的亮度 0% - 100%\n\t\t\t\t  A 透明度 0% - 100%\ndiv&#123;\n           margin-right: 20px;\n       &#125;\n       .demo1&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           background-color: red;\n       &#125;\n       .demo2&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 三个值依次表示 红 黄 蓝 */\n           background-color: rgb(255, 0, 0);\n       &#125;\n       .demo3&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 四个值依次表示 红 黄 蓝 透明度（0~1） */\n           background-color: rgba(255, 0, 0, 1);\n       &#125;\n       .demo4&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用16进制表示 红黄蓝依次使用两个16进制数表示 当每个颜色的两位数字相同时可以采用只写一位的简写 */\n           background-color: #f00;\n       &#125;\n       .demo5&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用 hsl 表示颜色 时三个值依次表示 色相 饱和度 亮度 hsl中的色相取值在0~360 可看成一个圆盘 0和360都是红色\n               饱和度 和 亮度 的取值在0%~100%\n           */\n           background-color: hsl(360, 100%, 50%);\n       &#125;\n       .demo6&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用 hsla 表示颜色 时四个值依次表示 色相 饱和度 亮度 透明度 hsl中的色相取值在0~360 可看成一个圆盘 0和360都是红色\n               饱和度 和 亮度 透明度 的取值在0%~100%\n               透明度 0% 表示不透明 此时元素不显示\n           */\n           background-color: hsl(360, 100%, 50%, 100%);\n\n      &lt;div class=\"demo0\">\n       &lt;div class=\"demo1\">&lt;/div>\n       &lt;div class=\"demo2\">&lt;/div>\n       &lt;div class=\"demo3\">&lt;/div>\n       &lt;div class=\"demo4\">&lt;/div>\n       &lt;div class=\"demo5\">&lt;/div>\n       &lt;div class=\"demo6\">&lt;/div>\n   \t&lt;/div>     \n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"004-CSS选择器","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/26/004-CSS选择器/","content":"1.CSS语法简介&lt;!--\n\t方式1 内联样式/行内样式：在标签内通过style属性设置元素样式\n\t\t内联样式：属性:值; 使用 ; 来间割属性\n\t\t该方式不能实现样式复用\n-->\n&lt;p style=\"color:green; font-size:20px;\">\n    这里是一段p元素文字\n&lt;/p>\n\n!!!注意在实际开发中不要轻易使用内联样式\n\n&lt;!-- \n\t方式2 内部样式表：在head标签内写style标签\n\t\t\t语法 样式选择器&#123;color: red;&#125;   \n\t方式3 外部样式表：通过引入外部css文件\n\t\t\t在head中通过link标签引入\n-->\n&lt;link rel=\"stylesheet\" href=\"这是css文件路径\">\n\n在实际开发中推荐使用方式3 css文件可实现复用\n\ncss文件中的注释符号为  /*  这是注释 */\n2.CSS选择器1.常用选择器（1）元素选择器：根据标签名选中指定元素 页面中所有该元素的标签都有效\n\t语法：标签名&#123;&#125;  如p&#123;&#125;，h1&#123;&#125; ，h2&#123;&#125; body&#123;&#125;\n（2）id选择器： 根据标签的id选中元素\n\t语法：#id名&#123;&#125; 如 #box&#123;&#125;， #big&#123;&#125;\n\t\t使用id选择器时 不提倡id重复 即id选择器只选中一个标签元素\n\t\t\t同id名是 目前的id选择器都将生效 效果和类选择器相同 但不推荐使用相同id\n（3）类选择器：使用类名选择一组相同类名的元素\n\t语法：.className&#123;&#125;,如 .类名&#123;&#125; \n（4）通配选择器：选中页面所有元素\n\t语法：*&#123;&#125; \n\n\np&#123;\n    这是元素选择器\n    color: red;\n&#125;\n#red&#123;\n     这是id选择器\n     color: red;\n&#125;\n.box&#123;\n    这是类选择器\n    color: red;\n&#125;\n*&#123;\n    这是通配选择器\n    效果和元素选择器 body&#123;&#125; 相同 选中所有元素\n&#125;\n2.复合选择器（1）交集选择器：选中同时复合多个条件的元素\n\t语法：选择器1选择器2选择器3&#123;&#125;  \n\t\t交集选择器中如果有元素选择器 需使用元素选择器开头\ndiv.box&#123;\n    这是一个交集选择器 选择一个类名为box的div元素\n    color:red;\n&#125;\n\n\t（2）并集选择器：同时选择多个选择器对应的元素\n     语法：选择器1,选择器2,选择器3&#123;&#125;\ndiv,span,h1&#123;\n    这是一个并集选择器 同时选中div，span，h1 三种标签\n    color: red;\n&#125;\n3.关系选择器父元素\n          - 直接包含子元素的元素叫做父元素\n      子元素\n          - 直接被父元素包含的元素是子元素\n      祖先元素\n          - 直接或间接包含后代元素的元素叫做祖先元素\n          - 一个元素的父元素也是它的祖先元素\n      后代元素\n          - 直接或间接被祖先元素包含的元素叫做后代元素\n          - 子元素也是后代元素\n      兄弟元素\n          - 拥有相同父元素的元素是兄弟元素\n1.子元素选择器（1）子元素选择器：选中指定父元素中的指定子元素\n\t\t\t语法：父元素 > 子元素\ndiv.box > span &#123;\n    /* 选中类名为box的div中的所有span子元素 只选中子元素*/\n    color: red;span &#123;\n            color: aqua;\n            /* 1.给所有span元素设置颜色 */\n            &#125;\n            .demo1 > span&#123;\n            color: red;\n            /* 2.选择demo1 中下属的直接子元素（不包括子元素的后代） 可见只有demo1\n                下的子元素才有效果 demo1的孙子元素及其以后未被选中！\n            */\n          &#125;\n&#125;\n\n&lt;div class=\"demo1\">\n        &lt;span>Span #1, in the div.\n            &lt;span>Span #2, in the span that's in the div.&lt;/span>\n          &lt;/span>\n          &lt;span>我是demo中的第三个span子元素&lt;/span>\n    &lt;/div>\n2.后代元素选择器(2)后代元素选择器：选中指定元素中的后代元素\n\t\t\t语法：祖先 后代\n \t\tspan &#123;\n            color: aqua;\n            /* 1.给所有span元素设置颜色 */\n            &#125;\n\t\t em&#123;\n                color: aqua;\n        \t&#125;\n.demo2 span&#123;\n              color: red;\n              /* 可知此时选中了demo2中的所有span后代元素 包括demo2子元素的后代 \n                这一点适合子元素选择器不一样的\n                demo2中的后代em元素未被选中\n              */\n          &#125;\n&lt;div class=\"demo2\">\n        &lt;span>\n            深情隐现眉宇间，他人已知我相思。 --阴阳师\n            &lt;span>\n                深情隐现眉宇间，他人已知我相思。 --阴阳师\n            &lt;/span>\n        &lt;/span>\n        &lt;span>\n            深情隐现眉宇间，他人已知我相思。 --阴阳师\n            &lt;span>\n                深情隐现眉宇间，他人已知我相思。 --阴阳师\n                &lt;em>\n                    深情隐现眉宇间，他人已知我相思。 --阴阳师\n                &lt;/em>\n            &lt;/span>\n        &lt;/span>\n    &lt;/div>\n3.下一个兄弟元素选择器(3)选择下一个兄弟\n\t\t\t语法:前一个 + 下一个\n  .demo3 > :nth-child(2) + li&#123;\n              /* 选中demo3 的所有后代元素中的第2个后代 的下一个元素 */\n              color: red;\n              /* 可知兄弟选择器只选中第三个li子元素 即兄弟元素选择器选择指定的\n                    元素的下一个元素\n              */\n          &#125;\n&lt;ul class=\"demo3\">\n        &lt;li>南风知我意，吹梦到西洲。 --西洲曲&lt;/li>\n        &lt;li>南风知我意，吹梦到西洲。 --西洲曲&lt;/li>\n        &lt;li>南风知我意，吹梦到西洲。 --西洲曲&lt;/li>\n        &lt;li>南风知我意，吹梦到西洲。 --西洲曲&lt;/li>\n    &lt;/ul>\n4.所有兄弟元素选择器（4）选择下边所有兄弟\n\t\t\t语法：兄 ~ 弟\n #one ~ span&#123;\n              color: red;\n              /* 此时选中了 id 名为 one 的span元素后面同级的span兄弟（不包括兄弟的后代）   */\n          &#125;\n&lt;div class=\"demo4\">\n        &lt;span id=\"one\">曾经沧海难为水，除却巫山不是云。 --离思五首·其四&lt;/span>&lt;br>\n        &lt;span id=\"two\">曾经沧海难为水，除却巫山不是云。 --离思五首·其四\n            &lt;span id=\"three\">曾经沧海难为水，除却巫山不是云。 --离思五首·其四&lt;/span>\n        &lt;/span>\n        &lt;br>\n        &lt;span id=\"four\">曾经沧海难为水，除却巫山不是云。 --离思五首·其四&lt;/span>\n    &lt;/div>\n4.属性选择器属性选择器：选择指定属性的标签元素\n\t\t语法：（1）[属性名=属性值] 选择含有指定属性和指定元素值的标签\n如 p[name=\"box\"]&#123;\n    选择name值等于“box”的p标签\n&#125;\n\t\t（2）选择属性值以指定值开头的元素  [属性名^=属性名]\n如 p[name ^= \"box\"]&#123;\n    选择name值以“box”开头的p标签\n&#125;\n\t\t（3）选择属性值以指定值结尾的元素  [属性名 $= 属性值]\n如p[name $= \"box\"]&#123;\n    选择name值以“box”结尾的元素的p标签\n&#125;\n\t\t（4）选择属性值中含有某值的元素  [属性名 *= 属性值]\n如 p[name *= \"box\"]&#123;\n    选择name值中含有“box”的p标签\n&#125;\n5.伪类选择器伪类选择器：伪类 （不存在的类 特殊的类 伪类用来描述一个元素的特殊状态）\n\t\t\t\t\t\t如：第一个子元素 被点击的子元素等\n\t\t\t\t\t\t语法： : 开头\n\t\t\t   :first-child 第一个子元素\n                :last-child 最后一个子元素\n                :nth-child() 选中第n个子元素\n                    特殊值：\n                        n 第n个 n的范围0到正无穷\n                        2n 或 even 表示选中偶数位的元素\n                        2n+1 或 odd 表示选中奇数位的元素\n\n                    - 以上这些伪类都是根据所有的子元素进行排序\n\n                :first-of-type\n                :last-of-type\n                :nth-of-type()\n                    - 这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序\n\n            - :not() 否定伪类\n                - 将符合条件的元素从选择器中去除\n\n /* 使用伪类选择器 选择 类名为demo 的ul 中的第一个li子元素 */\n        .demo > li:first-child&#123;\n            /* 这里选择第一个子元素 */\n            color: yellow;\n            font-size: 20px;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的最后一个li子元素 */\n        .demo > li:last-child&#123;\n            /* 这里选择最后一个子元素 */\n            color: skyblue;\n            font-size: 50px;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的第奇数个li子元素 */\n        .demo > li:nth-child(2n+1)&#123;\n            /* 这里选择第奇数个子元素 */\n            background-color: red;\n        &#125;\n          /* 使用伪类选择器 选择 类名为demo 的ul 中的第偶数个li子元素 */\n          .demo > li:nth-child(2n)&#123;\n            /* 这里选择第偶数个子元素 */\n            background-color: gray;\n        &#125;\n          /* 使用伪类选择器 选择 类名为demo 的ul 中的第一个span子元素 */\n          .demo > span:first-of-type&#123;\n            background-color: orange;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的除最后一个span子元素 */\n        .demo > span:not(:last-child)&#123;\n           font-size: 30px;\n        &#125;\n\nexample： \n.first span:nth-child(2n+1)&#123;\n    /* 此时选择的是first类中的所有后代中 排在奇数位的span元素 \n    \t即如果此时first类中第三个直接子元素不是span类型的元素则不被选中\n    也就是所除了span元素外的后代元素也参与排列\n    */\n&#125;\n\n.first span:nth-of-type(2n+1)&#123;\n    /* 此时选中的是first类中的所有后代 排在奇数位的span元素\n    \t但是此时只有后代元素是span类型才参与排列\n    */\n&#125;\n\ndiv:only-child&#123;\n    /* 此时选择只有一个孩子元素的div中的孩子 */\n&#125;\n\nmain:only-of-type&#123;\n    /* 此时选中mian标签中 所有没有同类型兄弟的后代元素 */\n&#125;\n6.元素的伪类元素的伪类： 用于指定特殊元素 \n\t\t\t如 a标签的 link visited（这两个只有a标签能用） hover active\n  \t\t/* \n            :link 用来表示没访问过的链接（正常的链接）\n         */\n        a:link&#123;\n            color: red; \n        &#125;\n        /* \n            :visited 用来表示访问过的链接\n            由于隐私的原因，所以visited这个伪类只能修改链接的颜色\n        */\n        a:visited&#123;\n            color: orange; \n            /* font-size: 50px;   */\n        &#125;\n\n         button:hover&#123;\n             /* 点击按钮时按钮颜色变红 */\n             color: red;\n         &#125;\n\n         button:active&#123;\n             /* 点击按钮是按钮变大 */\n             width: 100px;\n         &#125;\n\n7.伪元素选择器伪元素选择器：\t表示页面中不真实存在的元素（特殊位置）\n\t\t\t\t伪元素 使用 :: 开头\n\t            ::first-letter 表示第一个字母\n                ::first-line 表示第一行\n                ::selection 表示选中的内容\n                ::before 元素的开始 \n                ::after 元素的最后\n                    - before 和 after 必须结合content属性来使用\n/* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的第一个字母 */\n        #demo::first-letter&#123;\n            /* 选中文本段第一个字母 */\n            font-size: 30px;\n            color: blue;\n        &#125;\n\n        /* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的开始 */\n        #demo::before&#123;\n            /* 选中文本段的起始 */\n            content: '##';\n        &#125;\n         /* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的末尾 */\n         #demo::after&#123;\n            /* 选中文本段的末尾 */\n            content: '##';\n        &#125;\n\n\t使用 ::before 和 ::after 时 加入的文本content也算第一个字母！！！","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"003-列表-超链接-图片-音视频","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/25/003-列表-超链接-图片-音视频/","content":"1.列表​    html中分为三种列表：有序，无序，定义列表\n&lt;!-- 无序列表 unordered list-->\n&lt;ul>\n    &lt;li>序号1&lt;/li>\n    &lt;li>序号2&lt;/li>\n    &lt;li>序号3&lt;/li>\n&lt;/ul>\n\n\n&lt;!-- 有序列表 ordered list-->\n&lt;ol>\n    &lt;li>无序1&lt;/li>\n    &lt;li>无序1&lt;/li>\n    &lt;li>无序1&lt;/li>\n&lt;/ol>\n\n&lt;!-- 定义列表 description list\n\t使用dl创建定义列表 使用dt表示定义名 dd对定义进行说明\n-->\n&lt;dl>\n    &lt;dt>定义名&lt;/dt>\n    &lt;dd>解释说明&lt;/dd>\n&lt;/dl>\n日常中多使用无序列表 ul标签 在li标签中可嵌套使用 ul标签 实现列表嵌套\n2.超链接​    使用超链接标签可是将页面跳转到指定页面 或者是当前页面的指定位置\n&lt;!-- \n\t使用a标签 \n\t\t使用属性href 指定跳转的目标 目标可以是指定网站 也可以是服务器内部页面（使用相对路径）\n\t\t超链接是一个行内元素 在a标签内可以嵌套除了自身外的所有标签\n-->\n&lt;a href=\"http://www.baidu.com\">这是一个超链接&lt;/a>\n\n&lt;!--\n\thref 的target属性：\n\t\t_self: 超链接的默认属性 不写也可 效果为在当前网页打开链接\n\t\t_blank: 保留当前页面 在新的页面打开链接\n\t\n\thref的几个常用值：\n\t\t1.javascript:;  -> 此时点击链接什么都不会发生\n\t\t2.#  -> 此时点击链接会自动回到网页顶部\n\t\t3.标签id -> 此时点击链接将跳转到指定id标签的位置 使用标签id时 尽量不要重复id\n-->\n&lt;a href=\"www.baidu.com\" target=\"_blank\">点我在新页面打开链接&lt;/a>\n\n3.图片标签​    使用 img 标签向当前页面引入图片资源（外部图片）img 标签属于替换元素（介于块元素和内联元素之间）\n​    img 标签 默认不会独占一行\n&lt;!-- \n\timg是自结束标签\n\timg 的属性：\n\t\t1.src：用于引入外部图片路径\n\t\t2.alt: 图片的描述 当浏览器加载不到图片时显示alt 搜索引擎使用alt来识别图片\n\t\t3.width: 图片的宽度（px）\n\t\t  height: 图片的高度 当图片的宽度或高度变化时 图片将按等比例缩放图片宽高\n-->\n&lt;img src=\"在这里引入图片路径\" width=\"200px/可不带单位\" alt=\"这是图片的描述\">\n\nsrc的资源路径可以是base64编码字符串\n\n4.内联框架​    使用 iframe 标签 用于在该页面引入其他页面 iframe 元素属于行内元素\n&lt;!--\n\tiframe 属性：\n\t\t1.src：用于引入网页路径\n\t\t2.frameborder：指定内联框架的边框\n-->\n&lt;iframe src=\"https://www.bilibili.com\" width=\"1000\" height=\"600\" frameborder=\"1\">不支持iframe时将显示这行字！&lt;/iframe>\n5.音视频​    使用 audio 标签在页面引用外部音频文件\n&lt;!--\n        属性：\n            controls 是否允许用户控制播放 默认情况下不允许用户自己控制播放停止\n            autoplay 音频文件是否自动播放\n                - 如果设置了autoplay 则音乐在打开页面时会自动播放\n                    但是目前来讲大部分浏览器都不会自动对音乐进行播放 \n            loop 音乐是否循环播放\n\t\t\n\t\t还可通过在标签内使用source标签引入音频资源 这样的好处是可以是浏览器兼容解析合适的文件\n\t\t\t还可以在这里写入浏览器不支持audio标签的提示\n\t\tembed标签为IE8以下的浏览器所解析使用\n\n\t\tsource 和 embed 标签均为自结束标签！ \n\t\tembed 标签内 的type 为map 匹配 文件类型（audio/video）/文件后缀（mp3/mp4）\n-->\n&lt;audio src=\"./source/这里是路径.mp3\" controls autoplay loop>&lt;/audio>\n &lt;audio controls>\n        &lt;source src=\"./source/audio.mp3\">\n        &lt;source src=\"./source/audio.ogg\">\n        &lt;embed src=\"./source/audio.mp3\" type=\"audio/mp3\" width=\"300\" height=\"100\">\n     \t&lt;!--以上资源默认从上往下解析 对不起，您的浏览器不支持播放音频！请升级浏览器！ -->\n &lt;/audio>\n\n&lt;!-- \n        使用video标签来向网页中引入一个视频\n            - 使用方式和audio基本上是一样的\n     -->\n &lt;video controls>\n        &lt;source src=\"./source/flower.webm\">\n        &lt;source src=\"./source/flower.mp4\">\n        &lt;embed src=\"./source/flower.mp4\" type=\"video/mp4\">\n    &lt;/video>\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"002-语义化标签","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/23/002-语义化标签/","content":"1.语义化标签​    在使用html标签时关注标签的语义而不是样式，网页的样式由css文件决定；\n2.块元素​    块元素都是独占一行\n&lt;!-- \n\th1~h6六级标题都是块内元素 （block element）\n\t一般在行元素内不会放块元素\n           -->\n&lt;hgroup>使用该标签可以将标题分组，将同一组标题放入到hgroup中&lt;/hgroup>\n\n&lt;p>\n    p标签也是块元素 在p标签中不使用任何块元素\n&lt;/p>\n\n3.行内元素/内联元素页面中不会独占一行的称为行内元素（inline element）\n&lt;em>斜体标签 用于将选中的文本把变为斜体&lt;/em>\n&lt;strong>用于加粗选中的字体&lt;/strong>\n&lt;blockquote>\n    长引用 使用时会自动将选中的文本缩进且换行\n&lt;/blockquote>\n&lt;q>短引用 将选中的文本加引号强调&lt;/q>\n&lt;br> 换行标签 可连用\n4.结构化语义化标签​    html5新提供的结构化语义标签都属于块元素 效果都和div相同 常使用div标签\n&lt;!-- \n        header 表示网页的头部\n        main 表示网页的主体部分(一个页面中只会有一个main)\n        footer 表示网页的底部\n        nav 表示网页中的导航\n        aside 和主体相关的其他内容（侧边栏）\n        article 表示一个独立的文章\n        section 表示一个独立的区块，上边的标签都不能表示时使用section\n\n        div 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素\n        span 行内元素，没有任何的语义，一般用于在网页中选中文字\n\n      -->\n     &lt;header>头部&lt;/header>\n     &lt;main>主体&lt;/main>\n     &lt;footer>底部&lt;/footer>\n     &lt;nav>导航&lt;/nav>\n     &lt;aside>侧边栏&lt;/aside>\n     &lt;article>文章&lt;/article>\n     &lt;section> 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;/section>\n\n\tdiv和span较常用\n     &lt;div>&lt;/div>\n     &lt;span>&lt;/span>\n注意 若将标签写在根元素之外时 浏览器解析时会自动修改 但不一定会达到想要的效果\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"001-实体-meta标签","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/23/001-实体-meta标签/","content":"1.HTML结构​    HTML结构可分为以下三部分：\n&lt;html>\n    &lt;head>\n        &lt;!--在这里可以使用meta title标签 -->\n    &lt;/head>\n    &lt;body>\n        \n    &lt;/body>\n&lt;/html>\n2.HTML5的标识​    在html文件开头使用标签来区分html4与5的区别\n​    文档声明用来告诉浏览器当前网页的版本\n​        - html5的文档声明\n &lt;!doctype html>\n\n&lt;!Doctype HTML>\n3.HTML编码字符集​    常见的字符集：\n​        ASCII\n​        ISO88591\n​        GB2312\n​        GBK\n​        UTF-8，在开发时我们使用的字符集都是UTF-8\n4.meta标签​    该标签在主要用于设置一些网页中的元数据，元数据用于网站的搜索引擎检索，可以在此标签内指定网页的编码字符集，如下代码：\n&lt;!-- \n       meta主要用于设置网页中的一些元数据，元数据不是给用户看\n           charset 指定网页的字符集\n           name 指定的数据的名称\n           content 指定的数据的内容\n\n            keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开\n                 \n             description 用于指定网站的描述\n                   \n              网站的描述会显示在搜索引擎的搜索的结果中\n\n               title标签的内容会作为搜索结果的超链接上的文字显示  \n\t&lt;meta name=\"keywords\" content=\"HTML5,前端,CSS3\">\n    \t&lt;meta name=\"description\" content=\"这是一个非常不错的网站\">\n\t&lt;title>这是标题&lt;/title>\n\t&lt;meta> 标签支持 HTML 中的全局属性。\n    -->\n\t\n使用meta标签有http-equiv, name,scheme 属性可选 其对应的content值具体参照文档\n5.实体标签​    在 HTML 中，某些字符是预留的。\n​    在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。\n​    如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。\n使用方法： &amp;需转义的字符;(&amp; ;均是英文符号)\n常用的转义字符：\n\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"计算机网络复习","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/07/08/计网复习/","content":"期末计网复习重点第一章 计算机网络概述1.三网融合的概念从电信网络（向用户提供电话，电报及传真等服务），有线电视网（传送各种电视节目）和计算机网络（在计算机之间传送数据）三种各自分工到将电信网络和有线电视网络融入现代计算机网络，将三种网络融合成一种网络就能提供所有服务。\n2.计算机网络的定义及其分类定义：计算机网络主要是由一些通用的，可编程的硬件互连而成，而这些硬件并非专门用来实现某一特定目标，这些可编程的硬件能够用来传送各种不同类型的数据，并能支持广泛的和日益增长的应用。\n分类：按作用范围可分为：广域网（WAN），城域网（MAN），局域网（LAN），个人区域网（PAN）及无线个人区域网（WPAN）；\n按使用者类型可分为：公用网和专用网；\n3.互连网的定义和组成定义：计算机网络（网络）由若干结点和连接这些结点的链路组成。利用路由器将这些网络互连起来组成的网络叫做互连网（互连网是网络的网络）；\n组成：分为边缘部分和核心部分；\n边缘部分：由所有连接在互连网的主机组成，这部分是用户直接使用的，用来进行通信和资源共享。\n核心部分：由大量的网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的。\n4.客户-服务器通信方式（C/S方式）客户是服务请求方，服务器是服务提供方；（B/S方式是C/S方式的一种特例）这种方式的通信是双向的。\n5.分组交换，电路交换，报文交换路由器是实现分组交换的关键构件，其任务是转发收到的分组。\n交换是按照某种方式动态的分配传输路线的资源。\n通常把要发送的整块数据称为一个报文；\n在发送报文之前，把较长的报文划分为一个个更小的等长数据段，在数据段的前面加上一些由必要的控制信息组成的首部（包头，首部包含了目的地的地址和源地址等重要控制信息）后就构成了一个分组；\n电路交换：建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）；电路交换的用户在通话始终占用端到端的通信资源；\n分组转发采用存储转发技术；\n电路交换：整个报文的比特流连续的从源点直达终点；\n报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。\n分组交换：单个分组（报文的一部分）传送到相邻的结点，存储下来后查找转发表转发到下一个结点。\n若要连续传送大量数据且其传送时间远大于连接建立时间选择电路交换，在传送突发数据时选择报文交换和分组交换，分组交换比报文交换具有更好的灵活性和更低的时延性。\n6.计算机网络性能指标速率：数据的传送速率（数据率、比特率，bit/s）\n带宽：在计算机网络中，网络带宽表示在单位时间内网络中的某信道所能通过的最高数据率（bit/s）；\n吞吐量：表示在单位时间内通过某个网络的实际的数据量。\n时延：指数据从网络的一端到另一端所需的时间。\n​        （1）发送时延：指主机或路由器发送数据帧所需要的时间。发送时延=数据帧长度（bit）/发送速率（bit/s）；\n​        （2）传播时延：电磁波在信道中传播一定距离所花费的时间。传播时延=信道长度(m)/电磁波在信道上的传播速率(m/s)；\n​        （3）处理时延：主机或路由器在收到分组时需要花费一定时间进行处理；\n​        （4）排队时延：分组在经过网络传输时，要经过许多路由器，在进入路由器后要先在输入队列中排队等待处理。\n​        总时延=发送时延+传播时延+处理时延+排队时延\n时延带积宽：时延带积宽=传播时延*带宽\n往返时间RTT：双向交互一次所需的时间；\n信道利用率:指出某信道有百分之几的时间是被利用的；\n网络利用率：全网络的信道利用率的加权平均值；\n信道或网络的利用率过高会产生非常大的时延；\n7.分层、透明分层：相互通信的两个计算机系统必须高度的协调工作，分层可将庞大而复杂的问题转化为若干较小的局部问题，这些较小的问题易于研究和处理。\n透明：指存在但不干预即：计算机中存在的,但对于某些人员而言又不需要了解的东西,这就是计算机所指的透明性.简单的说就是:计算机中存在,但你不需要了解的.使用本层服务的实体只能看见服务而无法看见下面一层的协议。集协议对上层实体是透明的。\n8.网络协议、实体、服务、服务访问点网络协议：为进行网络中的数据交换而建立的规则，标准或约定称为网络协议（协议）；协议是控制两个对等（或对个）实体进行通信规则的集合；在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，要实现本层协议需要使用下面一层的提供的服务。\n实体：表示任何可发送或接受信息的硬件或软件进程；\n服务：协议是水平的，服务是垂直的，服务是由下层向上层通过层间接口提供的，只有那些能被上层实体看见的功能才称为服务；\n服务访问点：在同一系统中相邻两层的实体进行交互的地方；\n9.体系结构计算机网络的各层及其协议的集合就是网络的体系结构，是这个计算机网络及其所有构件所应完成的功能的精确定义。\n\n应用层：直接为用户的应用进程提供服务；通过应用进程间的交互来完成特定网络应用。应用层交互的数据单元称为报文；\n运输层：负责向两台主机中的进程之间的通信提供通用的数据传输服务；\n​                运输层主要使用以下两种协议：\n​                （1）传输控制协议TCP：提供面向连接的，可靠的数据传输服务，其数据传输单位是报文段；\n​                （2）用户数据报协议UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报；\n网络层：负责为分组交换网上的主机提供通信服务；\n数据链路层：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送帧。使每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）；\n物理层：物理层的任务就是透明地传送比特流。为数据端设备提供传送数据的通路；传输数据；在物理层上所传送的数据单位是比特；\n\n\n第二章 物理层1.物理层的四大规程物理层考虑的是怎样在连接各种计算机的传输媒体上传输数据比特流；物理层的协议称为规程，物理层的主要任务是确定与传输媒体的接口有关的一些特性；数据在通信线路（传输媒体）上的传输一般为串行传输；\n机械特性：指明接口所用的接线器的形状和尺寸，引脚数目和排列，固定和锁定装置等；\n电气特性：指明在接口电缆的各条线上出现的电压的范围；\n功能特性：指明某条线上出现的某一电平的电压的意义；\n过程特性：指明对于不同功能的各种可能事件的出现顺序；\n2.通信基础知识数据是运送消息的实体；\n信号是数据的电气或电磁的表现；可分为模拟信号（连续信号，消息的参数的取值是连续的），数字信号（离散信号，消息的参数的取值是离散的）；\n信道：表示向某一个方向传送信息的媒体，一条通信电路往往包含一条发送信道和接受信道；\n调制：数字比特流转换为模拟信号；（基带调制：数字信号到数字信号；带通调制：数字信号到模拟信号）\n解调：模拟信号转换为数字比特流；\n调制方法：调频、调幅、调相；\n从通信双方信息交互的方式可分为：单工通信（电视广播，只有一个方向）、半双工通信（双向交替通信需要两条信道）、全双工通信（双向同时通信需要两条信道）；\n曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1，反过来定义也可以；\n差分曼彻斯特编码：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1；\n基本的带通调制方法\n​    （1）调幅（AM）：载波的振幅随基带数字信号而变化；\n​    （2）调频（FM）：载波的频率随基带数字信号而变化；\n​    （3）调相（PM）：载波的初始相位随基带数字信号而变化；\n3.常见的有线传输介质双绞线：\n​        568a的排线顺序从左到右依次为：白绿、绿、白橙、蓝、白蓝、橙、白棕、棕。 568b则为：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕。​        正线，即直通线 ，标准568B）：两端线序一样，从左至右线序是：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。​        反线，即交叉线 ，（568A）：一端为正线的线序，另一端为从左至右：白绿，绿，白橙，蓝，白蓝，橙，白棕，棕。​        交叉线是指：一端是568a标准，另一端是568b标准的双绞线；​        直连线则指：两端都是568a或都是568b标准的双绞线。​        相同设备用直通线，不同设备用交叉线，除了主机和路由器用交叉线；​        反线也是交叉线；同轴电缆（利用光的全反射）光缆：多模光纤适用于短距离传输、单模光纤使用远距离传输\n4.复用技术复用：上层多个进程可同时使用下面层提供的服务；\n分用：下层将收到的数据分别交付给上层相应的进程；\n频分复用：所有用户在同样的时间内占用不同的带宽资源（频率带宽）；\n时分复用（同步时分复用）：所有用户在不同的时间占用同样的频带宽度；有利于数字信号传输；\n统计时分复用（异步时分复用）：改进的时分复用，提高信道利用率；\n波分复用：光的频分复用（利用光的波长）；\n码分复用（码分多址）：每一个用户可以在同样的时间使用同样的频带进行通信，不同的码型可避免干扰；\n​        将码片（每一个比特时间再划分为m个短的间隔）的0记为**-1，将1记为+1**；\n​        CDMA系统内每个站分配的码片序列各不相同且正交（内积为0）；每个码片与自己本身内积为1；每个码片和自己的反码内积为**-1**；\n5.有线宽带接入技术ADSL技术（非对称数字用户线技术）：是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务；\nHFC网（光纤同轴混合网）：在有线电视的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话，数据和其他宽带交互型业务；\nFTTx技术：为提高居民的上网速率提出FTTH技术（光纤到户技术），从而出现了多种宽带光纤接入技术FTTx，就是把光电转换的地方从用户家向外延伸到离用户家门口有一定距离的地方（从H到x）；\n\n第三章 数据链路层点对点信道：使用一对一的点对点通信方式的信道；\n广播信道：使用一对多的广播方式的信道；\n局域网属于数据链路层范围，在同一个局域网中，分组从一台主机转发到另一台主机不经过路由器转发；\n链路：从一个结点到相邻结点的一段物理线路（有线或无线），中间没有其他交换节点；\n帧：数据链路层的协议数据单元；由帧首部+数据部分（IP数据报）+帧尾部构成；\n数据链路：具有必要的通信协议（控制数据传输）的软硬件构成的链路；常使用网络适配器来实现这些协议；数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出上交到网络层，网络层的协议数据单元是IP数据报（数据报，分组，包）；\n1.数据链路层三个基本问题封装成帧：就是在一段数据的前后分别添加首部和尾部\n​      首部和尾部的一个很重要的作用就是进行帧定界（帧定界符的控制字符SOH(十六进制 01)放在帧的最前面，表示帧的开始，EOT(十六进制 04)放在帧尾，表示帧的结束）此外，首部和尾部还包括许多必要的控制信息。发送帧时从帧首部开始发送；\n透明传输：\n​     “透明”表示某个实际存在的事物看起来却好像不存在一样,在数据链路层透明传送数据表示无论什么样的比特组合的数据，都能够按照原样没有差错的通过数据链路层；\n​      解决透明传输的办法是字节填充（字符填充）：\n​        1.发送端的数据链路层在数据中出现了控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”（其16进制为1B），而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。\n​        2.如果转义字符也出现在数据当中，那么就在转义字符前面插入一个转义字符，当接收端收到两个连续的转义字符时，就删除其中前面的一个。\n差错检测（CRC循环冗余校验）：\n比特差错：在传输过程中可能会产生差错，0变成1或1变成0；\n传输差错：帧丢失，帧重复，帧失序；\n【例子】：除数M为101001 除数P（x）=X3+X2+1 此时除数P=1101\n​    被除数后要补比除数位数少一个0，这里为4-1=3个0\n​    在运算过程中不借位，余数最高位位为1则上1。\n则发送的数据为101001001\n在接收端对收到的每一帧经过CRC检验后，有两种情况：\n​    1.若得出余数为0，则判定这个帧没错，接受\n​    2.若余数不为0，则判定这个帧有差错（但无法确定是哪里出现了差错），丢弃\n注意：CRC不是“可靠传输”，只能做到无差错接受，即“若只在数据链路层使用CRC差错检测技术，凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”；\n2.点对点协议PPPPPP协议是用户计算机和ISP进行通信时所使用的的数据链路层协议；\nPPP协议的特点：\n（1）简单：他提供不可靠的数据包服务，对于数据链路层的帧不需要纠错，不需要序号，也不需要流量控制（只进行CRC检验，正确就收下，错误就抛弃）；\n（2）封装成帧：规定特殊的字符作为帧定界符；将数据报封装成帧；\n（3）透明性：保证数据传输时的透明性；\n（4）多种网络协议：必须能够在同一条物理链路上同时支持多种网络层协议（如IP和IPX）；\n（5）多种类型链路：必须能够在多种链路上运行（串行的，并行的，同步的，异步的等）；\n（6）差错检测：必须能够对接收端收到的帧进行检测，并立即抛弃有差错的帧；\n（7）检测连接状态：必须具有自动检测链路是否处于正常工作状态的机制；\n（8）最大传送单元：必须对每一种类型的点链路设置最大传送单元（MTU）的标准默认值；\n（9）网络层地址协商：必须提供一种使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址的机制；\n（10）数据压缩协商：必须提供一种方法来协商使用数据压缩算法；\nPPP协议的组成：一个将IP数据报封装成串行链路的方法；一个用来建立，配置和测试数据链路连接的链路控制协议LCP；一套网络控制协议NCP；\n3.局域网常见拓扑星型网、环形网、总线网；\n4.网卡的功能计算机与外界局域网的连接是通过通信适配器进行的。在主机箱内插入的一块网络接口板又称为网络接口卡NIC（网卡）；\n适配器的一个重要功能是进行数据串行传输和并行传输的转换。对数据进行缓存，在计算机的操作系统安装设备驱动程序；\n适配器还要能够实现以太网协议；\n5.CSMA/CD在同一时间内只能允许一台计算机发送数据，因此采用一种协调协议CSMA/CD（载波监听多点接入/碰撞检测）;\n工作原理：载波监听（检测信道）；信道忙时停止发送（忙则等待），信道空闲时才进行发送；碰撞检测（边发送边监听，若发生碰撞则暂停）；使用截断二进制指数退避算法确定碰撞后重传时机；发送强干扰信号强化碰撞；\n6.MAC地址、MAC帧格式、无效帧无效帧：凡长度小于64字节的帧都是由于冲突而异常中止的无效帧\nMAC地址：在局域网中，硬件地址又称为物理地址或MAC地址；实际上就是适配器地址或适配器标识符；\nMAC帧格式：两种标准，一种是DIX Ethernet V2标准，一种是IEEE 802.3标准；\n以太网V2的Mac帧由五个字段组成，前两个字段分别为6字节长的目的地址和源地址，第三个字段是2字节的类型字段（标志上一层使用的协议），第四个字段是数据字段，第五个字段是四字节长的帧检验序列FCS；\n\n7.集线器、网桥的工作原理集线器：以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，集线器类似于一个多接口的转发器，集线器工作在物理层，它的每个接口仅仅简单地转发比特；\n网桥的工作原理：多接口的网桥实质就是交换机；网桥对收到的帧根据其MAC帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是根据此帧的目的MAC地址，查找网桥中的地址表，然后确定将该帧转发到哪一个接口，或者是把它丢弃。\n网桥带来的好处：1.过滤通信量；\n​                            2.扩大了物理范围；\n​                            3.提高了可靠性；\n​                            4.可互连不同的物理层、不同的MAC子层和不同速率的局域网；\n8.虚拟局域网的概念、原理虚拟局域网的概念：VLAN是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪个VLAN；\n虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN标记。\n原理：VLAN中的端口成员不是按照物理地址划分的，所以一个VLAN也可以跨越多台物理交换机，这就是VLAN中继(Trunk)功能，在不同的交换机上可以有相同的VLAN，而且不同交换机上相同的VLAN是可以相互通信的，可以把相同的VLAN在不同物理交换机在逻辑上看作存在物理连接，因此自然可以相互通信。\n\n第四章 网络层1.网络层提供的两种服务\n\n\n对比的方面\n虚电路服务\n数据报服务\n\n\n\n思路\n可靠通信应当由网络来保证\n可靠通信应当由用户主机负责\n\n\n连接的建立\n必须有\n不需要\n\n\n重点地址\n仅在建立连接时使用，每个分组使用短的虚电路号\n每个分组都有终点的完整地址\n\n\n分组的转发\n属于同一条虚电路的分组均按照同一路由进行转发\n每个分组独立选择路由进行转发\n\n\n当结点出故障时\n所有通过出故障的结点的虚电路均不能工作\n出故障的结点可能会丢失分组，一些路由可能会发生变化\n\n\n分组的顺序\n总是按发送顺序达到终点\n达到终点的时间不一定按发送顺序\n\n\n端到端的差错处理和流量控制\n可以由网络负责，也可以由用户主机负责\n由用户主机负责\n\n\n2.IP地址IP地址：: :={&lt;网络号&gt;,&lt;主机号&gt;}\nIP地址在全世界范围内是唯一的32位的标识符；一个网络号在整个互联网范围内必须是唯一的；一台主机号在其网络号声明的网络范围内必须是唯一的；\nIP地址是一种分等级的地质结构。IP地址管理机构在分配IP地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号来转发分组。\n分类的IP地址是由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别为指明IP地址的类别。\n一个IP地址在整个互联网范围内是唯一的。分类的IP地址包括A类、B类和C类地址（单播地址），以及D类地址（多播地址）。E类地址未使用。A类    1126    B类128191        C    192223        D    224239        127用于环路测试\n3.ARP协议（地址解析协议）的原理地址解析协议ARP把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。ARP的高速缓存可以大大减少网络上的通信量。\nARP步骤：        1.ARP进程在本局域网上广播发送一个ARP请求分组。\n​        2.在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组。\n​        3.若有主机的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向(发送ARP请求分组的)主机发送ARP相应分组，同时在这个ARP相应分组中写入自己的硬件地址。由于区域的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理财这个ARP请求分组。（注意：ARP请求分组是广播发送，但ARP响应分组是单播的）。\n​        4.(发送ARP请求分组的)主机接收到ARP响应分组后，就在其ARP高速缓存中写入响应主机的IP地址到硬件地址的映射。\n4.IP协议首部格式\n首部的固定部分长度固定为20字节，固定部分后面的是可选字段，长度可变；\n版本：占4位，值IP协议的版本；\n首部长度：占4位，可表示的最大十进制数是15；\n区分服务：占8位，用来获得更好的服务；\n总长度：指首部和数据之和的长度，占16位；可表示的数据报最大长度为65535字节；\n标识：占16位，相同的标识字段的值使分片后的各数据报片最后能正确的重装为原来的数据报；\n标志：占3位，MF=1表示后面还有分片，MF=0表示这是最后一个分片；DF=0表示不能分片，等于0时才能分片；\n片漂移：占13位，片漂移指出较长的分组在分片后某片的在原分组的相对位置；\n5.分组转发算法(1)从数据报的首部提取目的主机的IP地址D,得出目的网络地址为N.\n(2)若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机(这里包括把目的主机地址D转换为具体的硬件 地址，把数据报封装为MAC帧，再发送此帧)；否则就是间接交付，执行(3)。\n(3)若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。\n(4)若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(5)。\n(5)若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。\n(6)报告转发分组出错。\n6.划分子网在IP地址中添加子网号字段，使两级IP地址变为三级IP地址；从主机号借用若干位作为子网号，主机号也相应减少同样的位数；\nIP地址  : :={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}\n\n7.无分类编址CIDR（构造超网）IP地址 : :={&lt;网络前缀&gt;,&lt;主机号&gt;}\n​        无分类域间路由选择CIDR是解决目前IP地址紧缺的一个方法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所占的位数，如（128.14.5.7/20）。前缀用来指明网路，前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”。IP地址的分配都以CIDR地址块为单位；\n​        CIDR的32位地址掩码（子网掩码）由一串1或一串0组成，而1的个数就是前缀的长度。只要把IP地址和地址掩码逐位进行“逻辑与(and)”运算，就很容易得出网络地址。A类地址的默认地址掩码是255.0.0.0。B类地址的默认地址掩码是255.255.0.0。C类地址的默认地址掩码是255.255.255.0；\n8.最长前缀匹配查找路由表时应当从匹配结果中选择具有最长网络前缀的路由；\n9.二叉线索查找路由表先找出对应于每一个IP地址的唯一前缀，通过唯一前缀构造二叉线索；\n10.ICMP（网际控制报文协议）在网际层使用ICMP协议提高IP转发数据报和提高交付成功的机会；ICMP报文是装在IP数据报中，作为其中的数据部分；\nICMP报文分为ICMP差错报告报文和ICMP询问报文；\n\n\n11.IPv6概念及地址长度由于IPv4的地址已耗尽，所以有了IPv6；IPv6的地址使用冒号十六进制记法；IPv6数据报的目的地址可以是一下三种基本类型地址之一：单播，多播，任播。IPv6数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所以的扩展首部和数据；结合起来叫做数据报的有效载荷或净负荷。IPv6主要带来的变化是：1更大的地址空间；2 灵活的首部格式；3 改进的选项；4支持即插即用；5支持资源的预分配；6 IPv6的首部改为8字节对齐。IPv6的地址长度是128位地址（补充IPv4是32位，MAC是48位）；\n12.静态路由、路由选择协议（RIP、OSPF）静态路由选择也叫非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。\n互联网把路由选择协议划分为内部网关协议IGP和外部网关协议EGP；\n内部网关协议RIP（路由信息协议），很少被使用，RIP是一种分布式的基于距离向量的路由选择协议；优点是简单；RIP协议的距离也称为跳数；距离等于16时相当不可达，RIP只适应于小型互联网；\n\nRIP协议特点：\n1仅和相邻的路由器交换信息；\n2交换的信息是当前本路由器所知道的全部信息，即自己的路由表；\n3按固定时间间隔交互信息。\n距离向量算法：1 从相邻的 X 路由器接收发送过来的 RIP（Routing Information Protocol） 报文；2 将该 RIP 报文中的下一跳地址修改为 X，且跳数增加 1；3 对每个项目执行如下步骤；    a.若原路由表没有 RIP 中的目的网络 N，直接添加到原路由表中；    b.若原路由表中有 RIP 中的目的网络 N，但下一跳地址不是 X ，选择跳数少的替换。如果两者跳数一样，则保留原路由表的项。    c.若原路由表中有 RIP 中的目的网络 N，且下一跳地址是 X，使用收到的项替换；4若超过 180s （RIP 默认 180s）还没有收到相邻路由器的更新路由表，则相邻路由器置为不可达，跳数为 16；\n\n内部网关协议OSPF（开放最短路劲优先）\nOSPF：OSPF使用分布式的链路状态协议。OSPF的更新过程收敛的快；特点：\n1.向本自治系统中所有路由器发送信息，采用洪泛法；\n2.发送的信息就是与本路由器相邻的所有路由器的链路状态；\n3.当链路状态发生变化时才回发送信息；\n\nRIP配置过程Router（config）#router ripRouter（config- router）#version 2Router（config- router）#network 192.167.100.0（ip地址）Router（config- router）#network 10.1.1.0Router（config- router）#no auto-summaryOSPF配置过程Router（config）#router ospf 1Router（config- router）#network 10.1.1.0  0.0.0.255  area 0\n\n13.路由器的组成和工作原理路由器结构可划分为两大部分：路由选择部分和分组转发部分；\n路由选择部分也叫做控制部分，其核心构件是路由选择处理机，它的任务是根据路由协议构造，更新和维护路由表；\n分组转发部分又三部分组成：交换结构，一组输入端口和一组输出端口，这里的端口是硬件接口；\n交换结构的任务就是根据转发表对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去；\n14.VPN 的原理，NAT 和 NAPT 的作用专用地址（内部地址）只能用于一个机构的内部通信，不能用于和互联网上的主机通信；\n虚拟专用网VPN：利用共用的互联网作为本机构各专用网之间的通信载体。三个专用地址块：（1）10.0.0.0到10.255.255.255（24位块）（2）172.16.0.0到172.31.255.255（20位块）（3）192.168.0.0到192.168.255.255（16位块）两个专用网之间通过IP隧道进行通信。网络地址转换NAT的作用是：它实现内网的IP地址与公网的地址之间的相互转换，将大量的内网IP地址转换为一个或少量的公网IP地址，减少对公网IP地址的占用。网络地址与端口号转换NAPT（实际上就是使用端口号的NAT）；\n\n第五章 运输层1.运输层的功能运输层向它上面的应用层提供通信服务，运输层为应用进程间提供端到端的逻辑通信；运输层具有复用（发送方不同的应用进程都可以使用同一个运输层协议传送数据）和分用（接收方的运输层在剥去报文的首部后能够把数据正确交付应用进程）功能；\n2.运输层的端口为了在通信中识别主机的应用进程，在运输层使用协议端口号，这是一种软件端口，端口只具有本地意义；\n\n3.UDP的特点、首部格式用户数据报协议UDP的特点：\n1.UDP是无连接的；\n2.UDP使用尽最大努力交付，不保证可靠交付；\n3.UDP是面向报文的；\n4.UDP没有拥塞控制；\n5.UDP支持一对一，一对多，多对一和多对多的交互通信；\n6.UDP的首部开销小只有8字节；\nUPD的首部格式：\n1.源端口：源端口号。在需要对方回信时选用，不需要时全为0；\n2.目的端口：目的端口号，在终点交付报文时使用；\n3.长度：UDP用户数据报的长度，最小值为8；\n4.检验和：检测UDP用户数据报在传输中是否有错，有错就丢弃；\n\n\n4.TCP的特点、可靠传输实现传输控制协议TCP的特点：\n1.TCP是面向连接的运输层协议；\n2.每一条TCP连接只能有两个端点。每一条TCP连接只能是点对点的；\n3.TCP提供可靠交付的服务；\n4.TCP提供全双工通信；\n5.面向字节流；\nTCP连接的端口叫套接字或插口；\n套接字 socket = （IP地址：端口号）\n每一条TCP连接唯一的 被通信两端的两个端点（即两个套接字）所确定；\nTCP连接 : : ={socket1，socket2} = {（IP1：port1），（IP2：port2）}\n可靠传输的实现：停止等待协议，连续ARQ协议；\n\nTCP报文段的首部格式：首部的前20个字节是固定的，所以TCP首部最小长度是20字节；\n\n\n首部固定部分各字段意义如下：\n1） 源端口和目的端口：各占2个字节，分别写入源端口和目的端口。\n2） 序号：占4字节。序号范围是【0，2^32 - 1】，共2^32（即4294967296）个序号。序号增加到2^32-1后，下一个序号就又回到0。也就是说，序号使用mod 2^32运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。\n3） 确认号      占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。\n   总之：若确认号为= N，则表明：到序号N-1为止的所有数据都已正确收到。\n\n4） 数据偏移         占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。\n5） 保留          占6位，保留为今后使用，但目前应置为0 。\n下面有6个控制位，用来说明本报文段的性质。6） 紧急URG（URGent）        当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。\n   当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。\n\n7） 确认ACK（ACKnowledgment）      仅当ACK = 1时确认号字段才有效，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。\n8） 推送 PSH（PuSH）    当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。\n9） 复位RST（ReSeT）       当RST=1时，表名TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。\n10） 同步SYN（SYNchronization）       在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。\n11） 终止FIN（FINis，意思是“完”“终”）          用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。\n12） 窗口             占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。\n  例如，发送了一个报文段，其确认号是701，窗口字段是1000.这就是告诉对方：“从701算起，我（即发送方报文段的一方）的接收缓存空间还可接受1000个字节数据（字节序号是701~1700），你在给我发数据时，必须考虑到这一点。”\n\n  总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。\n\n13） 检验和       占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。\n14） 紧急指针            占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。\n15） 选项       长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。\n   TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie）。注意MSS这个名词含义。MSS是每一个TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。\n\n   为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）才能组装成一个IP数据报。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。\n\n   因此，MSS应尽可能大些，只要在IP层传输时不需要分片就行。由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要的分片的MSS，如果改走另一条路径就可能需要进行分片。因此最佳的MSS是很难确定的。在连接过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传输数据，两个传送方向可以有不同的MSS值。若主机未填写这一项，则MSS的默认值是536字节长。因此，所有在互联网上的主机都应该接受的报文段长度是536+20（固定首部长度）=556字节。\n\n后来又增加了几个选项如窗口扩大选项、时间戳选项等。\n  窗口扩大选项是为了扩大窗口。我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。\n\n   窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2^（16+14）-1=2^30-1。\n\n   窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=0选项，使窗口大小回到16。\n\n时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念：\n  第一、 用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。\n\n   第二、 用于处理TCP序号超过2^32的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加2^32个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。例如，当使用1.5Mbit/s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。\n\n\nTCP可靠传输的实现\n\nTCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。\nTCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。\nTCP 两端的四个窗口经常处于动态变化之中。\nTCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。\n\n1.以字节为单位的滑动窗口技术；\n2.超时重传时间的选择 ；\n3.改进的确认——选择确认(SACK)；\nTCP的流量控制：让发送方的发送速率不要太快，要让接收方来得及接受；（利用滑动窗口来实现）\n5.TCP的拥塞控制拥塞：在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏；\n拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载；这是一个全局性的过程；\nTCP的拥塞控制方法：慢开始，拥塞避免，快重传，快恢复；\n6.随机早期检测算法 RED 算法主动队列管理：当路由器的队列长度达到某个警惕值时主动丢弃到达的分组；（利用RED算法实现）\nRED算法：使路由器维持队列最小门限和最大门限两个参数；按规定计算当前的平均队列长度；\n（1）若平均队列长度小于最小门限，则将新到达的分组放入队列进行排队；\n（2）若平均队列长度大于最大门限，则将新到达的分组丢弃；\n（3）若平均队列长度处于最小门限和最大门限之间，则按某一丢弃概率p丢弃新到达的分组；\n7.TCP连接的管理TCP的运输连接阶段分为：连接建立，数据传送和连接释放；\nTCP的连接建立（三次握手）：\n（1）请求连接：客户端发送SYN=1，seq=x的报文段向服务器请求建立连接（不携带数据）；\n（2）同意连接：服务器收到请求后向客户端发送SYN=1，ACK=1，seq=y，ack=x+1的报文同意建立连接（不携带数据）；\n（3）确认连接：客户端收到同意后想服务器发送ACK=1，seq=x+1，ack=y+1的报文确认连接（可携带数据）；\n\n**TCP的连接释放(四次握手)**：\n\n\n第六章 应用层1.DNS的工作原理域名系统DNS是互联网使用的命名系统；用来把机器名字转换为IP地址；\n域名服务器分四种：（1）    根域名服务器（知道所有顶级域名服务器和IP地址）（2）    顶级域名服务器（3）    权限域名服务器（4）    本地域名服务器\n域名的解析过程分两步第一：主机向本地域名服务器的查询本地服务器用递归查询。第二：本地域名服务器向根域名服务器的查询用迭代查询。\n\n解析顺序\n　　1） 浏览器缓存\n　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；\n　　2） 系统缓存\n　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；\n　　3） 路由器缓存\n　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；\n　　4） ISP（互联网服务提供商）DNS缓存\n　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；\n　　5） 根域名服务器\n　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；\n　　6） 顶级域名服务器\n　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；\n　　7） 主域名服务器\n　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；\n　　8）保存结果至缓存\n　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。\n2.FTP 的工作原理文件传输协议FTP1.FTP的基本工作原理：主进程的工作步骤：(简答题)（1）    打开熟知端口（端口号为21），使客户进程能够连接上。（2）    等待客户进程发出连接请求。（3）    驱动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。（4）    回到等待状态，继续接受其他客户进程发来的请求。\nFTP的客户和服务器之间要建立两个并行的TCP连接：控制连接和数据连接\n3.电子邮件的工作原理1.电子邮件的一些标准：发送邮件的协议：SMTP读取邮件的协议：POP3和IMAP多用途互联网邮件扩展类型：MIME(在邮件首部说明邮件的数据类型如声音……)\n\n   计算机之间发送和接收电子邮件的几个重要步骤：（简答题）（1）    发件人调用计算机中的用户代理撰写和编辑要发送的邮件（2）    发件人点击屏幕上的“发送邮件”按钮，把发送邮件的工作全交给用户代理来完成。（3）    SMTP服务器收到用户代理发来的邮件后，就把邮件临时存放在邮件缓存队列中，等待发送到接受方的邮件服务器（4）    发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP服务器建立TCP连接，然后把邮件缓存队列中的邮件一次发送出去（5）    运行在接受方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取（6）    收件人在打算收信时，就在运行计算机中的用户代理，使用POP3（或IMAP）协议读取发送给自己的邮件\n\n电子邮件地址的格式：TCP/IP体系的电子邮件系统规定电子邮件地址的格式如下： 收件人邮箱名@邮箱所在主机的域名 例子：&#120;&#105;&#x65;&#120;&#x69;&#101;&#x72;&#x65;&#x6e;&#64;&#x74;&#x73;&#105;&#110;&#103;&#104;&#117;&#97;&#x2e;&#x6f;&#114;&#103;&#x2e;&#99;&#x6e;\n\n\n简单邮件传送协议SMTPSMTP通信的三个阶段：（1）    建立连接（主机的SMTP客户与接收主机的SMTP服务器的连接）（2）    邮件的传送（邮件的传送从MAIL命令开始）（3）    连接释放（邮件发送完毕后，SMTP客户发送OUIT命令）\n4.WWW 的四大问题及解决方法（1）怎样标志分布在整个互联网上的万维网文档？使用统一资源定位符URL；\n（2）用什么协议来实现万维网上的各种链接？使用超文本传送协议HTTP；\n（3）怎么使不同作者创造不同风格的万维网文档并显示在主机上？使用超文本标记语言HTML；\n（4）怎么样使用户很方便的查找信息？使用搜索引擎；\n5.DHCP的工作原理动态主机配置协议DHCP\n原理：动态主机设置协定（DHCP）是一种使网络管理员能够集中管理和自动分配IP网络地址的通信协议。在IP网络中，每个连接Internet的设备都需要分配唯一的IP地址。DHCP使网络管理员能从中心结点监控和分配IP地址。当某台计算机移到网络中的其它位置时，能自动收到新的IP地址。\n连接到互联网的计算机的协议软件需要配置的项目：（1）    IP地址；（2）    子网掩码；（3）    默认路由器的IP地址；（4）    域名服务器的IP地址；\n\n习题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["计算机网络复习"],"tags":["计算机网络"]},{"title":"Hexo环境搭建","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/02/21/Hexo环境搭建/","content":"1.1 创建博客项目安装Hexo\nnpm install -g hexo-cli\n初始化博客项目\nhexo init dm-blog\n进入项目文件夹，安装相关依赖\nnpm install\n目录结构\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n打开_config.yml，配置基本信息\n# Site\ntitle: 淡漠Blog\nsubtitle: &#39;&#39;\ndescription: &#39;淡漠DM的博客&#39;\nkeywords:\nauthor: 淡漠DM\nlanguage: zh-CN\ntimezone: &#39;&#39;\n启动项目\nhexo s\n\n\n常用命令介绍\n\n\n\n命令\n简写\n含义\n\n\n\nhexo server\nhexo s\n本地启动\n\n\nhexo generate\nhexo g\n生成静态文件\n\n\nhexo deploy\nhexo d\n部署网站\n\n\nhexo clean\n无\n清除缓存及生成的静态文件\n\n\n1.2 修改主题选择自己喜欢的主题\nhttps://hexo.io/themes/\n这里选择Kaze\n进入themes文件夹，下载主题，并重命名为kaze\ncd themes\ngit clone https:&#x2F;&#x2F;github.com&#x2F;theme-kaze&#x2F;hexo-theme-Kaze.git kaze\n修改配置文件（_config.yml）\ntheme: kaze\n主题名称为文件夹名称，默认为：landscape\n回到项目根目录，启动项目\nhexo clean\nhexo g\nhexo s\n1.3 完善博客项目1.3.1 修改基本信息进入themes/kaze/source ，创建文件夹 img，放入logo图片和作者头像\ntitle: 淡漠Blog\nauthor: 淡漠DM\nlogo_img: &#x2F;img&#x2F;logo.png # put the logo on the $&#123;blog_path&#125;&#x2F;source&#x2F;img&#x2F;$&#123;picname&#125;.png or use urls\nauthor_img: &#x2F;img&#x2F;author.jpg\nauthor_description: 最有趣的编程，莫过于服务生活。\n1.3.2 开启站点访问量统计（默认关闭）footer:\n  statistics:\n    enable: true\n    type: busuanzi # now version only supports busuanzi\n    pv:\n      enable: true\n      style: 本站总访问量&#123;&#125;次 # the style will be shown as $1&#123;pv&#125;$2\n    uv:\n      enable: true\n      style: 本站总访客数&#123;&#125;次\nenable 开启访问量统计（默认关闭）\ntype&#96; 目前仅支持 &#96;busuanzi\npv 访问总量统计\nuv 用户总量统计\n1.3.3 友链links:\n  小R资源:\n    url: https:&#x2F;&#x2F;www.tomyres.com\n    avatar: https:&#x2F;&#x2F;www.tomyres.com&#x2F;static&#x2F;images&#x2F;logo&#x2F;res_logo_1.png\n    description: 小R资源,免费的编程资源在线分享\n1.3.4 文章头部hello-world.md\n---\ntitle: Hello World\nbanner_img: https:&#x2F;&#x2F;www.tomyres.com&#x2F;static&#x2F;images&#x2F;logo&#x2F;res_logo_1.png\ncategory: Hi\ntag: hello\nexcerpt: 这是一段简介\n---\nbanner_img 文章封面\ncategory 分类\ntag 标签\nexcerpt 简介\n1.3.5 代码高亮在md文件写一段JavaScript代码\n​&#96;&#96;&#96;javascript\nconst smoothScrollToTop &#x3D; () &#x3D;&gt; &#123;\n  let yTopValve &#x3D; (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop);\n  if (yTopValve &gt; 1) &#123;\n    window.requestAnimationFrame(smoothScrollToTop);\n    scrollTo(0, Math.floor(yTopValve * 0.85));\n  &#125; else &#123;\n    scrollTo(0, 0);\n  &#125;\n&#125;;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  document.getElementById(&#39;scrollbutton&#39;).onclick &#x3D; smoothScrollToTop;\n&#125;, 0);\n​&#96;&#96;&#96;\n关闭 highlight，开启 prismjs（_config.yml）\nhighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: true\n  line_number: true\n  tab_replace: &#39;&#39;\n设置主题（kaze/_config.yml）\nprism:\n  theme: tomorrow\n1.3.6 评论这里使用 valine 实现评论，官方网 https://leancloud.cn/\n进入控制台后点击左下角创建应用\n应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了\n开启评论功能 kaze/_config.yml\ncomment:\n  enable: true\n  type: valine # valine | gitalk | livere | disqus | we recommend valine\n  # gitalk config details can see in https:&#x2F;&#x2F;github.com&#x2F;gitalk&#x2F;gitalk&#x2F;blob&#x2F;master&#x2F;readme-cn.md\n  valine:\n    appId: 你的appId\n    appKey: 你的appKey\n1.4 部署gitee创建一个公开的仓库，仓库名称需要和个人空间地址相同\n个人空间地址查看方式：设置——&gt;基本设置——&gt;个人资料\n初始化\ngit init\ngit remote add origin git@gitee.com:个人空间地址&#x2F;仓库名称.git\ngit pull origin master\n提交项目\ngit add .\ngit commit -m &#39;我的第一个博客项目&#39;\ngit push origin master\n第一次提交时，确保仓库没有文件，因为如果仓库有文件，且文件名字正好和本地项目的某个文件名相同，会导致提交失败\n修改配置文件\ndeploy:\n  type: git\n  repo: git@gitee.com:个人空间地址&#x2F;仓库名称.git\n  branch: master\n部署到gitee\nnpm install --save hexo-deployer-git\nhexo clean\nhexo g\nhexo d\n选择强制使用https\n部署后会显示网站地址，直接访问即可。\n项目每一次更新提交到gitee之后，需要更新部署\n注意：\n如果更新部署后访问项目没有变化，可以尝试 CTRL+F5 强制刷新，或清除浏览器缓存。\n","categories":["Hexo环境搭建"],"tags":["Hexo"]},{"title":"Hello Hexo","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/02/20/hello-world/","content":"const smoothScrollToTop = () => &#123;\n  let yTopValve = (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop);\n  if (yTopValve > 1) &#123;\n    window.requestAnimationFrame(smoothScrollToTop);\n    scrollTo(0, Math.floor(yTopValve * 0.85));\n  &#125; else &#123;\n    scrollTo(0, 0);\n  &#125;\n&#125;;\n\nsetTimeout(() => &#123;\n  document.getElementById('scrollbutton').onclick = smoothScrollToTop;\n&#125;, 0);\n","categories":["Hexo文章测试"],"tags":["Hexo"]}]