[{"title":"008-position布局","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/01/008-position布局/","content":"1.position布局​    定位（position）是一种布局手段 通过定位可以将元素摆放到任意位置\n​        使用position属性来开启定位：\n​                可选值  1.static 默认值 此时元素为不开启定位\n​                            2.relative 开启元素相对定位\n​                            3.absolute 开启元素绝对定位\n​                            4.fixed 开启元素固定定位\n​                            5.sticky 开启元素粘滞定位\n      偏移量（offset）：元素开启定位后 可以通过偏移量来设置元素的位置\n\n​                        top —  定位元素和定位位置上边的距离 top值越大 定位元素越靠下\n​                        bottom — 定位元素和定位位置下边的距离 bottom值越大 定位元素越靠上\n​                        left —  定位元素和定位位置左侧的距离 left值越大 定位元素越靠右\n​                        right —  定位元素和定位位置右侧的距离 right值越大 定位元素越靠左\n2.相对布局当元素的position属性为 relative 时 开启相对定位 \n\t- 相对定位的特点：\n                            1.元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化\n                            2.相对定位是参照于元素在文档流中的位置进行定位的\n                            3.相对定位会提升元素的层级\n                            4.相对定位不会使元素脱离文档流\n                            5.相对定位不会改变元素的性质块还是块，行内还是行内\n.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 1.初始三个div垂直排列 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            position: relative;\n            /* 2.demo2开启相对定位 但是还未设置偏移量\n                开启相对定位的元素不会脱离文档流 所以demo3的位置不会发生变化\n            */\n            left: 0px;\n            right: 0px;\n            /* 3.给元素的相对定位偏移量设置为 left 0 right 0 让其回到参照原点 可知\n                相对定位的参照原点为其在文档流时候的位置\n            */\n            left: 200px;\n            top: -200px;\n            /* 4.给元素依照参照原点 向右移动200px 向上移动200px 使其与demo1水平相邻排列*/\n            left: 70px;\n            /* 5.将元素demo2向右水平移动的距离改为70px 可见现在demo2遮盖住了demo1 所以可知相对定位会提升元素的层级\n                应为开启相对定位的元素未脱离文档里 不会改变元素的块级元素性质 而且开启相对定位的元素 其文档流后的元素不会因为其移动为改变布局\n            */\n        &#125;\n        .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: green;\n            /* demo3全程不移动 虽然demo已经移走 但是demo2还占据文档流中的位置 */\n        &#125;\n\t&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3&lt;/div>\n3.绝对定位当元素的position属性值为 absolute 时 元素开启绝对定位\n\t- 绝对定位的特点：\n                    1.开启绝对定位后，如果不设置偏移量元素的位置不会发生变化\n                    2.开启绝对定位后，元素会从文档流中脱离\n                    3.绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开\n                    4.绝对定位会使元素提升一个层级\n                    5.绝对定位元素是相对于其包含块进行定位的\n包含块( containing block )\n                        - 正常情况下：\n                            包含块就是离当前元素最近的祖先块元素\n                            &lt;div> &lt;div>&lt;/div> &lt;/div>\n                            &lt;div>&lt;span>&lt;em>hello&lt;/em>&lt;/span>&lt;/div>\n\n                        - 绝对定位的包含块:\n                            包含块就是离它最近的开启了定位的祖先元素，\n                                如果所有的祖先元素都没有开启定位则根元素就是它的包含块\n\n                        - html（根元素、初始包含块）\n.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            /* 1.初始demo1和demo2垂直相邻排列 */\n            position: absolute;\n            /* 4.demo2 开启绝对定位 demo2脱离文档流 所以demo3向上移动部位\n                但是demo2还未设置偏移量 所以demo2位置不发生变化\n                但是明显demo2遮挡住了demo3 可知开启绝对提升了元素的层级\n            */\n            top: 0;\n            left: 0;\n            /* 5.让demo2回到定位参照原点 可知此时demo2回到了最左上角 */\n            /* 8. 可知demo2此时的包含块是html根标签 所以回到最左上角 */\n        &#125;\n        .demo3&#123;\n            width: 400px;\n            height: 400px;\n            background-color: greenyellow;\n        &#125;\n        .demo4&#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n            position: relative;\n            /* 6.demo4 开启相对定位  未设置偏移量 此时demo4位置不发生变化*/\n        &#125;\n        .demo5&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            /* 2.初始demo3里包含demo4，demo4包含demo5 */\n            position: absolute;\n            /* 3.demo5开启绝对定位 还未设置偏移量 页面布局不发生变化 */\n            top: 0;\n            left: 0;\n            /* 7.让demo5回到定位参照原点 可见demo5回到了demo4文档流所在位置\n                可知绝对定位的参照原点是距其最近的开启了定位的包含块\n                    若元素的祖先们均未开启定位 则该元素的定位参照原点为html根包含块\n            */\n        &#125;\n\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4\n            &lt;div class=\"demo5\">5&lt;/div>\n        &lt;/div>\n    &lt;/div>\n\nPS：实际开发中 使用绝对定位和相对定位较多\n4.固定定位元素的position属性值为 fixed 时 元素开启固定定位\n\t特点：固定定位为绝对定位的一种 用法性质基本和绝对定位一致 \n\t\t\t唯一不同的是固定定位的参照原点一直都是浏览器的视口\n\t\t\t固定定位的元素不会随网页的滚动条移动\n .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 250px;\n            height: 250px;\n            background-color: skyblue;\n            position: fixed;\n            /* 2.demo2开启固定定位 */\n            top: 0;\n            left: 0;\n            /* 3. demo2回到定位参照原点 此时demo2位于页面最左上角 demo2此时脱离文档流 demo3上移*/\n        &#125;\n        .demo3&#123;\n            width: 300px;\n            height: 300px;\n            background-color: yellowgreen;\n            position: relative;\n            /* 4.demo3开启相对定位 */\n        &#125;\n        .demo4&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            position: fixed;\n            /* 1.demo4开启固定定位 此时未设置偏移量时 demo4固定在网页的这个位置不动 */\n            top: 0;\n            left: 0;\n            /* 5.demo4也回到定位参照原点 可知 此时demo4也会在demo2所在位置\n                可知固定定位的参照原点是浏览器的网页视口\n            */\n             left: 400px;\n            /* 让demo4从参照原点向右移动400px */\n        &#125;\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4&lt;/div>\n    &lt;/div>\n\n5.粘滞定位粘滞定位\n                    - 当元素的position属性设置为sticky时则开启了元素的粘滞定位\n                    - 粘滞定位和相对定位的特点基本一致，\n                        不同的是粘滞定位可以在元素到达某个位置时将其固定\n粘滞定位只能调整top 和 left 且调整top是不影响元素的原位置 只有在滑动元素要离开这一页面时才生效\n\n  .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: beige;\n        &#125;\n        .demo2&#123;\n            width: 250px;\n            height: 250px;\n            background-color: skyblue;\n            position: sticky;\n            /* 1.demo1 开启粘滞定位 特点和相对定位差不多 元素不脱离文档流 */\n            left: 0;\n            top: 0;\n            /* 2.demo2 回到参照原点  此时网页下滑时demo2在浏览器视口位置保持不动*/\n            left: 200px;\n            /* 3. demo2 向左移动200px 此时网页下滑时 demo2在浏览器视口向左移动200px的位置保持不变 */\n            top: 20px;\n            /* 4. 未滑动时demo2位置不发生变化 可知设置top未滑动页面时不影响元素原位置 \n                在页面下滑时 页面会停留在参照浏览器视口而偏移的位置\n            */\n        &#125;\n        .demo3&#123;\n            width: 100px;\n            height: 100px;\n            background-color: dodgerblue;\n        &#125;\n\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3&lt;/div>\n6.绝对定位元素的布局开启绝对定位以后 水平方向的布局的等式需要再加入 left right 两个值\n left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块的内容区的宽度\n此时规则和之前一样只是多添加了两个值：\n                            当发生过度约束：\n                                如果9个值中没有 auto 则自动调整right值以使等式满足\n                                如果有auto，则自动调整auto的值以使等式满足\n\n                        - 可设置auto的值\n                            margin width left right\n\n                        - 因为left 和 right的值默认是auto，所以如果不指定left和right\n                            则等式不满足时，会自动调整这两个值\n\n 垂直方向布局的等式的也必须要满足\n   bottom + top + margin-top/bottom + padding-top/bottom + border-top/bottom + height = 包含块的高度\n\n .demo1&#123;\n            width: 300px;\n            height: 300px;\n            background-color: #bfa;\n            position: relative;\n            /* 4.demo1开启相对定位 因此demo2的包含块更改为demo1所在的文档流位置 */\n        &#125;\n        .demo2&#123;\n            width: 100px;\n            height: 100px;\n            background-color: skyblue;\n            /* 1.此时demo1 和 demo2 上边距重叠 */\n            position: absolute;\n            /* 2.demo2开启绝对定位 */\n            left: 0;\n            top: 0;\n            /* 3.demo2回到定位参照原点 此时其父元素还没开启定位 所以其包含块应该是html根元素*/\n            right: 0;\n            /* 5.设置 right == 0 但是水平的等式 过度约束仍然成立 此时浏览器自动调整right不为0以满足等式 */\n            margin-left: auto;\n            /* 6.设置demo2 的margin-left为auto 此时等式不成立是 浏览器优先调整margin-left为最大值以满足等式 */\n            margin-right: auto;\n            /* 7.此时demo2 的margin-right 也为auto 此时浏览器自动调整水平两边的margin值相等 达到居中 */\n            bottom: 0;\n            margin: auto;\n            /* 8.此时demo2的水平 垂直方向上margin 均为 auto 所以浏览器优先调整margin 达到水平垂直居中 */\n        &#125;\n &lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n7.元素的层级对于开启了定位元素，可以通过z-index属性来指定元素的层级\n                    z-index需要一个整数作为参数，值越大元素的层级越高\n                        元素的层级越高越优先显示\n\n                    如果元素的层级一样，则优先显示靠下的元素\n\n                    祖先的元素的层级再高也不会盖住后代元素\n\n .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            position: relative;\n            /* 1.开启相对定位 */\n            z-index: 1;\n            /* 11.给demo1设置层级 此时demo1层级变为最高 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            position: absolute;\n            /* 2.开启绝对定位 */\n            top: 20px;\n            left: 40px;\n            /* 5. 此时移动demo2的位置 此时demo2 的参照原点是html根元素 可知demo2 的层级高于demo1 */\n        &#125;\n        .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            /* 3.此时demo3移动到demo2下面 因为demo2已脱离文档流 且demo2此时的层级高于demo3*/\n            position: absolute;\n            /* 4.demo3也开启绝对定位 越靠后的元素层级越高 所以此时demo3层级高于demo2 */\n            left: 80px;\n            top: 40px;\n            /* 6. 此时移动demo3的位置 此时demo3 的参照原点是html根元素 可知demo3 的层级高于demo2 */\n            z-index: 2;\n            /* 12.给demo3设置层级 此时demo3层级高于demo1 demo3的层级此时最高 但可知祖先的层级再高也不会遮挡后代元素 */\n        &#125;\n        .demo4&#123;\n            width: 100px;\n            height: 100px;\n            background-color: green;\n            /* 7.demo4 完全被包含在demo3中 */\n            position: absolute;\n            /* 8.demo4开启绝对定位 还没设置偏移量 所以位置不变 且demo4已没有元素 */\n            top: 0;\n            left: 0;\n            /* 9.此时demo4回到定位参照原点 可知此时demo4的包含块是demo3 */\n            top: 120px;\n            left: 140px;\n            /* 10.移动 demo4的位置 可知此时demo4 的层级高于demo3 此时层级为 demo1 &lt; demo2 &lt; demo3 &lt; demo4 */\n        &#125;\n &lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4&lt;/div>\n    &lt;/div>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"007-float布局","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/01/007-float布局/","content":"1.浮动布局（Float）浮动： 使用 float 属性设置 默认值为none； left 元素向左移动； right 元素向右移动；\n\tPS：一旦元素开启了float属性 此元素将脱离文档流 水平布局的等式便不再强制成立\n\t\t不占用文档流的元素浮动后 还在文档流的元素将自动补上\n\n .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 此时没开启float时 块级元素独占一行 盒子的可见框大小为 200px * 200px 浏览器将自动调整margin-right */\n            float: left;\n            /* 开启float 后 margin-right == 0 元素脱离文档流*/\n        &#125;\n        .demo1&#123;\n            width: 205px;\n            height: 205px;\n            background-color: green;\n            /* 此时demo1自动补上文档流中的demo离开的位置 此时demo1完全被浮动的demo遮挡 不可见 */\n        &#125;\n&lt;div class=\"demo\">&lt;/div>\n&lt;div class=\"demo1\">&lt;/div>\n\n浮动的特点： 按元素的浮动顺序排列 排在后面的浮动元素所在高度不会超过其前面浮动元素的所在高度\n                                排在前面的浮动元素越接近父元素的边界 但无法超出父元素\n2.浮动布局与文字浮动布局最早用来解决文字环绕问题 浮动元素不会遮住文字 文字会自动环绕在浮动元素周围\n.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 开启float后 div上浮 但不会遮住span中的文本 */\n        &#125;\n.content&#123;\n           \n            float: left;\n            /* 可知行内元素开启float 脱离文档流后 特点变得和块元素一样 */\n        &#125;\n\n &lt;span class=\"content\">Lorem ipsum dolor sit amet consectetur adipisicing elit. Molestiae enim officia dolore non dolor eligendi maxime et quis, accusamus laborum pariatur praesentium, saepe dolores ipsa est libero delectus itaque ullam!&lt;/span>\n &lt;div class=\"demo\">&lt;/div>\n\n.test1&#123;\n            background-color: #bfa;\n            /* 未开启float时 div默认独占一行 不主动设置宽高的时候 div宽度默认100% 高度由内容撑开 */\n            float: left;\n            /* 开启float 后 块级元素div 脱离文档流 此时元素的宽高默认由内容撑开 */\n        &#125;\n &lt;div class=\"test1\">\n        我是一个类名为 test1 的div\n        &lt;div class=\"test2\">我是在test1类里的div&lt;/div>\n  &lt;/div>\n\n\n脱离文档流的特点：\n                    块元素：\n                        1、块元素不在独占页面的一行\n                        2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开\n\n                    行内元素：\n                        行内元素脱离文档流以后会变成块元素，特点和块元素一样\n\n                    脱离文档流以后，不需要再区分块和行内了\n\nPPS ： float元素 默认宽高均由内容撑开 但也可以手动设置宽高 此时不再区分块元素和内联元素\n3.高度塌陷问题在普通布局中 外层的块级元素高度默认由内部的块级元素高度撑开 但若父元素内部的子元素开启浮动后 父元素高度将丢失\n\n        .box1&#123;\n            /* 1.不设置宽高 默认其由子元素撑开 */\n            /* 2.设置边框 */\n            border: 5px red solid;\n        &#125;\n        .box2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 3.此时子元素将父元素撑开 */\n            float: left;\n            /* 4.开启子元素浮动后 子元素脱离文档流 将无法撑开父元素高度 */\n        &#125;\n\t &lt;div class=\"box1\">\n        &lt;div class=\"box2\">&lt;/div>\n    &lt;/div>\n4.BFC（块级格式化环境）解决高度塌陷问题 BFC(Block Formatting Context) 块级格式化环境\n                    - BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC\n                        开启BFC该元素会变成一个独立的布局区域\n                    - 元素开启BFC后的特点：\n                        1.开启BFC的元素不会被浮动元素所覆盖\n                        2.开启BFC的元素子元素和父元素外边距不会重叠\n                        3.开启BFC的元素可以包含浮动的子元素\n\n                    - 可以通过一些特殊方式来开启元素的BFC：\n                        1、设置元素的浮动（不推荐）\n                        2、将元素设置为行内块元素（不推荐）\n                        3、将元素的overflow设置为一个非visible的值\n                            - 常用的方式 为元素设置 overflow:hidden 开启其BFC 以使其可以包含浮动元素\n .box1&#123;\n            /* 1.不设置宽高 默认其由子元素撑开 */\n            /* 2.设置边框 */\n            border: 5px red solid;\n            overflow: hidden;\n            /* 5.父元素开启 BFC 使其可以包含浮动元素 此时父元素不会被浮动元素遮挡*/\n            \n        &#125;\n        .box2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 3.此时子元素将父元素撑开 */\n            float: left;\n            /* 4.开启子元素浮动后 子元素脱离文档流 将无法撑开父元素高度 浮动的子元素遮挡住了父元素*/\n        &#125;\n &lt;div class=\"box1\">\n        &lt;div class=\"box2\">&lt;/div>\n &lt;/div>\n\n\nBFC   解决外边距重叠问题\n .demo1&#123;\n            width: 400px;\n            height: 400px;\n            background-color: #bfa;\n            overflow: hidden;\n            /* 3.父元素开启BFC 父元素的外边距与子元素的外边距不重叠 实现子元素在父元素中下移 而父元素不下移 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            /* 1.此时子元素与父元素的外边距重叠 */\n            margin-top: 200px;\n            /* 2.此时父元素 与 子元素 一起下移*/\n        &#125;\n\n &lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n5.clear在普通的块级元素的垂直布局中 若文档流中有元素由于浮动脱离文档流后 该元素之和的文档流元素位置将发生移动 \n\t若不希望元素受到浮动的影响 可使用clear 属性清除浮动元素产生的影响\nclear\n                    - 作用：清除浮动元素对当前元素所产生的影响\n                    - 可选值：\n                        left 清除左侧浮动元素对当前元素的影响\n                        right 清除右侧浮动元素对当前元素的影响\n                        both 清除两侧中最大影响的那侧\n\n                    原理：\n                        设置清除浮动以后，浏览器会自动为元素添加一个上外边距，\n                            以使其位置不受其他元素的影响\n\n \t\t.demo1&#123;\n            width: 400px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 1.此时demo1开启浮动 文档流中其后的demo2 和 demo3 位置将发生移动 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            clear: left;\n            /* 2.demo2 开启clear ：left 清除其前面元素demo1 左浮带来的影响 */\n            float: right;\n            /* 3.此时demo2 开启右浮 demo3位置发生改变 */\n        &#125;\n        .demo3&#123;\n            width: 400px;\n            height: 100px;\n            background-color: green;\n            clear: right;\n            /* demo3 开启 clear ： right 消除demo2右浮的影响 */\n        &#125;\n&lt;div class=\"demo1\">1&lt;/div>\n&lt;div class=\"demo2\">2&lt;/div>\n&lt;div class=\"demo3\">3&lt;/div>\n6.clearfix解决高度塌陷.demo&#123;\n            /* 1.demo不设置宽高 默认其的高度由子元素撑开 此时默认width为100% */\n            border: 5px red solid;\n        &#125;\n        .test&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 2.开启子元素浮动 父元素高度塌陷 */\n        &#125;\n        .demo::after&#123;\n            content: '';\n            display: block;\n            clear: both;\n            /* 3.使用伪类选择器 在父元素的最后加入内容\n                    加入的内容为：\n                        1.''空字符串\n                        2.将这个字符串转换成block元素\n                        3.因为这个字符串元素在浮动元素test后面 使用clear 清除浮动影响\n                        使用clear相当于在这个字符串元素身上加上了 margin-top 高度为test的高度 所以此时父元素相当于被这个字符串元素撑开\n            \n            这里也不推荐使用block 推荐使用table\n            */\n        &#125;\n\n&lt;div class=\"demo\">\n\t &lt;div class=\"test\">&lt;/div>\n&lt;/div>\n\n\n最终的clearfix样式：\n/* clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 */\n        .clearfix::before,\n        .clearfix::after&#123;\n            content: '';\n            display: table;\n            clear: both;\n        &#125;\nPS：这里将字符串元素转换成table类型 是因为block不能讲父子元素的外边距分离开\n\t而采用table可以实现外间距分离和高度塌陷\n\n\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"006-文档流-盒模型","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/27/006-文档流-盒模型/","content":"1.文档流（normal flow）​    在文档流中，内联元素默认从左到右流，遇到阻碍或者宽度不够的自动换行，继续按照从左到右的方式布局；块级元素独占一行，按照从上到下的方式布局。\n​    文档流是网页的基础 所创建的元素默认在文档流中排列\n元素在文档流中有什么特点：\n        - 块元素\n            - 块元素会在页面中独占一行(自上向下垂直排列)\n            - 默认宽度是父元素的全部（会把父元素撑满）\n            - 默认高度是被内容撑开（子元素）\n\n        - 行内元素\n            - 行内元素不会独占页面的一行，只占自身的大小\n            - 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素\n                则元素会换到第二行继续自左向右排列（书写习惯一致）\n            - 行内元素的默认宽度和高度都是被内容撑开\n\n2.盒模型（Box Model）盒模型 ： 可以将网页中的任何元素都看成一个矩形\n\t\t每一个盒子都由以下几个部分组成：\n\t\t1.内容区（content）\n\t\t2.内边距（padding）\n\t\t3.边框（border）\n\t\t4.外边距（margin）\n\n\t内容区 内边距 边框 都会影响可见盒模型的大小！！！\n\n\n\n1.内容区（content）内容区的大小由 width 和 height 两个属性设置\n/* 设置 demo 盒子的大小 */\n        .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n2.边框（border）要想在网页的盒子显示边框 必须要设置三个属性 border-width border-color border-style\n\t\tborder-width 和 border-color 有默认值 可省略不写（border-width默认3px border-color默认使用盒子的color）\n\t（1）border-width：可用来指定盒子四个方向的边框宽度 有默认值 3px\n\t\t\t\t值的情况：四个值 ----上 右 下 左 （顺时针）\n\t\t\t\t\t\t三个值 ---- 上 左右 下\n\t\t\t\t\t\t两个值 ---- 上下 左右\n\t\t\t\t\t\t一个值 ---- 上下左右\n\t\tborder-xxx-width： 可单独指定任意一边的宽度 xxx---top right  bottom  left\n\t（2）border-color: 可用来指定盒子边框的颜色 有默认值 使用color值\n\t\t\t\t使用规则与border-width 基本相同\n\t\t\t\t也有border-xxx-color可使用\n\t（3）border-style ： 用来指定边框的样式 没有默认值 none\n\t\t\t\tsolid 表示实线\n                  dotted 点状虚线\n                  dashed 虚线\n                  double 双线\n\t\t\t\nborder简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求\n\t\tborder: red 10px solid (三者顺序任意 需用空格间隔开)\n 除了border以外还有四个 border-xxx\n                       border-top\n                       border-right\n                       border-bottom\n                       border-left   用来单独设置每一条边框的具体样式\n\t\t\t也有 border-xxx-style 可使用\n\n \t\t/* 设置demo1 盒子的边框样式 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n            border-width: 10px;\n            border-color: red;\n            border-style: solid;\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n          /* 设置demo2 盒子的边框样式 */\n          .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n           border: 10px red solid;\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n         /* 设置demo3 盒子的边框样式 */\n         .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n           border-style: solid;\n           \n           border-top-style: double;\n\n           /* 此时边框宽度使用默认值 边框颜色使用默认值 black */\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n\n3.内边距（padding）​    内容区和边框之间的是内边距区 一共有四个方向的内边距 padding-top/right/bottom/left \n​    内边距的设置会影响盒子的大小  背景颜色会延伸到内边距区 内边距区不能单独设置背景颜色\npadding 内边距的简写属性同 border-width 相同 可同时指定四个方向的内边距大小\n\n /* 设置demo1 盒子的外边距 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n\n\n            /* 设置内边距 20px 此时盒子的高度为220px 盒子的背景颜色延伸到内边距区*/\n            /* padding-top: 20px; */\n            /* 内边距区不能单独设置背景颜色 */\n\n            /* 直接设置4个方向的内边距大小 */\n            padding: 10px 20px 30px 40px;\n\n            border: red 10px solid;\n        &#125;\n\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: black;\n            /* demo2盒子在demo1盒子中 大小与demo1的内容区大小一致 此时设置demo1 的内边距 直接影响demo1\n                盒子的整体大小\n                此时demo1的整体高度为240px\n            */\n\n\n\n            padding-top:10px;\n\n            /* 设置demo2 盒子的内边距不影响demo1的盒子大小 此时 设置demo2 内边距 padding-top 10px \n                此时demo2 整个盒子的高度变为210px\n                因为demo1此时边框距demo2 的边框还差 20px 所以两者边框未重叠\n            */\n\n            border: blue 10px solid;\n\n            /* 此时设置；两盒子的边框 demo2 的盒子高度达到230px 此时与demo1 的边框重合 \n                demo2 此时覆盖了demo1 的padding-bottom 30px    \n            */\n        &#125;\n\n\t&lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n\n\n盒子的可见框的大小，由内容区 内边距 和 边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算\n4.外边距（margin）​    外边距不会影响盒子可见框的大小 只影响盒子排放的位置 一共有四个方向的外边距\n                 margin-top\n                            - 上外边距，设置一个正值，元素会向下移动\n                 margin-right\n                            - 默认情况下设置margin-right不会产生任何效果\n                 margin-bottom\n                            - 下外边距，设置一个正值，其下边的元素会向下移动\n                 margin-left\n                            - 左外边距，设置一个正值，元素会向右移动\n                - margin也可以设置负值，如果是负值则元素会向相反的方向移动\n\n                - 元素在页面中是按照自左向右的顺序排列的，\n                    所以默认情况下如果我们设置的左和上外边距则会移动元素自身\n                    而设置下和右外边距会移动其他元素\n\n                - margin的简写属性\n                    margin 可以同时设置四个方向的外边距 ，用法和padding一样\n\n                - margin会影响到盒子实际占用空间\n\n\t\t/* 设置demo1盒子的外边距样式 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n\n            /* 设置外边框 */\n            border: 10px red solid;\n\n            /* 设置外边距大小 */\n            margin: 30px 20px 50px 100px;\n\n            /* 从效果可知此时盒子在设置margin-top 和 margin-left 时才会移动自身的位置 */\n        &#125;\n\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gainsboro;\n\n            /* 调整demo1 的 margin-bottom 时 demo2 的位置会下移 */\n             margin: 10px;\n\n            /* 此处其实有垂直方向上的 两个盒子 的margin-bottom 和 margin-top 重叠 */\n        &#125;\n\n&lt;div class=\"demo1\">&lt;/div>\n&lt;div class=\"demo2\">&lt;/div>\n5.盒模型的水平布局块元素独占一行 元素在其父元素中的水平方向的位置由以下几个属性共同决定\n\t\t\t\t\t  margin-left\n                        border-left\n                        padding-left\n                        width\n                        padding-right\n                        border-right\n                        margin-right\n\t刚好是盒子从外到内在到内 从左到右的水平宽度之和\n一个元素在其父元素的水平布局中必须满足以下等式：\nmargin-left+border-left+padding-left+width+padding-right+border-right+margin-right = 其父元素内容区的宽度 （必须满足）\n\n若以上等式右边之和小于父元素宽度 称为 过度约束 此时等式会自动调整\n\t\t调整原则：1.这七个值中没有为 auto 的值的时候 浏览器自动调整margin-right值使等式成立\n\t\t\t\t2.如果 width margin-left margin-right 三个值中有为 auto 值的 浏览器会自动优先调整auto使等式成立\n\t\t\t\t\t如果 width 和 margin-left/right 均设置为auto 则宽度会默认调整到最大 margin为0\n\t\t\t\t\t如果只有连个外边距为auto width固定值 此时会自动调整到margin-left=margin-right\n\t\t\t\t\t\t\t实现元素在父元素中居中\n\n \t.demo&#123;\n            width: 1000px;\n            height: 400px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 300px;\n            height: 200px;\n            background-color: yellowgreen;\n            /* 此时demo2的宽度300px 就算小于其父元素的1000px\n                两个demo2共同排放在其父元素demo中 也不可能排放在同一排\n\n                此时 过度约束 成立 没有设置auto值 浏览器调整 demo2的margin-right 为 700px 使等式成立 \n\n                此时demo2的宽度总和占满以父元素 所以 demo3 自动被挤出父元素换行\n            */\n        &#125;\n        .demo3&#123;\n            width: 300px;\n            height: 200px;\n            background-color: yellow;\n\n        &#125;\n        .demo4&#123;\n            width: 1000px;\n            height: 400px;\n            background-color: #bfa;\n        &#125;\n        .demo5&#123;\n            /* width 和 margin 均为 auto 此时width为最大 margin为0 */\n            width: auto;\n            margin: auto;\n            height: 200px;\n            background-color: yellowgreen;\n        &#125;\n        .demo6&#123;\n            /* width 为 400px ， margin 均为 auto 此时；水平两边margin值相等 实现元素在父元素中居中 */\n            width: 400px;\n            margin: auto;\n            height: 200px;\n            background-color: yellowgreen;\n        &#125;\n &lt;div class=\"demo\">\n        &lt;div class=\"demo2\">&lt;/div>\n        &lt;div class=\"demo3\">&lt;/div>\n    &lt;/div>\n\n    &lt;hr>\n\n    &lt;div class=\"demo4\">\n        &lt;div class=\"demo5\">&lt;/div>\n        &lt;div class=\"demo6\">&lt;/div>\n    &lt;/div>\n6.盒模型的垂直布局默认情况下父元素的高度被内容撑开\n .demo&#123;\n            width: 500px;\n            background-color: #bfa;\n            /* 父元素不设置高度 */\n        &#125;\n        .test&#123;\n            width: 200px;\n            height: 200px;\n            background-color: green;\n            /* 子元素高度设置为200px 此时父元素的高度被撑开 为200px */\n        &#125;\n&lt;div class=\"demo\">\n        &lt;div class=\"test\">&lt;/div>\n    &lt;/div>\n\n子元素在父元素的内容区中排列 如果子元素大小超过父元素 称子元素从父元素中 溢出（overflow）\n\t使用 overflow 属性处理溢出的子元素\n\n\t\t\t\t可选值：\n                        visible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示\n                        hidden 溢出内容将会被裁剪不会显示\n                        scroll 生成两个滚动条，通过滚动条来查看完整的内容\n                        auto 根据需要生成滚动条\n .demo1&#123;\n            width: 500px;\n            height: 200px;\n            background-color: #bfa;\n           \n\n            /* overflow属性应写在父元素中 */\n             /* overflow: visible;  */\n            /* overflow默认值为 visible 即显示溢出不作处理 */\n            /* overflow: hidden; */\n            /* overflow: scroll; */\n            /* overflow: auto; */\n            \n        &#125;\n        .test1&#123;\n            width: 200px;\n            height: 400px;\n            background-color: yellowgreen;\n            /* 此时子元素高度超过父元素 从中溢出 */\n        &#125;\n&lt;div class=\"demo1\">\n        &lt;div class=\"test1\">&lt;/div>\n    &lt;/div>\n\n还有 \t\t\toverflow-x: 调整水平溢出\n                overflow-y:调整垂直溢出\n7.外边距的折叠盒子的相邻垂直方向外边距（margin）会发生重叠现象\n\t1.兄弟元素 间的相邻垂直外边距取两者之间最大值（当两者都为正值时）\n\t\t相邻两外边距一正一负时取两者之和\n\t\t若两外边距都是负值时取绝对值大的\n\n\t\t.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            margin-bottom: 50px;\n\n            /* 将demo1 的margin-bottom 设置为 负值 */\n            margin-bottom: -30px;\n\n\n            /* 此时两盒子的垂直外边距均为负值 取demo1 的外边距 -30 px （绝对值较大） */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 此时demo1的margin-bottom值为50px\n                设置demo2 的margin-top 为50px\n            */\n            margin-top: 50px;\n            /* 可知发生外边距折叠 此时盒子布局和只设置demo1 margin-bottom 50px 效果一致 */\n\n            margin-top: 100px;\n            /* 若将demo2的 margin-top 设置为100 px 两盒子间的间隔 取demo2\n                    外边距（100px较大）\n            */\n\n            margin-top: -20px;\n            /* 若将demo2 的margin-top 值设置为 -20 px 此时两盒子的间隔为 50px-20px=30px 取两者之和 */\n        &#125;\n\n&lt;div class=\"demo1\">&lt;/div>\n&lt;div class=\"demo2\">&lt;/div>\n\n实际开发中 兄弟间的边距折叠现象是有利的 不用去处理\n\n\t2.父子元素相邻外边距\n\t\t\t子元素的外边距会传递给父元素\n\t\t\t父子外边距折叠会影响页面布局 需要处理\n\n        /* 父子间元素 */\n\n        .demo3&#123;\n            width: 500px;\n            height: 500px;\n            background-color: #bfa;\n            /* 设置父元素的边框 */\n            border: 2px red solid;\n            /* 给父元素设置边框后 就将父子的边框分离开来 此时 子元素的外边距不会传递给父元素 */\n        &#125;\n        .demo4&#123;\n             border: 2px red solid;\n            /* 只设置子元素的边框无法分离父子元素的边框 需要在父元素处设置边框 */\n            width: 250px;\n            height: 250px;\n            background-color: yellowgreen;\n\n            /* 设置子元素的外边距 */\n            margin-top: 50px;\n            /* 可知此时子元素的外边距与父元素的外边距重叠 设置子元素外边距时父元素的外边距也一起变化 */           \n        &#125;\n \t&lt;div class=\"demo3\">\n        &lt;div class=\"demo4\">&lt;/div>\n    &lt;/div>\n8.行内元素的盒模型行内元素不支持设置宽度和高度\n\t行内元素可以设置padding border margin 都是垂直方向均无效 不影响布局\n\t\t.demo1&#123;\n            width: 200px;\n            height: 200px;\n            /* 设置高度和宽度均无效 */\n            background-color: #bfa;\n            margin-top: 1000px;\n            /* 设置垂直外边距无效 */\n            margin-left: 100px;\n            margin-right: 100px;\n            /* 设置水平外边距有效 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            /* 设置高度和宽度均无效 */\n            background-color: yellowgreen;\n            margin-top: 1000px;\n            /* 设置垂直外边距无效 */\n            margin-left: 100px;\n            margin-right: 100px;\n            /* 设置水平外边距有效 相邻水平间距取两者之和*/\n        &#125;\n &lt;span class=\"demo1\">我是类名为demo1 的span&lt;/span>\n &lt;span class=\"demo2\">我是类名为demo2 的span&lt;/span>\n\n行内元素的两个属性：\n\t（1）display 用来设置元素显示的类型\n\t\t\t\t\t  inline 将元素设置为行内元素\n                        block 将元素设置为块元素\n                        inline-block 将元素设置为行内块元素 \n                                行内块，既可以设置宽度和高度又不会独占一行\n                        table 将元素设置为一个表格\n                        none 元素不在页面中显示\n\t（2）visibility 用来设置元素的显示状态\n   \t\t\t\t\t  visible 默认值，元素在页面中正常显示\n                        hidden 元素在页面中隐藏 不显示，但是依然占据页面的位置\t\n\n  .box1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            display: inline;\n            /* div变成行内元素后 宽度和高度设置将失效 */\n        &#125;\n  &lt;div class=\"box1\">我是一个变成行内元素的div&lt;/div>\n  &lt;div class=\"box1\">我是一个变成行内元素的div&lt;/div>\n\n.test1&#123;\n            background-color: #bfa;\n            display: block;\n            /* 将span的display属性设置为 block span将变为块元素 独占一行 */\n        &#125;\n .test2&#123;\n            background-color: palegoldenrod;\n            display: none;\n            /* display 属性设置为 none 元素将隐藏 */\n        &#125;\n .test3&#123;\n            background-color: pink;\n            visibility: hidden;\n            /* visibility属性设置为 hidden 将元素隐藏 但还是在网页占据位置\n                display ： none 元素不再网页中占据位置空间\n            */\n        &#125;\n\t&lt;span class=\"test1\">我是类名为 test1 的span&lt;/span>\n    &lt;span class=\"test2\">我是类名为 test2 的span&lt;/span>\n    &lt;span class=\"test3\">我是类名为 test3 的span&lt;/span>\n9.盒子的尺寸默认情况下 盒子可见框有 content padding border 三者决定\n\tbox-sizing 用来设置盒子尺寸的计算方式（即设置 width 和 height 的作用）\n\t\t可选值：content-box 为默认值 此时设置的 width 和height 均为content大小\n\t\t\t\tborder-box 此时width 和 height 设置整个盒子的可见框大小\n\t\t.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            border: 10px red solid;\n            box-sizing: content-box;\n            /* 默认值 此时width 和 height 为content 大小 */\n        &#125;\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            border: 10px red solid;\n            box-sizing: border-box;\n            /* 此时width 和 height 决定整个盒子可见框大小 */\n        &#125;\n10.轮廓和圆角（1）轮廓：outline 用来设置元素的轮廓线 用法和border一致\n\t\t\t轮廓和边框不同的是轮廓不会影响可见框的大小\n.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* border: 10px red solid; */\n            outline: 10px red solid;\n            /* outline 属性不影响页面布局 \n                outline会遮住下面的行内元素 但是border不会\n            */ \n        &#125;\n&lt;div class=\"demo\">&lt;/div>\n    &lt;span>hello&lt;/span>\n\n（2）阴影：box-shadow 用来设置元素的阴影效果 阴影不会影响页面布局\n\t\t\t   第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动\n                第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动\n                第三个值 阴影的模糊半径\n                第四个值 阴影的颜色\n \t.demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n           box-shadow: 20px 5px 30px rgba(0, 0, 0, .4);\n        &#125;\n（3）圆角： border-radius 用来设置圆角 圆角设置的圆的半径大小\n\t\t\t/* border-top-left-radius:  */\n            /* border-top-right-radius */\n            /* border-bottom-left-radius:  */\n            /* border-bottom-right-radius:  */\n\t border-radius 可以分别指定四个角的圆角\n                    四个值 左上 右上 右下 左下\n                    三个值 左上 右上/左下 右下 \n                    两个个值 左上/右下 右上/左下  \n\t.demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* border-radius: 30px; */\n            /* 50% 为圆形 */\n            /* border-radius: 50%; */\n\n            border-radius: 10px / 55px;\n            /* 设置椭圆角 第一个值为 垂直半轴 第二个值为 水平半轴*/\n        &#125;\n3.练习line-height 值设置为与父元素的height相等时 此时可让子元素中的字体在父元素中垂直居中\ntext-decoration ：none 为去除超链接下划线样式\n\npadding的设置增加的大小属于盒子 margin的设置增加的大小不属于盒子\ndisplay：inline-block 将元素转换成行内块元素\n重温伪元素选择器 ::before&#123;&#125;\n\n设计页面时先考虑整体布局 先实现整体布局效果 再进一步修改每处细节样式\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"005-样式继承-选择器权重-单位-颜色","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/27/005-样式继承-选择器权重-单位-颜色/","content":"1.样式的继承​    为一个元素设置的样式会自动应用到他的所有后代子元素身上\n​    注意：并不是所有样式都会继承，如 背景，布局相关样式都不会继承\n.box&#123;\n           /* box中的颜色样式会自动继承到box的所有子类身上 */\n           color: blue;\n\n           width: 200px;\n           height: 200px;\n\n           /* 背景颜色不会继承到后代中 但是后代子元素的背景默认为透明 所以看上去同父元素背景颜色一致*/\n           background-color: gray;\n       &#125;\n\n       /* 选择box中的所有span字元素 */\n       div > span, div > p >span&#123;\n           /* background-color: red; */\n           /* 调整透明度 */\n           opacity: .5; \n       &#125;\n2.选择器的权重内联样式        1,0,0,0\nid选择器        0,1,0,0\n类和伪类选择器   0,0,1,0\n元素选择器       0,0,0,1\n通配选择器       0,0,0,0\n继承的样式       没有优先级\n\n比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的）,\n      选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器\n                如果优先级计算后相同，此时则优先使用靠下的样式\n\n可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式，\n       注意：在开发中这个玩意一定要慎用！\n\n /* 选择box中的第一个p元素设置样式 */\n         .box :first-child&#123;\n             /* 这里的第一个p元素不生效 但是第二个p元素的span元素样式生效 因为span是p标签的中的第一个子元素 */\n             color: red;\n         &#125;\n         /* 选中id为 demo的span标签 */\n         #demo&#123;\n             /* id选择器优先级高于类选择器和伪类选择器 */\n             color: aqua;\n         &#125;\n\n&lt;div class=\"box\" >\n        我是一个类名叫box的div\n        &lt;!-- p元素中的内联样式优先级最高 -->\n        &lt;p style=\"color: skyblue;\">\n            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deserunt repellat vero, eveniet dolore ducimus temporibus iure inventore. Nihil ea blanditiis delectus repellat fuga corrupti? Minus voluptate commodi asperiores aspernatur quam!\n        &lt;/p>\n\n        &lt;p>\n            &lt;span id=\"demo\">我是p元素中的span&lt;/span>\n            &lt;br>&lt;br>\n            &lt;span>我是p元素中的第二个span元素&lt;/span>\n        &lt;/p>\n    &lt;/div>\n3.像素单位（1）像素 -- px\n（2）百分比 -- %\n（3）em -- 相对于以元素的字体大小来计算 默认字体大小是16px\n\t\t\t1em = 1font-size  em根据所在元素字体大小计算而改变\n（4）rem -- 根据根元素（root -- html）的字体大小来改变\n\n.demo&#123;\n            /* 设计一个box */\n            width: 400px;\n            height: 400px;\n            background-color: green;\n        &#125;\n        .test&#123;\n            /* 这是在demo里的的一个div 大小根据父容器大小改变 */\n            width:50%;\n            height: 50%;\n            background-color: bisque;\n            /* 改变元素字体大小 */\n            font-size: 12px;\n        &#125;\n        .t1&#123;\n            /* em根据所在元素字体大小改变 */\n            font-size: 30px;\n            width: 5em;\n            height: 5em;\n            background-color: blue;\n        &#125;\n        .t2&#123;\n            /* rem根据body根元素的字体大小改变 */\n            width: 5rem;\n            height: 5rem;\n            background-color: red;\n        &#125;\n        html&#123;\n            font-size: 25px;\n        &#125;\n  &lt;div class=\"demo\">\n        &lt;div class=\"test\">\n            &lt;div class=\"t1\">\n                &lt;div class=\"t2\">&lt;/div>\n            &lt;/div>\n        &lt;/div>\n    &lt;/div>\n4.颜色颜色单位：\n                   在CSS中可以直接使用颜色名来设置各种颜色\n                       比如：red、orange、yellow、blue、green ... ...\n                       但是在css中直接使用颜色名是非常的不方便\n\n                   RGB值：\n                       - RGB通过三种颜色的不同浓度来调配出不同的颜色\n                       - R red，G green ，B blue\n                       - 每一种颜色的范围在 0 - 255 (0% - 100%) 之间\n                       - 语法：RGB(红色,绿色,蓝色)\n\n                   RGBA:\n                       - 就是在rgb的基础上增加了一个a表示不透明度\n                       - 需要四个值，前三个和rgb一样，第四个表示不透明度\n                           1表示完全不透明   0表示完全透明  .5半透明\n\n                   十六进制的RGB值：\n                       - 语法：#红色绿色蓝色\n                       - 颜色浓度通过 00-ff\n                       - 如果颜色两位两位重复可以进行简写  \n                           #aabbcc --> #abc\n                   \n                   HSL值 HSLA值\n                       H 色相(0 - 360)\n                       S 饱和度，颜色的浓度 0% - 100%\n                       L 亮度，颜色的亮度 0% - 100%\n\t\t\t\t  A 透明度 0% - 100%\ndiv&#123;\n           margin-right: 20px;\n       &#125;\n       .demo1&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           background-color: red;\n       &#125;\n       .demo2&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 三个值依次表示 红 黄 蓝 */\n           background-color: rgb(255, 0, 0);\n       &#125;\n       .demo3&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 四个值依次表示 红 黄 蓝 透明度（0~1） */\n           background-color: rgba(255, 0, 0, 1);\n       &#125;\n       .demo4&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用16进制表示 红黄蓝依次使用两个16进制数表示 当每个颜色的两位数字相同时可以采用只写一位的简写 */\n           background-color: #f00;\n       &#125;\n       .demo5&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用 hsl 表示颜色 时三个值依次表示 色相 饱和度 亮度 hsl中的色相取值在0~360 可看成一个圆盘 0和360都是红色\n               饱和度 和 亮度 的取值在0%~100%\n           */\n           background-color: hsl(360, 100%, 50%);\n       &#125;\n       .demo6&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用 hsla 表示颜色 时四个值依次表示 色相 饱和度 亮度 透明度 hsl中的色相取值在0~360 可看成一个圆盘 0和360都是红色\n               饱和度 和 亮度 透明度 的取值在0%~100%\n               透明度 0% 表示不透明 此时元素不显示\n           */\n           background-color: hsl(360, 100%, 50%, 100%);\n\n      &lt;div class=\"demo0\">\n       &lt;div class=\"demo1\">&lt;/div>\n       &lt;div class=\"demo2\">&lt;/div>\n       &lt;div class=\"demo3\">&lt;/div>\n       &lt;div class=\"demo4\">&lt;/div>\n       &lt;div class=\"demo5\">&lt;/div>\n       &lt;div class=\"demo6\">&lt;/div>\n   \t&lt;/div>     \n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"004-CSS选择器","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/26/004-CSS选择器/","content":"1.CSS语法简介&lt;!--\n\t方式1 内联样式/行内样式：在标签内通过style属性设置元素样式\n\t\t内联样式：属性:值; 使用 ; 来间割属性\n\t\t该方式不能实现样式复用\n-->\n&lt;p style=\"color:green; font-size:20px;\">\n    这里是一段p元素文字\n&lt;/p>\n\n!!!注意在实际开发中不要轻易使用内联样式\n\n&lt;!-- \n\t方式2 内部样式表：在head标签内写style标签\n\t\t\t语法 样式选择器&#123;color: red;&#125;   \n\t方式3 外部样式表：通过引入外部css文件\n\t\t\t在head中通过link标签引入\n-->\n&lt;link rel=\"stylesheet\" href=\"这是css文件路径\">\n\n在实际开发中推荐使用方式3 可是css文件实现复用\n\ncss文件中的注释符号为  /*  这是注释 */\n2.CSS选择器1.常用选择器（1）元素选择器：根据标签名选中指定元素 页面中所有该元素的标签都有效\n\t语法：标签名&#123;&#125;  如p&#123;&#125;，h1&#123;&#125; ，h2&#123;&#125; body&#123;&#125;\n（2）id选择器： 根据标签的id选中元素\n\t语法：#id名&#123;&#125; 如 #box&#123;&#125;， #big&#123;&#125;\n\t\t使用id选择器时 不提倡id重复 即id选择器只选中一个标签元素\n\t\t\t同id名是 目前的id选择器都将生效 效果和类选择器相同 但不推荐使用相同id\n（3）类选择器：使用类名选择一组相同类名的元素\n\t语法：.className&#123;&#125;,如 .类名&#123;&#125; \n（4）通配选择器：选中页面所有元素\n\t语法：*&#123;&#125; \n\n\np&#123;\n    这是元素选择器\n    color: red;\n&#125;\n#red&#123;\n     这是id选择器\n     color: red;\n&#125;\n.box&#123;\n    这是类选择器\n    color: red;\n&#125;\n*&#123;\n    这是通配选择器\n    效果和元素选择器 body&#123;&#125; 相同 选中所有元素\n&#125;\n2.复合选择器（1）交集选择器：选中同时复合多个条件的元素\n\t语法：选择器1选择器2选择器3&#123;&#125;  \n\t\t交集选择器中如果有元素选择器 需使用元素选择器开头\ndiv.box&#123;\n    这是一个交集选择器 选择一个类名为box的div元素\n    color:red;\n&#125;\n\n\t（2）并集选择器：同时选择多个选择器对应的元素\n     语法：选择器1,选择器2,选择器3&#123;&#125;\ndiv,span,h1&#123;\n    这是一个并集选择器 同时选中div，span，h1 三种标签\n    color: red;\n&#125;\n3.关系选择器\t\t父元素\n            - 直接包含子元素的元素叫做父元素\n        子元素\n            - 直接被父元素包含的元素是子元素\n        祖先元素\n            - 直接或间接包含后代元素的元素叫做祖先元素\n            - 一个元素的父元素也是它的祖先元素\n        后代元素\n            - 直接或间接被祖先元素包含的元素叫做后代元素\n            - 子元素也是后代元素\n        兄弟元素\n            - 拥有相同父元素的元素是兄弟元素\n\t \n\t\t（1）子元素选择器：选中指定父元素中的指定子元素\n\t\t\t语法：父元素 > 子元素\ndiv.box > span &#123;\n    选中类名为box的div中的span在子元素\n    color: red;\n&#125;\n\n\t\t(2)后代元素选择器：选中指定元素中的后代元素\n\t\t\t语法：祖先 后代\ndiv span&#123;\n    选中div中的span所有后代\n    color: red;\n&#125;\n\n\t(3)选择下一个兄弟\n\t\t\t语法:前一个 + 下一个\n\t   选择下边所有兄弟\n\t\t\t语法：兄 ~ 弟\n /* 选中类名叫demo的div中的第一个子元素的下一个兄弟 */\n          #test + span &#123;\n              color: red;\n          &#125;\n\n  /* 选中test后面的所有兄弟 */\n          #test ~ span&#123;\n              font-size: 40px;\n          &#125;\n4.属性选择器属性选择器：选择指定属性的标签元素\n\t\t语法：（1）[属性名=属性值] 选择含有指定属性和指定元素值的标签\n如 p[name=\"box\"]&#123;\n    选择name值等于“box”的p标签\n&#125;\n\t\t（2）选择属性值以指定值开头的元素  [属性名^=属性名]\n如 p[name ^= \"box\"]&#123;\n    选择name值以“box”开头的p标签\n&#125;\n\t\t（3）选择属性值以指定值结尾的元素  [属性名 $= 属性值]\n如p[name $= \"box\"]&#123;\n    选择name值以“box”结尾的元素的p标签\n&#125;\n\t\t（4）选择属性值中含有某值的元素  [属性名 *= 属性值]\n如 p[name *= \"box\"]&#123;\n    选择name值中含有“box”的p标签\n&#125;\n5.伪类选择器伪类选择器：伪类 （不存在的类 特殊的类 伪类用来描述一个元素的特殊状态）\n\t\t\t\t\t\t如：第一个子元素 被点击的子元素等\n\t\t\t\t\t\t语法： : 开头\n\t\t\t   :first-child 第一个子元素\n                :last-child 最后一个子元素\n                :nth-child() 选中第n个子元素\n                    特殊值：\n                        n 第n个 n的范围0到正无穷\n                        2n 或 even 表示选中偶数位的元素\n                        2n+1 或 odd 表示选中奇数位的元素\n\n                    - 以上这些伪类都是根据所有的子元素进行排序\n\n                :first-of-type\n                :last-of-type\n                :nth-of-type()\n                    - 这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序\n\n            - :not() 否定伪类\n                - 将符合条件的元素从选择器中去除\n\n /* 使用伪类选择器 选择 类名为demo 的ul 中的第一个li子元素 */\n        .demo > li:first-child&#123;\n            /* 这里选择第一个子元素 */\n            color: yellow;\n            font-size: 20px;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的最后一个li子元素 */\n        .demo > li:last-child&#123;\n            /* 这里选择最后一个子元素 */\n            color: skyblue;\n            font-size: 50px;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的第奇数个li子元素 */\n        .demo > li:nth-child(2n+1)&#123;\n            /* 这里选择第奇数个子元素 */\n            background-color: red;\n        &#125;\n          /* 使用伪类选择器 选择 类名为demo 的ul 中的第偶数个li子元素 */\n          .demo > li:nth-child(2n)&#123;\n            /* 这里选择第偶数个子元素 */\n            background-color: gray;\n        &#125;\n          /* 使用伪类选择器 选择 类名为demo 的ul 中的第一个span子元素 */\n          .demo > span:first-of-type&#123;\n            background-color: orange;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的除最后一个span子元素 */\n        .demo > span:not(:last-child)&#123;\n           font-size: 30px;\n        &#125;\n6.元素的伪类元素的伪类： 用于指定特殊元素 \n\t\t\t如 a标签的 link visited（这两个只有a标签能用） hover active\n  \t\t/* \n            :link 用来表示没访问过的链接（正常的链接）\n         */\n        a:link&#123;\n            color: red; \n        &#125;\n        /* \n            :visited 用来表示访问过的链接\n            由于隐私的原因，所以visited这个伪类只能修改链接的颜色\n        */\n        a:visited&#123;\n            color: orange; \n            /* font-size: 50px;   */\n        &#125;\n\n         button:hover&#123;\n             /* 点击按钮时按钮颜色变红 */\n             color: red;\n         &#125;\n\n         button:active&#123;\n             /* 点击按钮是按钮变大 */\n             width: 100px;\n         &#125;\n\n7.伪元素选择器伪元素选择器：\t表示页面中不真实存在的元素（特殊位置）\n\t\t\t\t伪元素 使用 :: 开头\n\t            ::first-letter 表示第一个字母\n                ::first-line 表示第一行\n                ::selection 表示选中的内容\n                ::before 元素的开始 \n                ::after 元素的最后\n                    - before 和 after 必须结合content属性来使用\n/* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的第一个字母 */\n        #demo::first-letter&#123;\n            /* 选中文本段第一个字母 */\n            font-size: 30px;\n            color: blue;\n        &#125;\n\n        /* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的开始 */\n        #demo::before&#123;\n            /* 选中文本段的起始 */\n            content: '##';\n        &#125;\n         /* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的末尾 */\n         #demo::after&#123;\n            /* 选中文本段的末尾 */\n            content: '##';\n        &#125;\n\n\t使用 ::before 和 ::after 时 加入的文本content也算第一个字母！！！","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"003-列表-超链接-图片-音视频","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/25/003-列表-超链接-图片-音视频/","content":"1.列表​    html中分为三种列表：有序，无序，定义列表\n&lt;!-- 有序列表 -->\n&lt;ul>\n    &lt;li>序号1&lt;/li>\n    &lt;li>序号2&lt;/li>\n    &lt;li>序号3&lt;/li>\n&lt;/ul>\n\n\n&lt;!-- 无序列表 -->\n&lt;ol>\n    &lt;li>无序1&lt;/li>\n    &lt;li>无序1&lt;/li>\n    &lt;li>无序1&lt;/li>\n&lt;/ol>\n\n&lt;!-- 定义列表\n\t使用dl创建定义列表 使用dt表示定义名 dd对定义进行说明\n-->\n&lt;dl>\n    &lt;dt>定义名&lt;/dt>\n    &lt;dd>解释说明&lt;/dd>\n&lt;/dl>\n日常中多使用有序列表 ul标签 在li标签中可嵌套使用 ul标签 实现列表嵌套\n2.超链接​    使用超链接标签可是将页面跳转到指定页面 或者是当前页面的指定位置\n&lt;!-- \n\t使用a标签 \n\t\t使用属性href 指定跳转的目标 目标可以是指定网站 也可以是服务器内部页面（使用相对路径）\n\t\t超链接是一个行内元素 在a标签内可以嵌套除了自身外的所有标签\n-->\n&lt;a href=\"http://www.baidu.com\">这是一个超链接&lt;/a>\n\n&lt;!--\n\thref 的target属性：\n\t\t_self: 超链接的默认属性 不写也可 效果为在当前网页打开链接\n\t\t_blank: 保留当前页面 在新的页面打开链接\n\t\n\thref的几个常用值：\n\t\t1.javascript:;  -> 此时点击链接什么都不会发生\n\t\t2.#  -> 此时点击链接会自动回到网页顶部\n\t\t3.标签id -> 此时点击链接将跳转到指定id标签的位置 使用标签id时 尽量不要重复id\n-->\n&lt;a href=\"www.baidu.com\" target=\"_blank\">点我在新页面打开链接&lt;/a>\n\n3.图片标签​    使用 img 标签向当前页面引入图片资源（外部图片）img 标签属于替换元素（介于块元素和内联元素之间）\n&lt;!-- \n\timg是自结束标签\n\timg 的属性：\n\t\t1.src：用于引入外部图片路径\n\t\t2.alt: 图片的描述 当浏览器加载不到图片时显示alt 搜索引擎使用alt来识别图片\n\t\t3.width: 图片的宽度（px）\n\t\t  height: 图片的高度 当图片的宽度或高度变化时 图片将按等比例缩放图片宽高\n-->\n&lt;img src=\"在这里引入图片路径\" width=\"200px/可不带单位\" alt=\"这是图片的描述\">\n\nsrc的资源路径可以是base64编码字符串\n\n4.内联框架​    使用 iframe 标签 用于在该页面引入其他页面\n&lt;!--\n\tiframe 属性：\n\t\t1.src：用于引入网页路径\n\t\t2.frameborder：指定内联框架的边框\n-->\n&lt;iframe src=\"https://www.bilibili.com\" width=\"1000\" height=\"600\" frameborder=\"1\">不支持iframe时将显示这行字！&lt;/iframe>\n5.音视频​    使用 audio 标签在页面引用外部音频文件\n&lt;!--\n        属性：\n            controls 是否允许用户控制播放 默认情况下不允许用户自己控制播放停止\n            autoplay 音频文件是否自动播放\n                - 如果设置了autoplay 则音乐在打开页面时会自动播放\n                    但是目前来讲大部分浏览器都不会自动对音乐进行播放 \n            loop 音乐是否循环播放\n\t\t\n\t\t还可通过在标签内使用source标签引入音频资源 这样的好处是可以是浏览器兼容解析合适的文件\n\t\t\t还可以在这里写入浏览器不支持audio标签的提示\n\t\tembed标签为IE8以下的浏览器所解析使用\n\n\t\tsource 和 embed 标签均为自结束标签！ \n\t\tembed 标签内 的type 为map 匹配 文件类型（audio/video）/文件后缀（mp3/mp4）\n-->\n&lt;audio src=\"./source/这里是路径.mp3\" controls autoplay loop>&lt;/audio>\n &lt;audio controls>\n        &lt;source src=\"./source/audio.mp3\">\n        &lt;source src=\"./source/audio.ogg\">\n        &lt;embed src=\"./source/audio.mp3\" type=\"audio/mp3\" width=\"300\" height=\"100\">\n     \t&lt;!--以上资源默认从上往下解析 对不起，您的浏览器不支持播放音频！请升级浏览器！ -->\n &lt;/audio>\n\n&lt;!-- \n        使用video标签来向网页中引入一个视频\n            - 使用方式和audio基本上是一样的\n     -->\n &lt;video controls>\n        &lt;source src=\"./source/flower.webm\">\n        &lt;source src=\"./source/flower.mp4\">\n        &lt;embed src=\"./source/flower.mp4\" type=\"video/mp4\">\n    &lt;/video>\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"002-语义化标签","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/23/002-语义化标签/","content":"1.语义化标签​    在使用html标签时关注标签的语义而不是样式，网页的样式由css文件决定；\n2.块元素​    块元素都是独占一行\n&lt;!-- \n\th1~h6六级标题都是块内元素 （block element）\n\t一般在行元素内不会放块元素\n           -->\n&lt;hgroup>使用该标签可以将标题分组，将同一组标题放入到hgroup中&lt;/hgroup>\n\n&lt;p>\n    p标签也是块元素 在p标签中不使用任何块元素\n&lt;/p>\n\n3.行内元素/内联元素页面中不会独占一行的称为行内元素（inline element）\n&lt;em>斜体标签 用于将选中的文本把变为斜体&lt;/em>\n&lt;strong>用于加粗选中的字体&lt;/strong>\n&lt;blockquote>\n    长引用 使用时会自动将选中的文本缩进且换行\n&lt;/blockquote>\n&lt;q>短引用 将选中的文本加引号强调&lt;/q>\n&lt;br> 换行标签 可连用\n4.结构化语义化标签​    html5新提供的结构化语义标签都属于块元素 效果都和div相同 常使用div标签\n&lt;!-- \n        header 表示网页的头部\n        main 表示网页的主体部分(一个页面中只会有一个main)\n        footer 表示网页的底部\n        nav 表示网页中的导航\n        aside 和主体相关的其他内容（侧边栏）\n        article 表示一个独立的文章\n        section 表示一个独立的区块，上边的标签都不能表示时使用section\n\n        div 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素\n        span 行内元素，没有任何的语义，一般用于在网页中选中文字\n\n      -->\n     &lt;header>头部&lt;/header>\n     &lt;main>主体&lt;/main>\n     &lt;footer>底部&lt;/footer>\n     &lt;nav>导航&lt;/nav>\n     &lt;aside>侧边栏&lt;/aside>\n     &lt;article>文章&lt;/article>\n     &lt;section> 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;/section>\n\n\tdiv和span较常用\n     &lt;div>&lt;/div>\n     &lt;span>&lt;/span>\n注意 若将标签写在根元素之外时 浏览器解析时会自动修改 但不一定会达到想要的效果\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"001-实体-meta标签","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/23/001-实体-meta标签/","content":"1.HTML结构​    HTML结构可分为以下三部分：\n&lt;html>\n    &lt;head>\n        &lt;!--在这里可以使用meta title标签 -->\n    &lt;/head>\n    &lt;body>\n        \n    &lt;/body>\n&lt;/html>\n2.HTML5的标识​    在html文件开头使用标签来区分html4与5的区别\n​    文档声明用来告诉浏览器当前网页的版本\n​        - html5的文档声明\n &lt;!doctype html>\n\n&lt;!Doctype HTML>\n3.HTML编码字符集​    常见的字符集：\n​        ASCII\n​        ISO88591\n​        GB2312\n​        GBK\n​        UTF-8，在开发时我们使用的字符集都是UTF-8\n4.meta标签​    该标签在主要用于设置一些网页中的元数据，元数据用于网站的搜索引擎检索，可以在此标签内指定网页的编码字符集，如下代码：\n&lt;!-- \n       meta主要用于设置网页中的一些元数据，元数据不是给用户看\n           charset 指定网页的字符集\n           name 指定的数据的名称\n           content 指定的数据的内容\n\n            keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开\n                 \n             description 用于指定网站的描述\n                   \n              网站的描述会显示在搜索引擎的搜索的结果中\n\n               title标签的内容会作为搜索结果的超链接上的文字显示  \n\t&lt;meta name=\"keywords\" content=\"HTML5,前端,CSS3\">\n    \t&lt;meta name=\"description\" content=\"这是一个非常不错的网站\">\n\t&lt;title>这是标题&lt;/title>\n\t&lt;meta> 标签支持 HTML 中的全局属性。\n    -->\n\t\n使用meta标签有http-equiv, name,scheme 属性可选 其对应的content值具体参照文档\n5.实体标签​    在 HTML 中，某些字符是预留的。\n​    在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。\n​    如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。\n使用方法： &amp;需转义的字符;(&amp; ;均是英文符号)\n常用的转义字符：\n\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"计算机网络复习","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/07/08/计网复习/","content":"期末计网复习重点第一章 计算机网络概述1.三网融合的概念从电信网络（向用户提供电话，电报及传真等服务），有线电视网（传送各种电视节目）和计算机网络（在计算机之间传送数据）三种各自分工到将电信网络和有线电视网络融入现代计算机网络，将三种网络融合成一种网络就能提供所有服务。\n2.计算机网络的定义及其分类定义：计算机网络主要是由一些通用的，可编程的硬件互连而成，而这些硬件并非专门用来实现某一特定目标，这些可编程的硬件能够用来传送各种不同类型的数据，并能支持广泛的和日益增长的应用。\n分类：按作用范围可分为：广域网（WAN），城域网（MAN），局域网（LAN），个人区域网（PAN）及无线个人区域网（WPAN）；\n按使用者类型可分为：公用网和专用网；\n3.互连网的定义和组成定义：计算机网络（网络）由若干结点和连接这些结点的链路组成。利用路由器将这些网络互连起来组成的网络叫做互连网（互连网是网络的网络）；\n组成：分为边缘部分和核心部分；\n边缘部分：由所有连接在互连网的主机组成，这部分是用户直接使用的，用来进行通信和资源共享。\n核心部分：由大量的网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的。\n4.客户-服务器通信方式（C/S方式）客户是服务请求方，服务器是服务提供方；（B/S方式是C/S方式的一种特例）这种方式的通信是双向的。\n5.分组交换，电路交换，报文交换路由器是实现分组交换的关键构件，其任务是转发收到的分组。\n交换是按照某种方式动态的分配传输路线的资源。\n通常把要发送的整块数据称为一个报文；\n在发送报文之前，把较长的报文划分为一个个更小的等长数据段，在数据段的前面加上一些由必要的控制信息组成的首部（包头，首部包含了目的地的地址和源地址等重要控制信息）后就构成了一个分组；\n电路交换：建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）；电路交换的用户在通话始终占用端到端的通信资源；\n分组转发采用存储转发技术；\n电路交换：整个报文的比特流连续的从源点直达终点；\n报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。\n分组交换：单个分组（报文的一部分）传送到相邻的结点，存储下来后查找转发表转发到下一个结点。\n若要连续传送大量数据且其传送时间远大于连接建立时间选择电路交换，在传送突发数据时选择报文交换和分组交换，分组交换比报文交换具有更好的灵活性和更低的时延性。\n6.计算机网络性能指标速率：数据的传送速率（数据率、比特率，bit/s）\n带宽：在计算机网络中，网络带宽表示在单位时间内网络中的某信道所能通过的最高数据率（bit/s）；\n吞吐量：表示在单位时间内通过某个网络的实际的数据量。\n时延：指数据从网络的一端到另一端所需的时间。\n​        （1）发送时延：指主机或路由器发送数据帧所需要的时间。发送时延=数据帧长度（bit）/发送速率（bit/s）；\n​        （2）传播时延：电磁波在信道中传播一定距离所花费的时间。传播时延=信道长度(m)/电磁波在信道上的传播速率(m/s)；\n​        （3）处理时延：主机或路由器在收到分组时需要花费一定时间进行处理；\n​        （4）排队时延：分组在经过网络传输时，要经过许多路由器，在进入路由器后要先在输入队列中排队等待处理。\n​        总时延=发送时延+传播时延+处理时延+排队时延\n时延带积宽：时延带积宽=传播时延*带宽\n往返时间RTT：双向交互一次所需的时间；\n信道利用率:指出某信道有百分之几的时间是被利用的；\n网络利用率：全网络的信道利用率的加权平均值；\n信道或网络的利用率过高会产生非常大的时延；\n7.分层、透明分层：相互通信的两个计算机系统必须高度的协调工作，分层可将庞大而复杂的问题转化为若干较小的局部问题，这些较小的问题易于研究和处理。\n透明：指存在但不干预即：计算机中存在的,但对于某些人员而言又不需要了解的东西,这就是计算机所指的透明性.简单的说就是:计算机中存在,但你不需要了解的.使用本层服务的实体只能看见服务而无法看见下面一层的协议。集协议对上层实体是透明的。\n8.网络协议、实体、服务、服务访问点网络协议：为进行网络中的数据交换而建立的规则，标准或约定称为网络协议（协议）；协议是控制两个对等（或对个）实体进行通信规则的集合；在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，要实现本层协议需要使用下面一层的提供的服务。\n实体：表示任何可发送或接受信息的硬件或软件进程；\n服务：协议是水平的，服务是垂直的，服务是由下层向上层通过层间接口提供的，只有那些能被上层实体看见的功能才称为服务；\n服务访问点：在同一系统中相邻两层的实体进行交互的地方；\n9.体系结构计算机网络的各层及其协议的集合就是网络的体系结构，是这个计算机网络及其所有构件所应完成的功能的精确定义。\n\n应用层：直接为用户的应用进程提供服务；通过应用进程间的交互来完成特定网络应用。应用层交互的数据单元称为报文；\n运输层：负责向两台主机中的进程之间的通信提供通用的数据传输服务；\n​                运输层主要使用以下两种协议：\n​                （1）传输控制协议TCP：提供面向连接的，可靠的数据传输服务，其数据传输单位是报文段；\n​                （2）用户数据报协议UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报；\n网络层：负责为分组交换网上的主机提供通信服务；\n数据链路层：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送帧。使每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）；\n物理层：物理层的任务就是透明地传送比特流。为数据端设备提供传送数据的通路；传输数据；在物理层上所传送的数据单位是比特；\n\n\n第二章 物理层1.物理层的四大规程物理层考虑的是怎样在连接各种计算机的传输媒体上传输数据比特流；物理层的协议称为规程，物理层的主要任务是确定与传输媒体的接口有关的一些特性；数据在通信线路（传输媒体）上的传输一般为串行传输；\n机械特性：指明接口所用的接线器的形状和尺寸，引脚数目和排列，固定和锁定装置等；\n电气特性：指明在接口电缆的各条线上出现的电压的范围；\n功能特性：指明某条线上出现的某一电平的电压的意义；\n过程特性：指明对于不同功能的各种可能事件的出现顺序；\n2.通信基础知识数据是运送消息的实体；\n信号是数据的电气或电磁的表现；可分为模拟信号（连续信号，消息的参数的取值是连续的），数字信号（离散信号，消息的参数的取值是离散的）；\n信道：表示向某一个方向传送信息的媒体，一条通信电路往往包含一条发送信道和接受信道；\n调制：数字比特流转换为模拟信号；（基带调制：数字信号到数字信号；带通调制：数字信号到模拟信号）\n解调：模拟信号转换为数字比特流；\n调制方法：调频、调幅、调相；\n从通信双方信息交互的方式可分为：单工通信（电视广播，只有一个方向）、半双工通信（双向交替通信需要两条信道）、全双工通信（双向同时通信需要两条信道）；\n曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1，反过来定义也可以；\n差分曼彻斯特编码：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1；\n基本的带通调制方法\n​    （1）调幅（AM）：载波的振幅随基带数字信号而变化；\n​    （2）调频（FM）：载波的频率随基带数字信号而变化；\n​    （3）调相（PM）：载波的初始相位随基带数字信号而变化；\n3.常见的有线传输介质双绞线：\n​        568a的排线顺序从左到右依次为：白绿、绿、白橙、蓝、白蓝、橙、白棕、棕。 568b则为：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕。​        正线，即直通线 ，标准568B）：两端线序一样，从左至右线序是：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。​        反线，即交叉线 ，（568A）：一端为正线的线序，另一端为从左至右：白绿，绿，白橙，蓝，白蓝，橙，白棕，棕。​        交叉线是指：一端是568a标准，另一端是568b标准的双绞线；​        直连线则指：两端都是568a或都是568b标准的双绞线。​        相同设备用直通线，不同设备用交叉线，除了主机和路由器用交叉线；​        反线也是交叉线；同轴电缆（利用光的全反射）光缆：多模光纤适用于短距离传输、单模光纤使用远距离传输\n4.复用技术复用：上层多个进程可同时使用下面层提供的服务；\n分用：下层将收到的数据分别交付给上层相应的进程；\n频分复用：所有用户在同样的时间内占用不同的带宽资源（频率带宽）；\n时分复用（同步时分复用）：所有用户在不同的时间占用同样的频带宽度；有利于数字信号传输；\n统计时分复用（异步时分复用）：改进的时分复用，提高信道利用率；\n波分复用：光的频分复用（利用光的波长）；\n码分复用（码分多址）：每一个用户可以在同样的时间使用同样的频带进行通信，不同的码型可避免干扰；\n​        将码片（每一个比特时间再划分为m个短的间隔）的0记为**-1，将1记为+1**；\n​        CDMA系统内每个站分配的码片序列各不相同且正交（内积为0）；每个码片与自己本身内积为1；每个码片和自己的反码内积为**-1**；\n5.有线宽带接入技术ADSL技术（非对称数字用户线技术）：是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务；\nHFC网（光纤同轴混合网）：在有线电视的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话，数据和其他宽带交互型业务；\nFTTx技术：为提高居民的上网速率提出FTTH技术（光纤到户技术），从而出现了多种宽带光纤接入技术FTTx，就是把光电转换的地方从用户家向外延伸到离用户家门口有一定距离的地方（从H到x）；\n\n第三章 数据链路层点对点信道：使用一对一的点对点通信方式的信道；\n广播信道：使用一对多的广播方式的信道；\n局域网属于数据链路层范围，在同一个局域网中，分组从一台主机转发到另一台主机不经过路由器转发；\n链路：从一个结点到相邻结点的一段物理线路（有线或无线），中间没有其他交换节点；\n帧：数据链路层的协议数据单元；由帧首部+数据部分（IP数据报）+帧尾部构成；\n数据链路：具有必要的通信协议（控制数据传输）的软硬件构成的链路；常使用网络适配器来实现这些协议；数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出上交到网络层，网络层的协议数据单元是IP数据报（数据报，分组，包）；\n1.数据链路层三个基本问题封装成帧：就是在一段数据的前后分别添加首部和尾部\n​      首部和尾部的一个很重要的作用就是进行帧定界（帧定界符的控制字符SOH(十六进制 01)放在帧的最前面，表示帧的开始，EOT(十六进制 04)放在帧尾，表示帧的结束）此外，首部和尾部还包括许多必要的控制信息。发送帧时从帧首部开始发送；\n透明传输：\n​     “透明”表示某个实际存在的事物看起来却好像不存在一样,在数据链路层透明传送数据表示无论什么样的比特组合的数据，都能够按照原样没有差错的通过数据链路层；\n​      解决透明传输的办法是字节填充（字符填充）：\n​        1.发送端的数据链路层在数据中出现了控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”（其16进制为1B），而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。\n​        2.如果转义字符也出现在数据当中，那么就在转义字符前面插入一个转义字符，当接收端收到两个连续的转义字符时，就删除其中前面的一个。\n差错检测（CRC循环冗余校验）：\n比特差错：在传输过程中可能会产生差错，0变成1或1变成0；\n传输差错：帧丢失，帧重复，帧失序；\n【例子】：除数M为101001 除数P（x）=X3+X2+1 此时除数P=1101\n​    被除数后要补比除数位数少一个0，这里为4-1=3个0\n​    在运算过程中不借位，余数最高位位为1则上1。\n则发送的数据为101001001\n在接收端对收到的每一帧经过CRC检验后，有两种情况：\n​    1.若得出余数为0，则判定这个帧没错，接受\n​    2.若余数不为0，则判定这个帧有差错（但无法确定是哪里出现了差错），丢弃\n注意：CRC不是“可靠传输”，只能做到无差错接受，即“若只在数据链路层使用CRC差错检测技术，凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”；\n2.点对点协议PPPPPP协议是用户计算机和ISP进行通信时所使用的的数据链路层协议；\nPPP协议的特点：\n（1）简单：他提供不可靠的数据包服务，对于数据链路层的帧不需要纠错，不需要序号，也不需要流量控制（只进行CRC检验，正确就收下，错误就抛弃）；\n（2）封装成帧：规定特殊的字符作为帧定界符；将数据报封装成帧；\n（3）透明性：保证数据传输时的透明性；\n（4）多种网络协议：必须能够在同一条物理链路上同时支持多种网络层协议（如IP和IPX）；\n（5）多种类型链路：必须能够在多种链路上运行（串行的，并行的，同步的，异步的等）；\n（6）差错检测：必须能够对接收端收到的帧进行检测，并立即抛弃有差错的帧；\n（7）检测连接状态：必须具有自动检测链路是否处于正常工作状态的机制；\n（8）最大传送单元：必须对每一种类型的点链路设置最大传送单元（MTU）的标准默认值；\n（9）网络层地址协商：必须提供一种使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址的机制；\n（10）数据压缩协商：必须提供一种方法来协商使用数据压缩算法；\nPPP协议的组成：一个将IP数据报封装成串行链路的方法；一个用来建立，配置和测试数据链路连接的链路控制协议LCP；一套网络控制协议NCP；\n3.局域网常见拓扑星型网、环形网、总线网；\n4.网卡的功能计算机与外界局域网的连接是通过通信适配器进行的。在主机箱内插入的一块网络接口板又称为网络接口卡NIC（网卡）；\n适配器的一个重要功能是进行数据串行传输和并行传输的转换。对数据进行缓存，在计算机的操作系统安装设备驱动程序；\n适配器还要能够实现以太网协议；\n5.CSMA/CD在同一时间内只能允许一台计算机发送数据，因此采用一种协调协议CSMA/CD（载波监听多点接入/碰撞检测）;\n工作原理：载波监听（检测信道）；信道忙时停止发送（忙则等待），信道空闲时才进行发送；碰撞检测（边发送边监听，若发生碰撞则暂停）；使用截断二进制指数退避算法确定碰撞后重传时机；发送强干扰信号强化碰撞；\n6.MAC地址、MAC帧格式、无效帧无效帧：凡长度小于64字节的帧都是由于冲突而异常中止的无效帧\nMAC地址：在局域网中，硬件地址又称为物理地址或MAC地址；实际上就是适配器地址或适配器标识符；\nMAC帧格式：两种标准，一种是DIX Ethernet V2标准，一种是IEEE 802.3标准；\n以太网V2的Mac帧由五个字段组成，前两个字段分别为6字节长的目的地址和源地址，第三个字段是2字节的类型字段（标志上一层使用的协议），第四个字段是数据字段，第五个字段是四字节长的帧检验序列FCS；\n\n7.集线器、网桥的工作原理集线器：以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，集线器类似于一个多接口的转发器，集线器工作在物理层，它的每个接口仅仅简单地转发比特；\n网桥的工作原理：多接口的网桥实质就是交换机；网桥对收到的帧根据其MAC帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是根据此帧的目的MAC地址，查找网桥中的地址表，然后确定将该帧转发到哪一个接口，或者是把它丢弃。\n网桥带来的好处：1.过滤通信量；\n​                            2.扩大了物理范围；\n​                            3.提高了可靠性；\n​                            4.可互连不同的物理层、不同的MAC子层和不同速率的局域网；\n8.虚拟局域网的概念、原理虚拟局域网的概念：VLAN是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪个VLAN；\n虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN标记。\n原理：VLAN中的端口成员不是按照物理地址划分的，所以一个VLAN也可以跨越多台物理交换机，这就是VLAN中继(Trunk)功能，在不同的交换机上可以有相同的VLAN，而且不同交换机上相同的VLAN是可以相互通信的，可以把相同的VLAN在不同物理交换机在逻辑上看作存在物理连接，因此自然可以相互通信。\n\n第四章 网络层1.网络层提供的两种服务\n\n\n对比的方面\n虚电路服务\n数据报服务\n\n\n\n思路\n可靠通信应当由网络来保证\n可靠通信应当由用户主机负责\n\n\n连接的建立\n必须有\n不需要\n\n\n重点地址\n仅在建立连接时使用，每个分组使用短的虚电路号\n每个分组都有终点的完整地址\n\n\n分组的转发\n属于同一条虚电路的分组均按照同一路由进行转发\n每个分组独立选择路由进行转发\n\n\n当结点出故障时\n所有通过出故障的结点的虚电路均不能工作\n出故障的结点可能会丢失分组，一些路由可能会发生变化\n\n\n分组的顺序\n总是按发送顺序达到终点\n达到终点的时间不一定按发送顺序\n\n\n端到端的差错处理和流量控制\n可以由网络负责，也可以由用户主机负责\n由用户主机负责\n\n\n2.IP地址IP地址：: :={&lt;网络号&gt;,&lt;主机号&gt;}\nIP地址在全世界范围内是唯一的32位的标识符；一个网络号在整个互联网范围内必须是唯一的；一台主机号在其网络号声明的网络范围内必须是唯一的；\nIP地址是一种分等级的地质结构。IP地址管理机构在分配IP地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号来转发分组。\n分类的IP地址是由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别为指明IP地址的类别。\n一个IP地址在整个互联网范围内是唯一的。分类的IP地址包括A类、B类和C类地址（单播地址），以及D类地址（多播地址）。E类地址未使用。A类    1126    B类128191        C    192223        D    224239        127用于环路测试\n3.ARP协议（地址解析协议）的原理地址解析协议ARP把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。ARP的高速缓存可以大大减少网络上的通信量。\nARP步骤：        1.ARP进程在本局域网上广播发送一个ARP请求分组。\n​        2.在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组。\n​        3.若有主机的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向(发送ARP请求分组的)主机发送ARP相应分组，同时在这个ARP相应分组中写入自己的硬件地址。由于区域的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理财这个ARP请求分组。（注意：ARP请求分组是广播发送，但ARP响应分组是单播的）。\n​        4.(发送ARP请求分组的)主机接收到ARP响应分组后，就在其ARP高速缓存中写入响应主机的IP地址到硬件地址的映射。\n4.IP协议首部格式\n首部的固定部分长度固定为20字节，固定部分后面的是可选字段，长度可变；\n版本：占4位，值IP协议的版本；\n首部长度：占4位，可表示的最大十进制数是15；\n区分服务：占8位，用来获得更好的服务；\n总长度：指首部和数据之和的长度，占16位；可表示的数据报最大长度为65535字节；\n标识：占16位，相同的标识字段的值使分片后的各数据报片最后能正确的重装为原来的数据报；\n标志：占3位，MF=1表示后面还有分片，MF=0表示这是最后一个分片；DF=0表示不能分片，等于0时才能分片；\n片漂移：占13位，片漂移指出较长的分组在分片后某片的在原分组的相对位置；\n5.分组转发算法(1)从数据报的首部提取目的主机的IP地址D,得出目的网络地址为N.\n(2)若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机(这里包括把目的主机地址D转换为具体的硬件 地址，把数据报封装为MAC帧，再发送此帧)；否则就是间接交付，执行(3)。\n(3)若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。\n(4)若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(5)。\n(5)若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。\n(6)报告转发分组出错。\n6.划分子网在IP地址中添加子网号字段，使两级IP地址变为三级IP地址；从主机号借用若干位作为子网号，主机号也相应减少同样的位数；\nIP地址  : :={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}\n\n7.无分类编址CIDR（构造超网）IP地址 : :={&lt;网络前缀&gt;,&lt;主机号&gt;}\n​        无分类域间路由选择CIDR是解决目前IP地址紧缺的一个方法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所占的位数，如（128.14.5.7/20）。前缀用来指明网路，前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”。IP地址的分配都以CIDR地址块为单位；\n​        CIDR的32位地址掩码（子网掩码）由一串1或一串0组成，而1的个数就是前缀的长度。只要把IP地址和地址掩码逐位进行“逻辑与(and)”运算，就很容易得出网络地址。A类地址的默认地址掩码是255.0.0.0。B类地址的默认地址掩码是255.255.0.0。C类地址的默认地址掩码是255.255.255.0；\n8.最长前缀匹配查找路由表时应当从匹配结果中选择具有最长网络前缀的路由；\n9.二叉线索查找路由表先找出对应于每一个IP地址的唯一前缀，通过唯一前缀构造二叉线索；\n10.ICMP（网际控制报文协议）在网际层使用ICMP协议提高IP转发数据报和提高交付成功的机会；ICMP报文是装在IP数据报中，作为其中的数据部分；\nICMP报文分为ICMP差错报告报文和ICMP询问报文；\n\n\n11.IPv6概念及地址长度由于IPv4的地址已耗尽，所以有了IPv6；IPv6的地址使用冒号十六进制记法；IPv6数据报的目的地址可以是一下三种基本类型地址之一：单播，多播，任播。IPv6数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所以的扩展首部和数据；结合起来叫做数据报的有效载荷或净负荷。IPv6主要带来的变化是：1更大的地址空间；2 灵活的首部格式；3 改进的选项；4支持即插即用；5支持资源的预分配；6 IPv6的首部改为8字节对齐。IPv6的地址长度是128位地址（补充IPv4是32位，MAC是48位）；\n12.静态路由、路由选择协议（RIP、OSPF）静态路由选择也叫非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。\n互联网把路由选择协议划分为内部网关协议IGP和外部网关协议EGP；\n内部网关协议RIP（路由信息协议），很少被使用，RIP是一种分布式的基于距离向量的路由选择协议；优点是简单；RIP协议的距离也称为跳数；距离等于16时相当不可达，RIP只适应于小型互联网；\n\nRIP协议特点：\n1仅和相邻的路由器交换信息；\n2交换的信息是当前本路由器所知道的全部信息，即自己的路由表；\n3按固定时间间隔交互信息。\n距离向量算法：1 从相邻的 X 路由器接收发送过来的 RIP（Routing Information Protocol） 报文；2 将该 RIP 报文中的下一跳地址修改为 X，且跳数增加 1；3 对每个项目执行如下步骤；    a.若原路由表没有 RIP 中的目的网络 N，直接添加到原路由表中；    b.若原路由表中有 RIP 中的目的网络 N，但下一跳地址不是 X ，选择跳数少的替换。如果两者跳数一样，则保留原路由表的项。    c.若原路由表中有 RIP 中的目的网络 N，且下一跳地址是 X，使用收到的项替换；4若超过 180s （RIP 默认 180s）还没有收到相邻路由器的更新路由表，则相邻路由器置为不可达，跳数为 16；\n\n内部网关协议OSPF（开放最短路劲优先）\nOSPF：OSPF使用分布式的链路状态协议。OSPF的更新过程收敛的快；特点：\n1.向本自治系统中所有路由器发送信息，采用洪泛法；\n2.发送的信息就是与本路由器相邻的所有路由器的链路状态；\n3.当链路状态发生变化时才回发送信息；\n\nRIP配置过程Router（config）#router ripRouter（config- router）#version 2Router（config- router）#network 192.167.100.0（ip地址）Router（config- router）#network 10.1.1.0Router（config- router）#no auto-summaryOSPF配置过程Router（config）#router ospf 1Router（config- router）#network 10.1.1.0  0.0.0.255  area 0\n\n13.路由器的组成和工作原理路由器结构可划分为两大部分：路由选择部分和分组转发部分；\n路由选择部分也叫做控制部分，其核心构件是路由选择处理机，它的任务是根据路由协议构造，更新和维护路由表；\n分组转发部分又三部分组成：交换结构，一组输入端口和一组输出端口，这里的端口是硬件接口；\n交换结构的任务就是根据转发表对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去；\n14.VPN 的原理，NAT 和 NAPT 的作用专用地址（内部地址）只能用于一个机构的内部通信，不能用于和互联网上的主机通信；\n虚拟专用网VPN：利用共用的互联网作为本机构各专用网之间的通信载体。三个专用地址块：（1）10.0.0.0到10.255.255.255（24位块）（2）172.16.0.0到172.31.255.255（20位块）（3）192.168.0.0到192.168.255.255（16位块）两个专用网之间通过IP隧道进行通信。网络地址转换NAT的作用是：它实现内网的IP地址与公网的地址之间的相互转换，将大量的内网IP地址转换为一个或少量的公网IP地址，减少对公网IP地址的占用。网络地址与端口号转换NAPT（实际上就是使用端口号的NAT）；\n\n第五章 运输层1.运输层的功能运输层向它上面的应用层提供通信服务，运输层为应用进程间提供端到端的逻辑通信；运输层具有复用（发送方不同的应用进程都可以使用同一个运输层协议传送数据）和分用（接收方的运输层在剥去报文的首部后能够把数据正确交付应用进程）功能；\n2.运输层的端口为了在通信中识别主机的应用进程，在运输层使用协议端口号，这是一种软件端口，端口只具有本地意义；\n\n3.UDP的特点、首部格式用户数据报协议UDP的特点：\n1.UDP是无连接的；\n2.UDP使用尽最大努力交付，不保证可靠交付；\n3.UDP是面向报文的；\n4.UDP没有拥塞控制；\n5.UDP支持一对一，一对多，多对一和多对多的交互通信；\n6.UDP的首部开销小只有8字节；\nUPD的首部格式：\n1.源端口：源端口号。在需要对方回信时选用，不需要时全为0；\n2.目的端口：目的端口号，在终点交付报文时使用；\n3.长度：UDP用户数据报的长度，最小值为8；\n4.检验和：检测UDP用户数据报在传输中是否有错，有错就丢弃；\n\n\n4.TCP的特点、可靠传输实现传输控制协议TCP的特点：\n1.TCP是面向连接的运输层协议；\n2.每一条TCP连接只能有两个端点。每一条TCP连接只能是点对点的；\n3.TCP提供可靠交付的服务；\n4.TCP提供全双工通信；\n5.面向字节流；\nTCP连接的端口叫套接字或插口；\n套接字 socket = （IP地址：端口号）\n每一条TCP连接唯一的 被通信两端的两个端点（即两个套接字）所确定；\nTCP连接 : : ={socket1，socket2} = {（IP1：port1），（IP2：port2）}\n可靠传输的实现：停止等待协议，连续ARQ协议；\n\nTCP报文段的首部格式：首部的前20个字节是固定的，所以TCP首部最小长度是20字节；\n\n\n首部固定部分各字段意义如下：\n1） 源端口和目的端口：各占2个字节，分别写入源端口和目的端口。\n2） 序号：占4字节。序号范围是【0，2^32 - 1】，共2^32（即4294967296）个序号。序号增加到2^32-1后，下一个序号就又回到0。也就是说，序号使用mod 2^32运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。\n3） 确认号      占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。\n   总之：若确认号为= N，则表明：到序号N-1为止的所有数据都已正确收到。\n\n4） 数据偏移         占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。\n5） 保留          占6位，保留为今后使用，但目前应置为0 。\n下面有6个控制位，用来说明本报文段的性质。6） 紧急URG（URGent）        当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。\n   当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。\n\n7） 确认ACK（ACKnowledgment）      仅当ACK = 1时确认号字段才有效，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。\n8） 推送 PSH（PuSH）    当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。\n9） 复位RST（ReSeT）       当RST=1时，表名TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。\n10） 同步SYN（SYNchronization）       在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。\n11） 终止FIN（FINis，意思是“完”“终”）          用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。\n12） 窗口             占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。\n  例如，发送了一个报文段，其确认号是701，窗口字段是1000.这就是告诉对方：“从701算起，我（即发送方报文段的一方）的接收缓存空间还可接受1000个字节数据（字节序号是701~1700），你在给我发数据时，必须考虑到这一点。”\n\n  总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。\n\n13） 检验和       占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。\n14） 紧急指针            占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。\n15） 选项       长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。\n   TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie）。注意MSS这个名词含义。MSS是每一个TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。\n\n   为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）才能组装成一个IP数据报。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。\n\n   因此，MSS应尽可能大些，只要在IP层传输时不需要分片就行。由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要的分片的MSS，如果改走另一条路径就可能需要进行分片。因此最佳的MSS是很难确定的。在连接过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传输数据，两个传送方向可以有不同的MSS值。若主机未填写这一项，则MSS的默认值是536字节长。因此，所有在互联网上的主机都应该接受的报文段长度是536+20（固定首部长度）=556字节。\n\n后来又增加了几个选项如窗口扩大选项、时间戳选项等。\n  窗口扩大选项是为了扩大窗口。我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。\n\n   窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2^（16+14）-1=2^30-1。\n\n   窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=0选项，使窗口大小回到16。\n\n时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念：\n  第一、 用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。\n\n   第二、 用于处理TCP序号超过2^32的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加2^32个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。例如，当使用1.5Mbit/s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。\n\n\nTCP可靠传输的实现\n\nTCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。\nTCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。\nTCP 两端的四个窗口经常处于动态变化之中。\nTCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。\n\n1.以字节为单位的滑动窗口技术；\n2.超时重传时间的选择 ；\n3.改进的确认——选择确认(SACK)；\nTCP的流量控制：让发送方的发送速率不要太快，要让接收方来得及接受；（利用滑动窗口来实现）\n5.TCP的拥塞控制拥塞：在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏；\n拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载；这是一个全局性的过程；\nTCP的拥塞控制方法：慢开始，拥塞避免，快重传，快恢复；\n6.随机早期检测算法 RED 算法主动队列管理：当路由器的队列长度达到某个警惕值时主动丢弃到达的分组；（利用RED算法实现）\nRED算法：使路由器维持队列最小门限和最大门限两个参数；按规定计算当前的平均队列长度；\n（1）若平均队列长度小于最小门限，则将新到达的分组放入队列进行排队；\n（2）若平均队列长度大于最大门限，则将新到达的分组丢弃；\n（3）若平均队列长度处于最小门限和最大门限之间，则按某一丢弃概率p丢弃新到达的分组；\n7.TCP连接的管理TCP的运输连接阶段分为：连接建立，数据传送和连接释放；\nTCP的连接建立（三次握手）：\n（1）请求连接：客户端发送SYN=1，seq=x的报文段向服务器请求建立连接（不携带数据）；\n（2）同意连接：服务器收到请求后向客户端发送SYN=1，ACK=1，seq=y，ack=x+1的报文同意建立连接（不携带数据）；\n（3）确认连接：客户端收到同意后想服务器发送ACK=1，seq=x+1，ack=y+1的报文确认连接（可携带数据）；\n\n**TCP的连接释放(四次握手)**：\n\n\n第六章 应用层1.DNS的工作原理域名系统DNS是互联网使用的命名系统；用来把机器名字转换为IP地址；\n域名服务器分四种：（1）    根域名服务器（知道所有顶级域名服务器和IP地址）（2）    顶级域名服务器（3）    权限域名服务器（4）    本地域名服务器\n域名的解析过程分两步第一：主机向本地域名服务器的查询本地服务器用递归查询。第二：本地域名服务器向根域名服务器的查询用迭代查询。\n\n解析顺序\n　　1） 浏览器缓存\n　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；\n　　2） 系统缓存\n　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；\n　　3） 路由器缓存\n　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；\n　　4） ISP（互联网服务提供商）DNS缓存\n　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；\n　　5） 根域名服务器\n　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；\n　　6） 顶级域名服务器\n　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；\n　　7） 主域名服务器\n　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；\n　　8）保存结果至缓存\n　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。\n2.FTP 的工作原理文件传输协议FTP1.FTP的基本工作原理：主进程的工作步骤：(简答题)（1）    打开熟知端口（端口号为21），使客户进程能够连接上。（2）    等待客户进程发出连接请求。（3）    驱动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。（4）    回到等待状态，继续接受其他客户进程发来的请求。\nFTP的客户和服务器之间要建立两个并行的TCP连接：控制连接和数据连接\n3.电子邮件的工作原理1.电子邮件的一些标准：发送邮件的协议：SMTP读取邮件的协议：POP3和IMAP多用途互联网邮件扩展类型：MIME(在邮件首部说明邮件的数据类型如声音……)\n\n   计算机之间发送和接收电子邮件的几个重要步骤：（简答题）（1）    发件人调用计算机中的用户代理撰写和编辑要发送的邮件（2）    发件人点击屏幕上的“发送邮件”按钮，把发送邮件的工作全交给用户代理来完成。（3）    SMTP服务器收到用户代理发来的邮件后，就把邮件临时存放在邮件缓存队列中，等待发送到接受方的邮件服务器（4）    发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP服务器建立TCP连接，然后把邮件缓存队列中的邮件一次发送出去（5）    运行在接受方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取（6）    收件人在打算收信时，就在运行计算机中的用户代理，使用POP3（或IMAP）协议读取发送给自己的邮件\n\n电子邮件地址的格式：TCP/IP体系的电子邮件系统规定电子邮件地址的格式如下： 收件人邮箱名@邮箱所在主机的域名 例子：&#x78;&#x69;&#101;&#120;&#x69;&#x65;&#114;&#x65;&#110;&#x40;&#x74;&#x73;&#x69;&#x6e;&#x67;&#104;&#x75;&#x61;&#x2e;&#x6f;&#114;&#103;&#x2e;&#x63;&#110;\n\n\n简单邮件传送协议SMTPSMTP通信的三个阶段：（1）    建立连接（主机的SMTP客户与接收主机的SMTP服务器的连接）（2）    邮件的传送（邮件的传送从MAIL命令开始）（3）    连接释放（邮件发送完毕后，SMTP客户发送OUIT命令）\n4.WWW 的四大问题及解决方法（1）怎样标志分布在整个互联网上的万维网文档？使用统一资源定位符URL；\n（2）用什么协议来实现万维网上的各种链接？使用超文本传送协议HTTP；\n（3）怎么使不同作者创造不同风格的万维网文档并显示在主机上？使用超文本标记语言HTML；\n（4）怎么样使用户很方便的查找信息？使用搜索引擎；\n5.DHCP的工作原理动态主机配置协议DHCP\n原理：动态主机设置协定（DHCP）是一种使网络管理员能够集中管理和自动分配IP网络地址的通信协议。在IP网络中，每个连接Internet的设备都需要分配唯一的IP地址。DHCP使网络管理员能从中心结点监控和分配IP地址。当某台计算机移到网络中的其它位置时，能自动收到新的IP地址。\n连接到互联网的计算机的协议软件需要配置的项目：（1）    IP地址；（2）    子网掩码；（3）    默认路由器的IP地址；（4）    域名服务器的IP地址；\n\n习题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["计算机网络复习"],"tags":["计算机网络"]},{"title":"Hexo环境搭建","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/02/21/Hexo环境搭建/","content":"1.1 创建博客项目安装Hexo\nnpm install -g hexo-cli\n初始化博客项目\nhexo init dm-blog\n进入项目文件夹，安装相关依赖\nnpm install\n目录结构\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n打开_config.yml，配置基本信息\n# Site\ntitle: 淡漠Blog\nsubtitle: &#39;&#39;\ndescription: &#39;淡漠DM的博客&#39;\nkeywords:\nauthor: 淡漠DM\nlanguage: zh-CN\ntimezone: &#39;&#39;\n启动项目\nhexo s\n\n\n常用命令介绍\n\n\n\n命令\n简写\n含义\n\n\n\nhexo server\nhexo s\n本地启动\n\n\nhexo generate\nhexo g\n生成静态文件\n\n\nhexo deploy\nhexo d\n部署网站\n\n\nhexo clean\n无\n清除缓存及生成的静态文件\n\n\n1.2 修改主题选择自己喜欢的主题\nhttps://hexo.io/themes/\n这里选择Kaze\n进入themes文件夹，下载主题，并重命名为kaze\ncd themes\ngit clone https:&#x2F;&#x2F;github.com&#x2F;theme-kaze&#x2F;hexo-theme-Kaze.git kaze\n修改配置文件（_config.yml）\ntheme: kaze\n主题名称为文件夹名称，默认为：landscape\n回到项目根目录，启动项目\nhexo clean\nhexo g\nhexo s\n1.3 完善博客项目1.3.1 修改基本信息进入themes/kaze/source ，创建文件夹 img，放入logo图片和作者头像\ntitle: 淡漠Blog\nauthor: 淡漠DM\nlogo_img: &#x2F;img&#x2F;logo.png # put the logo on the $&#123;blog_path&#125;&#x2F;source&#x2F;img&#x2F;$&#123;picname&#125;.png or use urls\nauthor_img: &#x2F;img&#x2F;author.jpg\nauthor_description: 最有趣的编程，莫过于服务生活。\n1.3.2 开启站点访问量统计（默认关闭）footer:\n  statistics:\n    enable: true\n    type: busuanzi # now version only supports busuanzi\n    pv:\n      enable: true\n      style: 本站总访问量&#123;&#125;次 # the style will be shown as $1&#123;pv&#125;$2\n    uv:\n      enable: true\n      style: 本站总访客数&#123;&#125;次\nenable 开启访问量统计（默认关闭）\ntype&#96; 目前仅支持 &#96;busuanzi\npv 访问总量统计\nuv 用户总量统计\n1.3.3 友链links:\n  小R资源:\n    url: https:&#x2F;&#x2F;www.tomyres.com\n    avatar: https:&#x2F;&#x2F;www.tomyres.com&#x2F;static&#x2F;images&#x2F;logo&#x2F;res_logo_1.png\n    description: 小R资源,免费的编程资源在线分享\n1.3.4 文章头部hello-world.md\n---\ntitle: Hello World\nbanner_img: https:&#x2F;&#x2F;www.tomyres.com&#x2F;static&#x2F;images&#x2F;logo&#x2F;res_logo_1.png\ncategory: Hi\ntag: hello\nexcerpt: 这是一段简介\n---\nbanner_img 文章封面\ncategory 分类\ntag 标签\nexcerpt 简介\n1.3.5 代码高亮在md文件写一段JavaScript代码\n​&#96;&#96;&#96;javascript\nconst smoothScrollToTop &#x3D; () &#x3D;&gt; &#123;\n  let yTopValve &#x3D; (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop);\n  if (yTopValve &gt; 1) &#123;\n    window.requestAnimationFrame(smoothScrollToTop);\n    scrollTo(0, Math.floor(yTopValve * 0.85));\n  &#125; else &#123;\n    scrollTo(0, 0);\n  &#125;\n&#125;;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  document.getElementById(&#39;scrollbutton&#39;).onclick &#x3D; smoothScrollToTop;\n&#125;, 0);\n​&#96;&#96;&#96;\n关闭 highlight，开启 prismjs（_config.yml）\nhighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: true\n  line_number: true\n  tab_replace: &#39;&#39;\n设置主题（kaze/_config.yml）\nprism:\n  theme: tomorrow\n1.3.6 评论这里使用 valine 实现评论，官方网 https://leancloud.cn/\n进入控制台后点击左下角创建应用\n应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了\n开启评论功能 kaze/_config.yml\ncomment:\n  enable: true\n  type: valine # valine | gitalk | livere | disqus | we recommend valine\n  # gitalk config details can see in https:&#x2F;&#x2F;github.com&#x2F;gitalk&#x2F;gitalk&#x2F;blob&#x2F;master&#x2F;readme-cn.md\n  valine:\n    appId: 你的appId\n    appKey: 你的appKey\n1.4 部署gitee创建一个公开的仓库，仓库名称需要和个人空间地址相同\n个人空间地址查看方式：设置——&gt;基本设置——&gt;个人资料\n初始化\ngit init\ngit remote add origin git@gitee.com:个人空间地址&#x2F;仓库名称.git\ngit pull origin master\n提交项目\ngit add .\ngit commit -m &#39;我的第一个博客项目&#39;\ngit push origin master\n第一次提交时，确保仓库没有文件，因为如果仓库有文件，且文件名字正好和本地项目的某个文件名相同，会导致提交失败\n修改配置文件\ndeploy:\n  type: git\n  repo: git@gitee.com:个人空间地址&#x2F;仓库名称.git\n  branch: master\n部署到gitee\nnpm install --save hexo-deployer-git\nhexo clean\nhexo g\nhexo d\n选择强制使用https\n部署后会显示网站地址，直接访问即可。\n项目每一次更新提交到gitee之后，需要更新部署\n注意：\n如果更新部署后访问项目没有变化，可以尝试 CTRL+F5 强制刷新，或清除浏览器缓存。\n","categories":["Hexo环境搭建"],"tags":["Hexo"]},{"title":"Hello Hexo","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/02/20/hello-world/","content":"const smoothScrollToTop = () => &#123;\n  let yTopValve = (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop);\n  if (yTopValve > 1) &#123;\n    window.requestAnimationFrame(smoothScrollToTop);\n    scrollTo(0, Math.floor(yTopValve * 0.85));\n  &#125; else &#123;\n    scrollTo(0, 0);\n  &#125;\n&#125;;\n\nsetTimeout(() => &#123;\n  document.getElementById('scrollbutton').onclick = smoothScrollToTop;\n&#125;, 0);\n","categories":["Hexo文章测试"],"tags":["Hexo"]}]