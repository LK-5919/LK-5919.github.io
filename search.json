[{"title":"BOM-定时器-JSON","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/25/BOM-定时器-JSON/","content":"BOM(Browser Object Model)BOM -- 浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window；\nBOM由一些列相关的对象构成，并且每个对象都提供了很多方法与属性。\n\nDOM\n● 文档对象模型\n● DOM就是把【文档】当作一个【对象】来看待\n● DOM的顶级对象是document\n● DOM主要学习的是操作页面元素\n● DOM是W3C标准规范\nBOM\n● 浏览器对象模型\n● 把【浏览器】当做一个【对象】来看待\n● BOM的顶级对象是window\n● BOM学习的是浏览器窗口交互的一些对象\n● BOM是浏览器厂商在各自浏览器上定义的，兼容性交差\n\nBOM比DOM更大，它包含DOM；\nwindow对象是浏览器的顶级对象，它具有双重角色。\n1.它是JS访问浏览器窗口的一个接口。\n2.它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。\n在调用的时候可以省略alert()、prompt()等window对话框都属于window对象方法。\n注意：window下的特殊属性window.name，由此尽量不要使用var name=’’;\n\n\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"事件对象-鼠标事件","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/24/事件对象/","content":"事件对象事件对象 -- 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数（浏览器自动传入，我们可以使用参数接受）\n\t在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标  键盘哪个按键被按下  鼠标滚轮滚动的方向；\n    \n    兼容性问题：\n    \t在常见的Chrome浏览器，火狐浏览器等，事件的响应函数执行时，事件对象会被自动传入，但是在IE8及以下的浏览器中，事件的响应函数被执行是并不会传入事件对象，而是将当前的事件对象作为window的属性保存；\n        解决办法 ： event = event || window.event;  //在响应函数被执行的获取event，若此时获取不到event则说明此时的浏览器为IE8及以下，使用window.event 获取事件对象；\n\t\n\t\t/*\n\t\t * onmousemove\n\t\t * \t- 该事件将会在鼠标在元素中移动时被触发\n\t\t */\n\t\t\t/*\n\t\t\t * clientX可以获取鼠标指针的水平坐标\n\t\t\t * cilentY可以获取鼠标指针的垂直坐标\n\t\t\t \t这两个属性是事件对象上的属性\n\t\t\t */\nareaDiv.onmousemove = function(event)&#123;\n    event = event || window.event;\n    var x = event.clientX;\n    var y = event.clientY;\n&#125;\n\n//获取box元素\n    var box = document.getElementById(\"box\");\n\n    //给整个文档元素节点添加鼠标移入事件\n    document.onmousemove = function(event)&#123;\n        //处理兼容性问题\n        event = event || window.event;\n\n        //获取当前鼠标的位置\n        // var x = event.clientX;\n        // var y = event.clientY;\n\n        //改用pageX和pageY获取位置\n        // var x = event.pageX;\n        // var y = event.pageY;\n\n        //兼容的解决方法\n        var x = event.clientX + document.scrollingElement.scrollLeft;\n        var y = event.clientY + document.scrollingElement.scrollTop;\n\n        //修改box元素的位置\n        box.style.left = x + \"px\";\n        box.style.top = y + \"px\";\n\n        /*当页面出现滚动条的时候，去滑动滚动条，将会出现鼠标与box分离但是一起继续移动的现象；\n\n        //原因分析：enent.clientX/clientY 的位置永远都是根据网页中的左上角计算的，也就是显示器中的左上角，不\t\t\t会随着浏览器\n        //滚动条的滑动而改变，而box.style.left/top 此时是根据其父元素的body的文档流位置所计算的，相当于\t\t\tleft:0; top:0;\n        //所以当我们去滑动滚动条的时候，box距离定位原点的距离改变了，但是鼠标event的定位原点没有改变，\n        //实际效果是，本来在一个没有滚动条的网页中鼠标和元素的计算原点是一致的，但是滑动滚动条后，因为box的定\t\t\t位距离是要等于此时\n        的鼠标clientX/Y的，网页下移，鼠标不动--》clientX/Y不变，所以box的left和top也不变，所以此时box会出现\t\t在鼠标的上面，因为鼠标现在所在的位置\n        是大于box距离top:0 的位置的，所以其实是box上移了。而box和鼠标间的距离差就是滚动条滚动的距离；\n        */\n\n        //解决方法1：鼠标采用pageX和pageY获取位置，此时鼠标的计算原点将变为与box计算原点一致，即body所在文档\t\t流位置；\n\n        //pageX和pageY可以获取鼠标相对于当前页面的坐标\n\t\t//但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用\n        //解决方法2：获取此时document的scrollTop位置，将box与鼠标的距离差（scrollTop添加上）\n        //获取滚动条滚动的距离\n\t\t\t\t\t/*\n\t\t\t\t\t * chrome认为浏览器的滚动条是body的，可以通过body.scrollTop来获取\n\t\t\t\t\t * 火狐等浏览器认为浏览器的滚动条是html的，\n\t\t\t\t\t */\n\t\t\t\t\tvar st = document.body.scrollTop || document.documentElement.scrollTop;\n\t\t\t\t\tvar sl = document.body.scrollLeft || document.documentElement.scrollLeft;\n\n    &#125;\n事件冒泡/*\n * 事件的冒泡（Bubble）\n * \t- 所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也\t\t\t\t\t会被触发\n * \t- 在开发中大部分情况冒泡都是有用的,如果不希望发生事件冒泡可以通过事件对象来取消冒泡\n * \n */\n//取消冒泡\n\t//可以将事件对象的cancelBubble设置为true，即可取消冒泡\n\tevent.cancelBubble = true;\n事件委派\t\t\t\t/* 事件的委派\n\t\t\t\t * \t- 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖\t\t\t\t\t先元素，从而通过祖先元素的响应函数来处理事件。\n\t\t\t\t *  - 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能\n\t\t\t\t */\n\t\t\t\t\t/*\n\t\t\t\t\t * target\n\t\t\t\t\t * \t- event中的target表示的触发事件的对象\n\t\t\t\t\t */\nconsole.log(event.target.name);\n多重事件绑定\t\t\t\t/*\n\t\t\t\t * 使用 对象.事件 = 函数 的形式绑定响应函数，\n\t\t\t\t * \t它只能同时为一个元素的一个事件绑定一个响应函数，\n\t\t\t\t * \t不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * addEventListener()\n\t\t\t\t * \t- 通过这个方法也可以为元素绑定响应函数\n\t\t\t\t *  - 参数：\n\t\t\t\t * \t\t1.事件的字符串，不要on\n\t\t\t\t * \t\t2.回调函数，当事件触发时该函数会被调用\n\t\t\t\t * \t\t3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false\n\t\t\t\t * \n\t\t\t\t * 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，\n\t\t\t\t * \t这样当事件被触发时，响应函数将会按照函数的绑定顺序执行\n\t\t\t\t * addEventListener()中的this，是绑定事件的对象\n\t\t\t\t * \n\t\t\t\t * 这个方法不支持IE8及以下的浏览器\n\t\t\t\t */\nbtn01.addEventListener(\"click\",function()&#123;\n\t\t\t\t\talert(1);\n\t\t\t\t&#125;,false);\n\n\t\t\t\t/*\n\t\t\t\t * attachEvent()\n\t\t\t\t * \t- 在IE8中可以使用attachEvent()来绑定事件\n\t\t\t\t *  - 参数：\n\t\t\t\t * \t\t1.事件的字符串，要on\n\t\t\t\t * \t\t2.回调函数\n\t\t\t\t * \n\t\t\t\t *  - 这个方法也可以同时为一个事件绑定多个处理函数，\n\t\t\t\t * \t\t不同的是它是后绑定先执行，执行顺序和addEventListener()相反\n\t\t\t\t * attachEvent()中的this，是window\n\t\t\t\t */\nbtn01.attachEvent(\"onclick\",function()&#123;\n\t\t\t\t\talert(1);\n\t\t\t\t&#125;);\n\n\t//兼容性解决方法\n\t//定义一个函数，用来为指定元素绑定响应函数\n\t\t\t/*\n\t\t\t * addEventListener()中的this，是绑定事件的对象\n\t\t\t * attachEvent()中的this，是window\n\t\t\t *  需要统一两个方法this\n\t\t\t */\n\t\t\t/*\n\t\t\t * 参数：\n\t\t\t * \tobj 要绑定事件的对象\n\t\t\t * \teventStr 事件的字符串(不要on)\n\t\t\t *  callback 回调函数\n\t\t\t */\n\n\t//自定义一个可兼容的bind函数用于给事件绑定多重响应函数\n    //参数1：需要绑定的对象，\n    //参数2：固定参数，字符串 \"click\"\n    //参数3：事件响应函数的回调函数；\n    function bind(obj,enevtStr,callback)&#123;\n        //判断当前的浏览器是否兼容addEventListener()方法\n        if(odj.addEventListener)&#123;\n            //进入这里说明当前可使用addEventListener()\n            //addEventListener()方法中需要传入三个参数，\n            /*\n            参数1：事件的响应类型\n            参数2：事件响应的回调函数\n            参数3：是否开启事件的捕捉，默认不开启false\n            */\n            obj.addEventListener(eventStr,callback,false);\n        &#125;else&#123;\n            //进入这里说明当前浏览器不支持addEventListener()方法，\n            //应该使用attachEvent()方法 -- IE8及以下\n            /*\n            参数1：attachEvent的点击事件传入的事件名以on开头；\n            参数2：需要绑定事件的对象；\n            参数3：默认传入一个匿名函数，并在里面使用call调用当前的callback回调函数\n            */\n            obj.attachEvent(\"on\"+enevtStr,obj,function()&#123;\n                //在attachEvent方法中，传入的回调函数里的this是window而不是当前的attachEvent方法执行对象\n                //所以只能在参数中传入一个匿名函数，并在此使用call调用传入的callback；\n                callback.call(obj);\n            &#125;);\n        &#125;\n    &#125;\n事件的传播/*\n * 事件的传播\n * \t- 关于事件的传播网景公司和微软公司有不同的理解\n * \t- 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，\n * \t\t然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。\n *  - 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层\t\t\t\t\t的祖先元素的事件，\n * \t\t然后在向内传播给后代元素\n * \t- W3C综合了两个公司的方案，将事件传播分成了三个阶段\n * \t\t1.捕获阶段\n * \t\t\t- 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触\t\t\t\t\t发事件\n * \t\t2.目标阶段\n * \t\t\t- 事件捕获到目标元素，捕获结束开始在目标元素上触发事件\n * \t\t3.冒泡阶段\n * \t\t\t- 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件\n * \n * \t\t- 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true\n * \t\t\t一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false\n * \n * \t- IE8及以下的浏览器中没有捕获阶段\n */\n\n拖拽练习//获取box1元素节点\n    var box1 = document.getElementById(\"box1\");\n\n    //给box添加鼠标事件\n    box1.onmousedown = function(event)&#123;\n        //进入这里说明鼠标进入box1且进行了点击\n\n        event = event || window.event;\n\n        //获取当前box1的位置\n        var boxLeft = box1.offsetLeft;\n        var boxTop = box1.offsetTop;\n\n        //获取当前鼠标点击但还未移动时的位置\n        var mouseLeft = event.clientX;\n        var mouseHeight = event.clientY;\n\n        //获取当前box1与鼠标的距离差\n        var left = mouseLeft - boxLeft;\n        var top = mouseHeight - boxTop;\n\n        //在鼠标点击时间内定义document拖拽事件\n        document.onmousemove = function(event)&#123;\n\n            event = event || window.event;\n            \n            var x = event.clientX - left;\n            var y = event.clientY - top;\n\n            box1.style.left = x + \"px\";\n            box1.style.top = y + \"px\";\n\n            /* \n            此时出现了box1位置闪现的问题\n            原因分析：\n                在鼠标进入box1的内部点击时，触发box1的onmousedown事件，此时鼠标还没有移动时\n                没有异常现象出现，一旦鼠标开始移动，此时触发document的onmousemove响应函数，\n                此时将立即获取到鼠标的位置，并且将修改box1的位置\n                    box1的位置最后会变成鼠标当前所在文档流位置\n                因为box1的位置和此时鼠标所在位置不一定相同造成box1闪现问题\n\n            解决方法：\n                在鼠标在box1内部点击时还没开始出发移动的响应函数前，\n                先获取当前box1的文档流位置和此时鼠标的位置\n                通过event.clientX - box1.offsetLeft 获取当前box1与鼠标的距离差\n                之后在鼠标开始移动的时候，将box1要闪现的距离差添加上以此弥补，从而解决闪现问题\n            */\n        &#125;\n\n    &#125;\n\n    box1.onmouseup = function()&#123;\n        document.onmousemove = null;\n    &#125;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * setCapture()\n\t\t\t\t\t * \t- 只有IE支持，但是在火狐中调用时不会报错，\n\t\t\t\t\t * \t\t而如果使用chrome调用，会报错\n\t\t\t\t\t */\n//当调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上\n\t\t\t\tbtn01.setCapture();\n滚轮事件\t\t\t\t/*\n\t\t\t\t * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，\n\t\t\t\t * \t但是火狐不支持该属性\n\t\t\t\t event.wheelDelta 可以获取鼠标滚轮滚动的方向\n\t\t\t\t wheelDelta这个值我们不看大小，只看正负\n\t\t\t\t 向上滚 -- 值大于0 ；  向下滚 -- 值小于0；\n\t\t\t\t * \n\t\t\t\t * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件\n\t\t\t\t * \t注意该事件需要通过addEventListener()函数来绑定\n\t\t\t\t wheelDelta属性在火狐浏览器中也不支持，需要使用event.detail来获取滚动的方向\n\t\t\t\t 向上滚 -- 值小于0； 向下滚 -- 值大于0；\n\t\t\t\t */\nbox1.onmousewheel = function(event)&#123;\n    //event兼容\n    event = event || window.event;\n    \n    //判断此时滚轮方向\n    if(event.wheelDetal > 0 || event.detail &lt; 0)&#123;\n        //进入这里说明此时滚轮向上滚\n        //clientHeight为当前盒子的内容区+内边距区大小\n        box1.style.height = box1.clientHeight - 10 + \"px\"; \n    &#125;else&#123;\n        box1.style.height = box1.clientHeight  + 10 + \"px\";\n    &#125;\n    \t\t\t\t/*\n\t\t\t\t\t * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false\n\t\t\t\t\t * 需要使用event来取消默认行为event.preventDefault();\n\t\t\t\t\t * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错\n\t\t\t\t\t */\n\t\t\t\t\tevent.preventDefault &amp;&amp; event.preventDefault();\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，\n\t\t\t\t\t * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n&#125;\n\t\t\t\t//为火狐绑定滚轮事件\n\tbind(box1,\"DOMMouseScroll\",box1.onmousewheel);\n\n\tfunction bind(obj , eventStr , callback)&#123;\n\t\tif(obj.addEventListener)&#123;\n\t\t\t//大部分浏览器兼容的方式\n\t\t\tobj.addEventListener(eventStr , callback , false);\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\t/*\n\t\t\t\t\t * this是谁由调用方式决定\n\t\t\t\t\t * callback.call(obj)\n\t\t\t\t\t */\n\t\t\t\t\t//IE8及以下\n\t\t\t\t\tobj.attachEvent(\"on\"+eventStr , function()&#123;\n\t\t\t\t\t\t//在匿名函数中调用回调函数\n\t\t\t\t\t\tcallback.call(obj);\n\t\t\t\t\t&#125;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n //给按钮绑定点击响应事件1 -- 点击打印box1的大小\n    bind(btn,\"click\",function()&#123;\n        console.log(\"box1的clientX：\",box1.clientWidth);\n    &#125;);\n\n    //给按钮绑定点击响应事件2 -- 点击打印box1的背景颜色\n    bind(btn,\"click\",function()&#123;\n        console.log(\"box1的背景颜色：\",getComputedStyle(box1,null).backgroundColor);\n    &#125;);\n键盘事件\t\t\t\t/*\n\t\t\t\t * 键盘事件：\n\t\t\t\t * \tonkeydown\n\t\t\t\t * \t\t- 按键被按下\n\t\t\t\t * \t\t- 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发\n\t\t\t\t * \t\t- 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快\n\t\t\t\t * \t\t\t这种设计是为了防止误操作的发生。\n\t\t\t\t * \tonkeyup\n\t\t\t\t * \t\t- 按键被松开\n\t\t\t\t * \n\t\t\t\t *  键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document\n\t\t\t\t */\n\t\t\t\t\t/*\n\t\t\t\t\t * 可以通过keyCode来获取按键的编码\n\t\t\t\t\t * \t通过它可以判断哪个按键被按下\n\t\t\t\t\t * 除了keyCode，事件对象中还提供了几个属性\n\t\t\t\t\t * \taltKey\n\t\t\t\t\t * \tctrlKey\n\t\t\t\t\t * \tshiftKey\n\t\t\t\t\t * \t\t- 这个三个用来判断alt ctrl 和 shift是否被按下\n\t\t\t\t\t * \t\t\t如果按下则返回true，否则返回false\n\t\t\t\t\t */\n\n//获取box对象\n    var box = document.getElementById(\"box\");\n\n    //定义一个box每次唯一的距离\n    var distant = 10;\n\n    //给document添加键盘监听事件\n    document.onkeydown = function(event)&#123;\n        //解决event兼容\n        event = event || window.event;\n\n        // console.log(\"当前输入的键盘编码:\",event.keyCode);\n        /*\n        获取到上方向键编码：38\n        向下方向键编码：40\n        向左方向键编码：37\n        向右方向键编码：39\n        */\n\n       //判断此时clrt键是否被按下\n       if(event.ctrlKey)&#123;\n        distant = 20;\n        console.log(\"crlt键被按下，移动加速\");\n       &#125;\n\n        switch(event.keyCode)&#123;\n            case 38:\n                box.style.top = box.offsetTop - distant + \"px\";\n                console.log(\"向上移动\"+distant+\"px\");\n                break;\n            case 40:\n                box.style.top = box.offsetTop + distant + \"px\";\n                console.log(\"向下移动\"+distant+\"px\");\n                break;\n            case 37:\n                box.style.left = box.offsetLeft - distant + \"px\";\n                console.log(\"向左移动\"+distant+\"px\");\n                break;\n            case 39:\n                box.style.left = box.offsetLeft + distant + \"px\";\n                console.log(\"向右移动\"+distant+\"px\");\n                break;\n        &#125;\n\n    &#125;","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"DOM-查询与修改","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/23/DOM-查询与修改/","content":"HTML DOM（文档对象模型）当网页解析加载时，浏览器会创建当前页面的文档对象模型DOM（Document Object Model）；\n​    文档 – 表示的就是整个HTML网页文档；\n​    对象 – 表示将网页中的每一个部分都转换成一个对象；\n​    模型 – 使用模型来表示对象之间的关系，方便获取对象；\n所以DOM可以可以看成是一个网页模型，通常将其结构化表示为一个对象树（浏览器首先将收到的html代码，通过html解析器解析构建为一颗DOM树。）：\n\n节点类型（Node）节点 – 是构成网页最基本的组成部分，网页中的每一个部分都可以称为是一个节点，文档是由节点构成的集合；\n​    常用节点分为四类：\n​        文档节点 – 整个HTML文档；网页中的所有节点都是它的子节点；document对象是window身上的属性，可以直接使用；\n​        元素节点 – HTML文档中的HTML标签；\n​        属性节点 – 元素的属性；属性节点并非是元素节点的子节点，而是元素节点的一部分；\n​        文本节点 – HTML标签以外的文本内容；（标签元素之间的空白也会被解析成文本节点）；任意非HTML的文本都是文本节点；\n\n节点的属性\n\n\n\n\nnodeName\nnodeType\nnodeValue\n\n\n\n文档节点\n#document\n9\nnull\n\n\n元素节点\n标签名\n1\nnull\n\n\n属性节点\n属性名\n2\n属性值\n\n\n文本节点\n#text\n3\n文本内容\n\n\n事件文档或浏览器窗口发生的一些特定交互瞬间；例如点击元素，鼠标移入等；\n文档的加载浏览器在解析网页时，按照从上到下的顺序解析代码，如果将script代码写在页面代码之前，会导致在页面还没加载DOM对象执行JS代码，此时将无法获取DOM对象；\nonload()事件会在整个页面加载完成后才执行，为window绑定一个onload事件，以确保在页面记载完成后才开始执行js代码，开始获取DOM对象；\n\n\twindow.onload()&#123;\n        &#x2F;&#x2F;这里书写js代码，这样即使js代码写在网页结构之前也可以正常获取dom对象；\n    &#125;\ndom查询//定义按钮单击事件绑定函数\n\t\t\tfunction btnClick(btnName,fun)&#123;\n\t\t\t\t//获取按钮对象\n\t\t\t\tvar btn = document.getElementById(btnName);\n\t\t\t\t//给按钮绑定单击事件\n\t\t\t\tbtn.onclick = fun;\n\t\t\t&#125;\n\t\t\t\n\t\t\t//在网页结构加载完成以后再开始执行获取dom对象\n\t\t\twindow.onload = function()&#123;\n\n\t\t\t\t//查找#bj节点\n\t\t\t\tbtnClick(\"btn01\",function()&#123;\n\t\t\t\t\t//使用document.getElementById()获取文档的元素节点。需要以字符串形式传入元素节点的id名称\n\t\t\t\t\tvar bj = document.getElementById(\"bj\");\n\t\t\t\t\tconsole.log(bj);\n\t\t\t\t&#125;);\n\n\t\t\t\t//查找所有li节点\n\t\t\t\tbtnClick(\"btn02\",function()&#123;\n\t\t\t\t\t//document.getElementsByTagName根据元素节点的标签名获取文档的中所有符合的节点对象，\n\t\t\t\t\t//返回的是数组，即使返回结果只有一个节点\n\t\t\t\t\tvar list = document.getElementsByTagName(\"li\");\n\t\t\t\t\tfor(var i = 0; i &lt; list.length; i++)&#123;\n\t\t\t\t\t\tconsole.log(list[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;);\n\n\t\t\t\t//查找name=gender的所有节点\n\t\t\t\tbtnClick(\"btn03\",function()&#123;\n\t\t\t\t\t//document.getElementsByName根据元素的name属性节点获取对象，返回的是数组\n\t\t\t\t\tvar list = document.getElementsByName(\"gender\");\n\t\t\t\t\tfor(var i = 0; i &lt; list.length; i++)&#123;\n\t\t\t\t\t\tconsole.log(list[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;);\n\n\t\t\t\t//查找#city下所有li子节点\n\t\t\t\tbtnClick(\"btn04\",function()&#123;\n\t\t\t\t\tvar city = document.getElementById(\"city\");\n\t\t\t\t\t//元素节点也可以使用getElementsByTagName,getElementById之类同document对象的函数，将会在当前节点的子节点查找\n\t\t\t\t\tvar list = city.getElementsByTagName(\"li\");\n\t\t\t\t\tfor(var i = 0; i &lt; list.length; i++)&#123;\n\t\t\t\t\t\tconsole.log(list[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#city下的所有子节点\n\t\t\t\tbtnClick(\"btn05\",function()&#123;\n\t\t\t\t\tvar city = document.getElementById(\"city\");\n\t\t\t\t\t// 使用childNode属性获取元素的所有元素节点和文本子节点\n\t\t\t\t\t// var list = city.childNodes;\n\t\t\t\t\t//使用children属性就只会获取到元素内的所有子元素节点，不包括文本节点，但是该属性不是所有浏览器都兼容\n\t\t\t\t\tvar list = city.children;\n\t\t\t\t\tfor(var i = 0; i &lt; list.length; i++)&#123;\n\t\t\t\t\t\tconsole.log(list[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#phone的第一个子节点\n\t\t\t\tbtnClick(\"btn06\",function()&#123;\n\t\t\t\t\tvar phone = document.getElementById(\"phone\");\n\t\t\t\t\t// 使用firstChild属性或者元素下的第一个子节点（包括文本节点）\n\t\t\t\t\t// var child = phone.firstChild;\n\t\t\t\t\t//使用firstElementChild属性获取元素下的第一个元素节点\n\t\t\t\t\tvar child = phone.firstElementChild;\n\t\t\t\t\tconsole.log(child);\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#bj的父节点\n\t\t\t\tbtnClick(\"btn07\",function()&#123;\n\t\t\t\t\tvar bj = document.getElementById(\"bj\");\n\t\t\t\t\tvar parent = bj.parentNode;\n\t\t\t\t\t// var parent = bj.parentElement;\n\t\t\t\t\t//parentNode和parentElement都可以获取父节点的所有节点属性\n\t\t\t\t\t//区别在于：在获取根部document节点时，parentElement找的是元素，因此报错null,\n\t\t\t\t\t//而parentNode获取的是节点，返回的是#document\n\t\t\t\t\tconsole.log(parent);\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#android的前一个兄弟节点\n\t\t\t\tbtnClick(\"btn08\",function()&#123;\n\t\t\t\t\tvar android = document.getElementById(\"android\");\n\t\t\t\t\t//使用previousSibling属性或获取当前元素的前一个节点（文本节点和元素节点）\n\t\t\t\t\t// var pre = android.previousSibling;\n\t\t\t\t\t//previousElementSibling属性获取当前元素的前一个元素节点\n\t\t\t\t\tvar pre = android.previousElementSibling;\n\t\t\t\t\t//使用nextSibling属性或获取当前元素的下一个节点（文本节点和元素节点）\n\t\t\t\t\t// var next = android.nextSibling;\n\t\t\t\t\t//nextElementSibling属性获取当前元素的下一个元素节点\n\t\t\t\t\tvar next = android.nextElementSibling;\n\t\t\t\t\tconsole.log(pre);\n\t\t\t\t\tconsole.log(next);\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#username的value属性值\n\t\t\t\tbtnClick(\"btn09\",function()&#123;\n\t\t\t\t\tvar username = document.getElementById(\"username\");\n\t\t\t\t\t//使用 元素.属性名 获取元素节点的属性值\n\t\t\t\t\tconsole.log(username.value);\n\t\t\t\t&#125;);\n\n\t\t\t\t//设置#username的value属性值\n\t\t\t\tbtnClick(\"btn10\",function()&#123;\n\t\t\t\t\tvar username = document.getElementById(\"username\");\n\t\t\t\t\t//使用 元素.属性名 = 属性值  修改元素节点的属性值\n\t\t\t\t\tusername.value = \"HelloWorld\";\n\t\t\t\t&#125;);\n\n\t\t\t\t//返回#bj的文本值\n\t\t\t\tbtnClick(\"btn11\",function()&#123;\n\t\t\t\t\tvar bj = document.getElementById(\"bj\");\n\t\t\t\t\t//innerText属性会获取当前节点的内部所有文本内容，不包括html标签\n\t\t\t\t\t//innerHTML属性会回去当前节点的内部所有html代码，包括空格换行\n\t\t\t\t\tconsole.log(bj.innerText);\n\t\t\t\t&#125;);\n\t\t\t&#125;\n\n\t\t\t\t/*\n\t\t\t\t * document.querySelector()\n\t\t\t\t * \t- 需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象\n\t\t\t\t * \t- 虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替\n\t\t\t\t * \t- 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个\n\t\t\t\t */\n\t\t\t\tvar div = document.querySelector(\".box1 div\");\n\t\t\t\t\n\t\t\t\tvar box1 = document.querySelector(\".box1\")\n\t\t\t\t\n                /*\n\t\t\t\t * document.querySelectorAll()\n\t\t\t\t * \t- 该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回\n\t\t\t\t * \t- 即使符合条件的元素只有一个，它也会返回数组\n\t\t\t\t */\n\t\t\t\tbox1 = document.querySelectorAll(\".box1\");\n\t\t\t\tbox1 = document.querySelectorAll(\"#box2\");\ndom节点操作/*\n\t\t\t\t\t * document.createElement()\n\t\t\t\t\t * \t可以用于创建一个元素节点对象，\n\t\t\t\t\t * \t它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，\n\t\t\t\t\t * \t并将创建好的对象作为返回值返回\n\t\t\t\t\t */\n\t\t\t\t\tvar li = document.createElement(\"li\");\n\n/*\n\t\t\t\t\t * document.createTextNode()\n\t\t\t\t\t * \t可以用来创建一个文本节点对象\n\t\t\t\t\t *  需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回\n\t\t\t\t\t */\n\t\t\t\t\tvar gzText = document.createTextNode(\"广州\");\n\n/*\n\t\t\t\t\t * appendChild()\n\t\t\t\t\t * \t - 向一个父节点中添加一个新的子节点\n\t\t\t\t\t * \t - 用法：父节点.appendChild(子节点);\n\t\t\t\t\t */\n\t\t\t\t\tli.appendChild(gzText);\n\n\n/*\n\t\t\t\t\t * insertBefore()\n\t\t\t\t\t * \t- 可以在指定的子节点前插入新的子节点\n\t\t\t\t\t *  - 语法：\n\t\t\t\t\t * \t\t父节点.insertBefore(新节点,旧节点);\n\t\t\t\t\t */\n\t\t\t\t\tcity.insertBefore(li , bj);\n\n\n/*\n\t\t\t\t\t * replaceChild()\n\t\t\t\t\t * \t- 可以使用指定的子节点替换已有的子节点\n\t\t\t\t\t * \t- 语法：父节点.replaceChild(新节点,旧节点);\n\t\t\t\t\t */\n\t\t\t\t\tcity.replaceChild(li , bj);\n\n/*\n\t\t\t\t\t * removeChild()\n\t\t\t\t\t * \t- 可以删除一个子节点\n\t\t\t\t\t * \t- 语法：父节点.removeChild(子节点);\n\t\t\t\t\t * \t\t\n\t\t\t\t\t * \t\t子节点.parentNode.removeChild(子节点);\n\t\t\t\t\t */\n\t\t\t\t\t//city.removeChild(bj);\n\t\t\t\t\t\n\t\t\t\t\tbj.parentNode.removeChild(bj);\n\n/*\n\t\t\t\t\t * 使用innerHTML也可以完成DOM的增删改的相关操作\n\t\t\t\t\t * 一般我们会两种方式结合使用\n\t\t\t\t\t */\n\t\t\t\t\t//city.innerHTML += \"&lt;li>广州&lt;/li>\";\n使用DOM操作CSS\t\t\t\t\t&#x2F;*\n\t\t\t\t\t * 通过JS修改元素的样式：\n\t\t\t\t\t * \t语法：元素.style.样式名 &#x3D; 样式值\n\t\t\t\t\t * \n\t\t\t\t\t * 注意：如果CSS的样式名中含有-，\n\t\t\t\t\t * \t\t这种名称在JS中是不合法的比如background-color\n\t\t\t\t\t * \t\t需要将这种样式名修改为驼峰命名法，\n\t\t\t\t\t * \t\t去掉-，然后将-后的字母大写\n\t\t\t\t\t * \n\t\t\t\t\t * 我们通过style属性设置的样式都是内联样式，\n\t\t\t\t\t * \t而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示\n\t\t\t\t\t * \n\t\t\t\t\t * 但是如果在样式中写了!important，则此时样式会有最高的优先级，\n\t\t\t\t\t * \t即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效\n\t\t\t\t\t * \t所以尽量不要为样式添加!important \n\t\t\t\t\t *&#x2F;\n\n&#x2F;&#x2F;给按钮btn1绑定单击事件\n\t\t\t\tbtn1.onclick &#x3D; function()&#123;\n\t\t\t\t\tvar width &#x3D; Math.round(Math.random()*200+100);\n\t\t\t\t\tvar height &#x3D; width;\n\t\t\t\t\t&#x2F;&#x2F;通过js控制的元素样式都是添加到元素的内联样式\n\t\t\t\t\tdemo.style.width &#x3D; width + &quot;px&quot;;\n\t\t\t\t\tdemo.style.height &#x3D; height + &quot;px&quot;;\n\t\t\t\t\tconsole.log(width);\n\t\t\t\t&#125;\n\n\t\t\t\t\t&#x2F;*\n\t\t\t\t\t * 获取元素的当前显示的样式\n\t\t\t\t\t * \t语法：元素.currentStyle.样式名\n\t\t\t\t\t * 它可以用来读取当前元素正在显示的样式\n\t\t\t\t\t * \t如果当前元素没有设置该样式，则获取它的默认值\n\t\t\t\t\t * \n\t\t\t\t\t * currentStyle只有IE浏览器支持，其他的浏览器都不支持\n\t\t\t\t\t *&#x2F;\nconsole.log(box01.currentStyle);\n\n\t\t\t\t\t&#x2F;*\n\t\t\t\t\t * 在其他浏览器中可以使用\n\t\t\t\t\t * \t\tgetComputedStyle()这个方法来获取元素当前的样式\n\t\t\t\t\t * \t\t这个方法是window的方法，可以直接使用\n\t\t\t\t\t * 需要两个参数\n\t\t\t\t\t * \t\t第一个：要获取样式的元素\n\t\t\t\t\t * \t\t第二个：可以传递一个伪元素，一般都传null\n\t\t\t\t\t * \n\t\t\t\t\t * 该方法会返回一个对象，对象中封装了当前元素对应的样式（整个样式的计算属性）\n\t\t\t\t\t * \t可以通过对象.样式名来读取样式\n\t\t\t\t\t * \t如果获取的样式没有设置，则会获取到真实的值，而不是默认值\n\t\t\t\t\t * \t比如：没有设置width，它不会获取到auto，而是一个长度\n\t\t\t\t\t * \n\t\t\t\t\t * 但是该方法不支持IE8及以下的浏览器\n\t\t\t\t\t * \n\t\t\t\t\t * 通过currentStyle和getComputedStyle()读取到的样式都是只读的，\n\t\t\t\t\t * \t不能修改，如果要修改必须通过style属性\n\t\t\t\t\t *&#x2F;\nconsole.log(getComputedStyle(box1,null).width);\n其他样式操作的属性\t\t\t\t\t/*\n\t\t\t\t\t * clientWidth\n\t\t\t\t\t * clientHeight\n\t\t\t\t\t * \t- 这两个属性可以获取元素的可见宽度和高度\n\t\t\t\t\t * \t- 这些属性都是不带px的，返回都是一个数字，可以直接进行计算\n\t\t\t\t\t * \t- 会获取元素宽度和高度，包括内容区和内边距\n\t\t\t\t\t *  - 这些属性都是只读的，不能修改\n\t\t\t\t\t */\nconsole.log(\"demo的宽度\",demo.clientWidth);  //输出具体的数值，不携带单位，返回内边距区和内容区的大小之和；\n\n\t\t\t\t\t/*\n\t\t\t\t\t * offsetWidth\n\t\t\t\t\t * offsetHeight\n\t\t\t\t\t * \t- 获取元素的整个的宽度和高度，包括内容区、内边距和边框\n\t\t\t\t\t */\nconsole.log(\"demo的宽度\",demo.offsetWidth);  //返回元素的可见框大小（边框+内边距+内容区）；\n\n\t\t\t\t\t/*\n\t\t\t\t\t * offsetParent\n\t\t\t\t\t * \t- 可以用来获取当前元素的定位父元素\n\t\t\t\t\t *  - 会获取到离当前元素最近的开启了定位的祖先元素\n\t\t\t\t\t * \t\t如果所有的祖先元素都没有开启定位，则返回body\n\t\t\t\t\t */\nconsole.log(\"demo最近的开启了定位的祖先元素\",demo.offsetParent);  \n\n\t\t\t\t\t/*\n\t\t\t\t\t * offsetLeft\n\t\t\t\t\t * \t- 当前元素相对于其定位父元素的水平偏移量\n\t\t\t\t\t * offsetTop\n\t\t\t\t\t * \t- 当前元素相对于其定位父元素的垂直偏移量\n\t\t\t\t\t \t返回的是当前元素相对于开启了定位的祖先元素的 margin-left/top + left 或 top 之和\n\t\t\t\t\t */\nconsole.log(\"demo相对于开启了定位的祖先元素的水平偏移量\",demo.offsetLeft); \n\n\t\t\t\t\t/*\n\t\t\t\t\t * scrollWidth\n\t\t\t\t\t * scrollHeight\n\t\t\t\t\t * \t- 可以获取元素整个滚动区域的宽度和高度\n\t\t\t\t\t \n\t\t\t\t\t \t出现滚动框一般都是子元素的宽度或高度超出父元素的大小，且此时父元素开启了overflow:auto; 属性，此时使用 父元素.scrollHeight 获取的是里面子元素的高度；\n\t\t\t\t\t */\nconsole.log(demo1.scrollHeight);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * scrollLeft\n\t\t\t\t\t * \t- 可以获取水平滚动条滚动的距离\n\t\t\t\t\t * scrollTop\n\t\t\t\t\t * \t- 可以获取垂直滚动条滚动的距离\n\t\t\t\t\t 获取的是滚动条滚动的距离\n\t\t\t\t\t */\n\n\t\t\t\t\t//当满足scrollHeight - scrollTop == clientHeight\n\t\t\t\t\t//scrollHeight相当于父元素内部的溢出的子元素高度，scrollTop等于当前垂直滚动条滚动的距离，clientHeight等于此时父元素的高度，scrollTop的距离是一直在改变的，当scrollTop滑到顶部也就是最大值时，子元素在父元素的中显示的内容高度恰好等于父元素的clientHeight；\n\t\t\t\t\t//说明垂直滚动条滚动到底了\n\t\t\t\t\t\n\t\t\t\t\t//当满足scrollWidth - scrollLeft == clientWidth\n\t\t\t\t\t//说明水平滚动条滚动到底\n\t\t\t\t\t//alert(box4.scrollHeight - box4.scrollTop); // 600\nconsole.log(demo1.scrollTop);","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"String-正则表达式","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/22/String-正则表达式/","content":"String相关方法字符串在底层中其实是以字符数组的形式保存的；\nvar str = \"hello\";\nconsole.log(str.length);  //输出 5\nconsole.log(str[1]);  //输出 e\n\n\t\t\t/*\n\t\t\t * charAt()\n\t\t\t * \t- 可以返回字符串中指定位置的字符\n\t\t\t * \t- 根据索引获取指定的字符\n             \t\t该方法不太常用，需要使用索引获取单个字符的话，直接使用str[index]更加便捷；\n\t\t\t */\nvar str = \"helloworld\";\nconsole.log(str.charAt('3'));  //输出 l\n\n\t\t\t/*\n\t\t\t * charCodeAt()\n\t\t\t * \t- 获取指定位置字符的字符编码（Unicode编码）\n\t\t\t */\nvar str = \"helloLK\"; \nconsole.log(str.charCodeAt(2));  //输出 108 即字符l的Unicode编码是108；\n\n\t\t\t/*\n\t\t\t * String.formCharCode()\n\t\t\t * \t- 可以根据字符编码去获取字符\n\t\t\t */\nconsole.log(String.fromCharCode(108));  //输出 字符 l；\n\n\t\t\t/*\n\t\t\t * concat()\n\t\t\t * \t- 可以用来连接两个或多个字符串\n\t\t\t * \t- 作用和+一样\n\t\t\t */\nvar str = \"hello\";\nconsole.log(str.concat(\"world\")); //输出 helloworld\n\n\t\t\t/*\n\t\t\t * indexof()\n\t\t\t * \t- 该方法可以检索一个字符串中是否含有指定内容\n\t\t\t * \t- 如果字符串中含有该内容，则会返回其第一次出现的索引\n\t\t\t * \t\t如果没有找到指定的内容，则返回-1\n\t\t\t * \t- 可以指定一个第二个参数，指定开始查找的位置\n\t\t\t * \n\t\t\t * lastIndexOf();\n\t\t\t * \t- 该方法的用法和indexOf()一样，\n\t\t\t * \t\t不同的是indexOf是从前往后找，\n\t\t\t * \t\t而lastIndexOf是从后往前找  -- 返回的索引是从从左往右开始的\n\t\t\t * \t- 也可以指定开始查找的位置\n\t\t\t */\nvar str = \"hello\";\nconsole.log(str.indexOf(\"a\"));  //返回 -1 说明查找失败\nconsole.log(str.indexOf(\"l\"));  //返回 2 说明字符 l 在第三个字符\nconsole.log(str.indexOf(\"l\",3)); //返回3 说明从索引为3开始查找字符 l \nconsole.log(str.lastIndexOf(\"l\"));  //返回 3 说明从后往前找 ，首次出现字符 l 在第4个字符\n\n\t\t\t/*\n\t\t\t * slice()\n\t\t\t * \t- 可以从字符串中截取指定的内容\n\t\t\t * \t- 不会影响原字符串，而是将截取到内容返回\n\t\t\t * \t- 参数：\n\t\t\t * \t\t第一个，开始位置的索引（包括开始位置）\n\t\t\t * \t\t第二个，结束位置的索引（不包括结束位置）\n\t\t\t * \t\t\t- 如果省略第二个参数，则会截取到后边所有的\n\t\t\t * \t\t- 也可以传递一个负数作为参数，负数的话将会从后边计算\n\t\t\t */\nvar str = \"helloworld\";\nvar result = str.slice(1,2);\nconsole.log(str);  //输出 helloworld\nconsole.log(result);  // 输出 e\nresult = str.slice(2);\nconsole.log(result); // 输出 lloworld\nconsole.log(str.slice(2,-1)); //输出 lloworl  参数-1表示在倒数第一个位置停止截取\n\n\t\t\t/*\n\t\t\t * substring()\n\t\t\t * \t- 可以用来截取一个字符串，可以slice()类似\n\t\t\t * \t- 参数：\n\t\t\t * \t\t- 第一个：开始截取位置的索引（包括开始位置）\n\t\t\t * \t\t- 第二个：结束位置的索引（不包括结束位置）\n\t\t\t * \t\t- 不同的是这个方法不能接受负值作为参数，\n\t\t\t * \t\t\t如果传递了一个负值，则默认使用0\n\t\t\t * \t\t- 而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换\n\t\t\t */\nvar str = \"helloworld\";\nconsole.log(str.substring(1,3)); //输出 el\nconsole.log(str.substring(1,0)); // 输出 h 第二个参数小于第一个参数，自动调整为（0,1）\n\n\t\t\t/*\n\t\t\t * substr()\n\t\t\t * \t- 用来截取字符串\n\t\t\t * \t- 参数：\n\t\t\t * \t\t1.截取开始位置的索引\n\t\t\t * \t\t2.截取的长度\n\t\t\t */\nvar str = 'helloworld';\nconsole.log(str.substr(1,3));  //输出 ell 表示从第二个字符开始截取是三个字符\n\n\t\t\t/*\n\t\t\t * split()\n\t\t\t * \t- 可以将一个字符串拆分为一个数组\n\t\t\t * \t- 参数：\n\t\t\t * \t\t-需要一个字符串作为参数，将会根据该字符串去拆分数组\n\t\t\t */\nvar str = \"helloworld\";\nvar arr = str.split(\"w\");\nconsole.log(str); //输出 helloworld\nconsole.log(Array.isArray(arr)); //输出 true\nconsole.log(arr); // 输出 ['hello', 'orld']  从字符 w 处分开，且不包含字符 w \nconsole.log(str.split(\"\"));  //输出  ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']\n\n\t\t\t/*\n\t\t\t * toUpperCase()\n\t\t\t * \t- 将一个字符串转换为大写并返回\n\t\t\t */\nvar str = \"hedenLsdHGH\";\nconsole.log(str.toUpperCase());  //输出 HEDENLSDHGH\n\n\t\t\t/*\n\t\t\t * toLowerCase()\n\t\t\t * \t-将一个字符串转换为小写并返回\n\t\t\t */\nvar str = \"hedenLsdHGH\";\nconsole.log(str.toLowerCase());  //输出 hedenlsdhgh\n正则表达式//创建正则表达式对象 -- 使用构造函数创造\n\t\t\t/*\n\t\t\t * 语法：\n\t\t\t * \tvar 变量 = new RegExp(\"正则表达式\",\"匹配模式\");\n\t\t\t *  使用typeof检查正则对象，会返回object\n\t\t\t * \tvar reg = new RegExp(\"a\"); 这个正则表达式可以来检查一个字符串中是否含有a\n\t\t\t * 在构造函数中可以传递一个匹配模式作为第二个参数，\n\t\t\t * \t\t可以是 \n\t\t\t * \t\t\ti 忽略大小写 \n\t\t\t * \t\t\tg 全局匹配模式\n\t\t\t */\n\t\t\t/*\n\t\t\t * 正则表达式的方法：\n\t\t\t * \ttest()\n\t\t\t * \t - 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，\n\t\t\t * \t\t如果符合则返回true，否则返回false\n\t\t\t */\nvar reg = new RegExp(\"ab\",\"i\");  //创建正则表达式规则 要求字符串中要包含有 \"ab\"，且不区分大小写\nconsole.log(reg.test(\"sdxardbasds\"));  //输出 false\nconsole.log(reg.test(\"hsujabiijio\"));  // 输出 true\nconsole.log(reg.test(\"Absdjs\"));  //输出 true\n\n方括号\n//使用字面量创建正则表达式\nvar reg = /ab/i;   //等同于new RegExp(\"ab\",\"i\");\nconsole.log(reg.test(\"abhdjshuh\")); //输出 true\n\n\t\t\t/*\n\t\t\t\t方括号\n\t\t\t * 使用 | 表示或者的意思\n\t\t\t * []里的内容也是或的关系\n\t\t\t * [ab] == a|b\n\t\t\t * [a-z] 任意小写字母\n\t\t\t * [A-Z] 任意大写字母\n\t\t\t * [A-z] 任意字母\n\t\t\t * [0-9] 任意数字\n\t\t\t  * [^ ] 除了\n\t\t\t */\nreg = /a|b|c/;  //创建一个规则为包含字符 a 或 b 或 c 的正则对象\nconsole.log(reg.test(\"asddefe\"));  //输出 true \n\nreg = /[A-Z]/;  //创建一个规则为包含字符 A 到 Z 的正则对象\nconsole.log(reg.test(\"asjjHsBd\"));  //返回 true\n\nreg = /[^BS]/;  //创建一个规则为除了字符BS以外的正则对象\nconsole.log(reg.test(\"Bdfgs\"));  //输出 true 因为该字符串中BS外还有其他字符\nconsole.log(reg.test(\"AHYGdfsb\")); //输出 true\nconsole.log(reg.test(\"B\"));  // 输出false\n元字符\n\t\t\t/*\n\t\t\t * \\w\n\t\t\t * \t- 任意字母、数字、_  [A-z0-9_]\n\t\t\t * \\W\n\t\t\t * \t- 除了字母、数字、_  [^A-z0-9_]\n\t\t\t * \\d\n\t\t\t * \t- 任意的数字 [0-9]\n\t\t\t * \\D\n\t\t\t * \t- 除了数字 [^0-9]\n\t\t\t * \\s\n\t\t\t * \t- 空格\n\t\t\t * \\S\n\t\t\t * \t- 除了空格\n\t\t\t * \\b\n\t\t\t * \t- 单词边界\n\t\t\t * \\B\n\t\t\t * \t- 除了单词边界\n\t\t\t */\nvar reg = /\\w/;  //创建一个规则为包含任意字母，数字，_的正则对象；\nconsole.log(reg.test(\"!###@\"));  //输出 false\nconsole.log(reg.test(\"#$$%asdf432\"));  //输出 true\n\nvar reg = /\\s/; //创建一个规则为包含空格的正则对象；\nconsole.log(reg.test(\"hsdjhsch\"));   //输出 false\nconsole.log(reg.test(\"fgdsjk jkjlko\"));  //输出 true\n\nvar reg = /\\b\\w&#123;3&#125;\\b/;  //创建一个包含单词边界的正则对象；\nconsole.log(reg.test(\"sdfdsf\")); //输出 false\nconsole.log(reg.test(\" jhf jsd h fkgjksfdjfio\"));  //输出 true\n量词\n/*\n\t\t\t * 量词\n\t\t\t * \t- 通过量词可以设置一个内容出现的次数\n\t\t\t * \t- 量词只对它前边的一个内容起作用\n\t\t\t * \t- &#123;n&#125; 正好出现n次\n\t\t\t * \t- &#123;m,n&#125; 出现m-n次\n\t\t\t * \t- &#123;m,&#125; m次以上\n\t\t\t * \t- + 至少一个，相当于&#123;1,&#125;\n\t\t\t * \t- * 0个或多个，相当于&#123;0,&#125;\n\t\t\t * \t- ? 0个或1个，相当于&#123;0,1&#125;\n\t\t\t */\nvar reg = /[ab]&#123;3&#125;/;  //创建一个规则为连续出现三次字符a或者字符b的正则对象\nconsole.log(reg.test(\"adsd\"));  //输出 false\nconsole.log(reg.test(\"aabbbsd\"));  //输出 true\n\nvar reg = /s&#123;1,3&#125;/;  //创建一个规则为连续出现1到三次的字符s的正则对象\nconsole.log(reg.test(\"fgfdhg\"));  //输出 false\nconsole.log(reg.tets(\"dddssgf\")); // 输出 true\nconsole.log(reg.test(\"ssss\"));  //输出 true  -- 当虽然这里有4个s字符，但是在未开启全局模式时\n\t\t\t\t\t\t\t//还没开始检测第四个字符就会返回true\n\t\t\t\t\t\t\t//如果要求严格控制在1到3次，需要开启全局匹配模式\n\n\t\t\t/*\n\t\t\t * \t^ 表示开头\n\t\t\t * \t$ 表示结尾\n\t\t\t */\nvar reg = /^a|b$/;  //创建一个规则为以a字符开头或者b字符结尾的正则对象\nconsole.log(reg.test(\"dfdffsf\"));  //输出 false\nconsole.log(reg.test(\"adsdjjd\"));  //输出 true\nconsole.log(reg.test(\"dsfsb\"));   //输出 true\nRegExp方法\n\t\t\t/*\n\t\t\t * split()\n\t\t\t * \t- 可以将一个字符串拆分为一个数组\n\t\t\t * \t- 方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串\n\t\t\t * \t- 这个方法即使不指定全局匹配，也会全都插分\n\t\t\t */\nvar str = \"helloworld\";\nvar result = str.split(/[lr]/);  //根据字母lr来拆分字符串；\nconsole.log(result);  //输出  ['he', '', 'owo', '', 'd']\nconsole.log(result instanceof Array); //输出true\n\n\t\t\t/*\n\t\t\t * search()\n\t\t\t * \t- 可以搜索字符串中是否含有指定内容\n\t\t\t * \t- 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1\n\t\t\t * \t- 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串\n\t\t\t * \t- serach()只会查找第一个，即使设置全局匹配也没用\n\t\t\t */\nvar str = \"heooljsdhfuhdsftFFDDDhnduhasui\";\nconsole.log(str.search(/f[adHt]f/i));  //输出 14\n\n\t\t\t/*\n\t\t\t * match()\n\t\t\t * \t- 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来\n\t\t\t * \t- 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索\n\t\t\t * \t\t我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容\n\t\t\t * \t\t可以为一个正则表达式设置多个匹配模式，且顺序无所谓\n\t\t\t * \t- match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果\n\t\t\t */\nvar str = \"heooljsdhfuhdsftFFDDDhnduhasui\";\nconsole.log(str.match(/f[adHt]f/i));//输出 ['ftF', index: 14, input:'heooljsdhfuhdsftFFDDDhnduhasui']\n\n\t\t\t/*\n\t\t\t * replace()\n\t\t\t * \t- 可以将字符串中指定内容替换为新的内容\n\t\t\t *  - 参数：\n\t\t\t * \t\t1.被替换的内容，可以接受一个正则表达式作为参数\n\t\t\t * \t\t2.新的内容\n\t\t\t *  - 默认只会替换第一个\n\t\t\t */\nvar str = \"heooljsdhfuhdsftFFDDDhnduhasui\";\nconsole.log(str.replace(/f[adHt]f/gi,\"@\")); //输出 heooljsdhfuhds@FDDDhnduhasui","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"数组-Date-Math","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/21/数组-Date-Math/","content":"数组（Array）\t数组也是一个对象，功能和普通对象类似，不同的是普通对象是使用字符串来作为属性名的，而数组使用数字索引来操作元素；\n\t索引是从0开始的，数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据；\n    \n    //创建数组对象；\n    var arr = new Array();\n\tconsole.log(typeof arr);  //输出 object ；\n\t\n\t//向数组中添加元素\n\tarr[0] = 1;\n\tarr[1] = 2;\n\n\t//读取数组中的元素值 如果读取不存在的索引，不会报错而是返回 undefined；\n\tconsole.log(arr[0]); //输出 1\n\tconsole.log(arr[2]); //输出undefined\n\n\t//获取数组的长度 -- 使用 数组名.length 来获取数组的长度\n\t //对于非连续的数组，使用length会获取到数组的最大的索引+1，尽量不要创建非连续的数组\n\tconsole.log(arr.length); //输出 2\n\t\n\t//修改length 如果修改的length值大于数组现有长度，则多出的部分会空出来，否则多出的元素会被删除；\n\tarr.length = 3;\n\tconsole.log(arr);  //输出 1,2， empty\n\t\n\tarr.length = 1;\n \tconsole.log(arr); //输出 1 ；\n\n\t//向数组最后一个位置添加元素\n\tarr[arrlength] = 2;\n\tconsole.log(arr); //输出 1,2；\n\tconsole.log(arr.length); //输出 2；\n\n使用字面量来常见数组；\nvar arr = [];  //使用字面量创建一个名为 arr 的空数组；\n//创建一个数组数组中只有一个元素10\narr = [10];\nconsole.log(arr instanceof Array);  //输出 true\n\n//使用字面量创建数组时，可以在创建时就指定数组中的元素\nvar arr = [1,2,3,4,5,10];\n\n//使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作文构造函数的参数传递\n//元素之间使用,隔开\nvar arr2 = new Array(10,20,30);\nconsole.log(arr2); //  输出 Array[3] \n//使用构造函数创造数组是只传入一个参数时，这个参数会被作为设置数组的长度，而不是成为数组的第一个元素；\n//创建一个长度为10的数组\narr2 = new Array(10);\nconsole.log(arr2);  //输出 (10) [empty × 10]\n\n//数组中的元素可以是任意的数据类型，可以是五种基本数据类型，也可以是对象，函数；\nvar obj = &#123;\n    name:\"LK\"\n&#125;\nfunction fun()&#123;\n    console.log(\"ffff\");\n&#125;\narr = [\"hello\",1,true,null,undefined,obj,fun];\nconsole.log(arr[5]); //输出 &#123;name: 'LK'&#125;\n\n//数组中也可以放数组，如下这种数组我们称为二维数组\narr = [[1,2,3],[3,4,5],[5,6,7]];\nconsole.log(arr[1]);  //输出 [3,4,5]\n数组元素的插入删除方法\t\t\t/*\n\t\t\t * push()\n\t\t\t * \t- 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度\n\t\t\t * \t- 可以将要添加的元素作为方法的参数传递，\n\t\t\t * \t\t这样这些元素将会自动添加到数组的末尾\n\t\t\t * \t- 该方法会将数组新的长度作为返回值返回\n\t\t\t */\nvar arr = [1,2,3];\nvar length = arr.push(4,5);\nconsole.log(arr); // 输出 [1,2,3,4,5]\nconsole(lenght); //输出 5\n\n\t\t\t/*\n\t\t\t * pop()\n\t\t\t * \t- 该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回\n\t\t\t */\nvar value = arr.pop();\nconsole.log(arr);  //输出 [1,2,3,4]\nconsole.log(value);  //输出 5\n\n\t\t\t/*\n\t\t\t * unshift()\n\t\t\t * \t- 向数组开头添加一个或多个元素，并返回新的数组长度\n\t\t\t * \t- 向前边插入元素以后，其他的元素索引会依次调整\n\t\t\t */\nlength = arr.unshift(6,7);\nconsole.log(arr);  //输出 [6,7,1,2,3,4]\nconsole.log(length);  //输出 6\n\n\t\t\t/*\n\t\t\t * shift()\n\t\t\t * \t- 可以删除数组的第一个元素，并将被删除的元素作为返回值返回\n\t\t\t */\nvalue = arr.shift();\nconsole.log(arr);  //输出 [7,1,2,3,4]\nconsole.log(value);  //输出 6；\nforEach()除了使用for循环去遍历数组，还可以使用forEach()方法遍历数组，该方法只支持IE8以上的浏览器；\n\nforEach()方法需要传入一个函数作为参数\n\t这种由我们创建但不是我们主动调用的函数称为回调函数；\n    在forEach()函数中，数组有几个元素该函数就会被执行几次；\n    可以在传入的回调函数书写自己的业务，可以在回调函数中传入3个参数，\n    \t第一个参数 -- 当前正在遍历的元素\n        第二个元素 -- 当前正在遍历的元素的索引\n        第三个元素 -- 正在遍历的完整数组；\n        \n var arr = [1,2,3,4,5];\narr.forEach(function(value,index,obj)&#123;\n    //value是当前遍历到的数组元素\n    //index是当前正在遍历的元素索引\n    //obj是当前传入的整个数组对象\n    ...业务逻辑;\n    ...\n&#125;);\nslice()\t\t\t/*\n\t\t\t * slice()\n\t\t\t * \t- 可以用来从数组提取指定元素\n\t\t\t * \t- 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回\n\t\t\t * \t- 参数：\n\t\t\t * \t\t1.截取开始的位置的索引,包含开始索引\n\t\t\t * \t\t2.截取结束的位置的索引,不包含结束索引\n\t\t\t * \t\t\t- 第二个参数可以省略不写,此时会截取从开始索引往后的所有元素\n\t\t\t * \t\t- 索引可以传递一个负值，如果传递一个负值，则从后往前计算\n\t\t\t * \t\t\t-1 倒数第一个\n\t\t\t * \t\t\t-2 倒数第二个\n\t\t\t */\n\nvar arr = [1,2,3,4,5];\nvar results = arr.slice(1,3);\nconsole.log(arr);  //返回 Array(5) [1,2,3,4,5]\nconsole.log(results);  //返回Array(2) [2,3]\nconsole.log(typeof results); //返回 Object\nsplice()\t\t\t/*\n\t\t\t * splice()\n\t\t\t * \t- 可以用于删除数组中的指定元素\n\t\t\t * \t- 使用splice()会影响到原数组，会将指定元素从原数组中删除\n\t\t\t * \t\t并将被删除的元素作为返回值返回\n\t\t\t * \t- 参数：\n\t\t\t * \t\t第一个，表示开始位置的索引\n\t\t\t * \t\t第二个，表示删除的数量\n\t\t\t * \t\t第三个及以后。。\n\t\t\t * \t\t\t可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边\n\t\t\t * \t\n\t\t\t */\nvar arr = [1,2,3,4,5,6];\nvar results = arr.splice(1,3,7,8);\nconsole.log(arr);  //返回 Array(5) [1,7,8,5,6]\nconsole.log(results);  //返回 Array(3) [2,3,4]\nconcat()\t\t\t/*\n\t\t\t * concat()可以连接两个或多个数组，并将新的数组返回\n\t\t\t * \t- 该方法不会对原数组产生影响\n\t\t\t */\nvar arr = [1,2,3];\nvar arr2 = [4,5,6];\nvar results = arr.concat(arr2);\nconsole.log(arr); //返回 Array(3) [1,2,3]\nconsole.log(arr2); //返回 Array(3) [4,5,6]\nconsole.log(results);  //返回 Array(6) [1,2,3,4,5,6]\njoin()\t\t\t/*\n\t\t\t * join()\n\t\t\t * \t- 该方法可以将数组转换为一个字符串\n\t\t\t * \t- 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回\n\t\t\t * \t- 在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符\n\t\t\t * \t\t如果不指定连接符，则默认使用 , 作为连接符\n\t\t\t */\nvar arr = [\"hello\",\"world\",\"LK\"];\nvar results = arr.join(\"-\");\nconsole.log(arr);  //返回原数组\nconsole.log(results);  //返回字符串 hello-world-LK\nconsole.log(typeof results); // 返回 string\nreverse()\t\t\t/*\n\t\t\t * reverse()\n\t\t\t * \t- 该方法用来反转数组（前边的去后边，后边的去前边）\n\t\t\t * \t- 该方法会直接修改原数组\n\t\t\t */\nvar arr = [1,2,3,4,5,6];\narr.reverse();\nconsole.log(arr); //返回 Array(6)  [6,5,4,3,2,1]\nsort()\t\t\t/*\n\t\t\t * sort()\n\t\t\t * \t- 可以用来对数组中的元素进行排序\n\t\t\t * \t- 也会影响原数组，默认会按照Unicode编码进行排序\n\t\t\t */\nvar arr = [1,3,2,6,4,7,5];\narr.sort();\nconsole.log(arr);  //返回  Array(7) [1,2,3,4,5,6,7]\narr = [11,2,5,34,3,6];\narr.sort();\nconsole.log(arr);  //返回 Array(5) [11, 2, 3, 34, 5, 6]  可知sort方法使用Unicode编码进行比较排序\n\n\t\t\t/*\n\t\t\t * 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，\n\t\t\t * \t所以对数字进排序时，可能会得到错误的结果。\n\t\t\t * \n\t\t\t * 我们可以自己来指定排序的规则\n\t\t\t * \t我们可以在sort()添加一个回调函数，来指定排序规则，\n\t\t\t * \t\t回调函数中需要定义两个形参,\n\t\t\t * \t\t浏览器将会分别使用数组中的元素作为实参去调用回调函数\n\t\t\t * \t\t使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边\n\t\t\t * \t- 浏览器会根据回调函数的返回值来决定元素的顺序，\n\t\t\t * \t\t如果返回一个大于0的值，则元素会交换位置\n\t\t\t * \t\t如果返回一个小于0的值，则元素位置不变\n\t\t\t * \t\t如果返回一个0，则认为两个元素相等，也不交换位置\n\t\t\t * \n\t\t\t * \t- 如果需要升序排列，则返回 a-b\n\t\t\t * \t\t如果需要降序排列，则返回b-a\n\t\t\t */\narr = [5,4,2,1,3,6,8,7];\narr.sort(function(a,b)&#123;\n    //升序排列\n\t//return a - b;\n\t\t\t\t\n\t//降序排列\n\treturn b - a;\n&#125;);\nconsole.log(arr);  //返回 Array(8) [8, 7, 6, 5, 4, 3, 2, 1]\ncall()和apply()\t\t\t/*\n\t\t\t * call()和apply()\n\t\t\t * \t- 这两个方法都是函数对象的方法，需要通过函数对象来调用\n\t\t\t * \t- 当对函数调用call()和apply()都会调用函数执行\n\t\t\t * \t- 在调用call()和apply()可以将一个对象指定为第一个参数\n\t\t\t * \t\t此时这个对象将会成为函数执行时的this\n\t\t\t * \t- call()方法可以将实参在对象之后依次传递\n\t\t\t * \t- apply()方法需要将实参封装到一个数组中统一传递\n\t\t\t * \n\t\t\t * \t- this的情况：\n\t\t\t * \t\t1.以函数形式调用时，this永远都是window\n\t\t\t * \t\t2.以方法的形式调用时，this是调用方法的对象\n\t\t\t * \t\t3.以构造函数的形式调用时，this是新创建的那个对象\n\t\t\t * \t\t4.使用call和apply调用时，this是指定的那个对象\n\t\t\t */\nvar name  = \"Hello\";\nvar obj = &#123;\n    name:\"LK\"\n&#125;\nvar obj2  = &#123;\n    name:\"ZK\"\n&#125;\nfunction fun()&#123;\n    console.log(this.name);\n&#125;\nfun();  // 输出 Hello\nfun.call(obj); //输出 LK\nfun.apply(obj2);  //输出 ZK\n\nfunction  fun2(a,b)&#123;\n    console.log(this.name);\n    console.log(\"a = \"+a);\n    console.log(\"b = \"+b);\n&#125;\nfun2.call(obj,1,2);  //输出 LK a = 1, b = 2\nfun2.apply(obj2,[1,2]);  //输出 ZK a = 1, b = 2\narguments\t\t\t/*\n\t\t\t * 在调用函数时，浏览器每次都会传递进两个隐含的参数：\n\t\t\t * \t1.函数的上下文对象 this\n\t\t\t * \t2.封装实参的对象 arguments\n\t\t\t * \t\t- arguments是一个类数组对象,它也可以通过索引来操作数据，也可以获取长度\n\t\t\t * \t\t- 在调用函数时，我们所传递的实参都会在arguments中保存\n\t\t\t * \t\t- arguments.length可以用来获取实参的长度\n\t\t\t * \t\t- 我们即使不定义形参，也可以通过arguments来使用实参，\n\t\t\t * \t\t\t只不过比较麻烦\n\t\t\t * \t\t\targuments[0] 表示第一个实参\n\t\t\t * \t\t\targuments[1] 表示第二个实参 。。。\n\t\t\t *\t\t- 它里边有一个属性叫做callee，\n\t\t\t * \t\t\t这个属性对应一个函数对象，就是当前正在指向的函数的对象\n\t\t\t * \t\t\n\t\t\t */\nfunction fun()&#123;\n    console.log(arguments[0]);   // 输出 1\n    console.log(arguments[1]);   // 输出 2\n    console.log(arguments.callee);\n    //输出：\n    /*  \n    ƒ fun()&#123;\n\t\t\t\tconsole.log(arguments[0]);\n\t\t\t\tconsole.log(arguments[1]);\n\t\t\t\tconsole.log(arguments.callee);\n\t\t\t&#125;\n\t*/\n&#125;\nfun(1,2);\nDateDate 对象 --- 在JS中表示一个时间\n\n//创建一个Date对象 -- 使用构造函数 ，不传参数 ，默认封装为当前代码的执行时间\nvar time = new Date();\nconsole.log(time);  // 返回 Tue Mar 22 2022 10:49:26 GMT+0800 (中国标准时间)\nconsole.log(typeof time);  //返回 object\n\n//创建一个指定时间对象，需要在构造函数中传递一个时间字符串作为参数 月份/日/年 时:分:秒\nvar time = new Date(\"6/7/2018 09:00:00\");\n//获取当前对象是多少号\nconsole.log(time.getDate());  //返回 7 -- 表示为这个月的7号\n//获取当前对象的月份\nconsole.log(time.getMonth());  //返回 5 -- 表示 6月 一月为0\n//获取当前对象是周几\nconsole.log(time.getDay());  //返回 4 表示是周4 每个星期从周日开始，从0开始\n//获取当前对象的年份\nconsole.log(time.getFullYear());  //返回 2018\n\n\t\t\t/*\n\t\t\t * getTime()\n\t\t\t * \t- 获取当前日期对象的时间戳\n\t\t\t * \t- 时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒\n\t\t\t * \t\t到当前日期所花费的毫秒数（1秒 = 1000毫秒）\n\t\t\t * \t- 计算机底层在保存时间时使用都是时间戳\n\t\t\t */\nconsole.log(time.getTime());  //返回 1528333200000\nMathMath和其他对象不同，它不是一个构造函数，属于一个工具类，不需要创建对象，可以直接调用其身上的相关方法；\n\nconsole.log(Math.PI);  //返回 3.141592653589793\nconsole.log(Math.E);  //返回 底数 e 2.718281828459045\n\nconsole.log(Math.abs(-1));  //返回 -1 的绝对值  1\n\n\t\t\t/*\n\t\t\t * Math.ceil()\n\t\t\t * \t- 可以对一个数进行向上取整，小数位只要有值就自动进1\n\t\t\t * Math.floor()\n\t\t\t * \t- 可以对一个数进行向下取整，小数部分会被舍掉\n\t\t\t * Math.round()\n\t\t\t * \t- 可以对一个数进行四舍五入取整\n\t\t\t */\nconsole.log(Math.ceil(1.0000001));  //返回 2\nconsole.log(Math.floor(1.9999999));  //返回 1\nconsole.log(Math.round(1.49999999));  // 返回 1\nconsole.log(Math.round(1.500000001));  // 返回 2\n\n\t\t\t/*\n\t\t\t * Math.random()\n\t\t\t * \t- 可以用来生成一个0-1之间的随机数  包含0 不包含1\n\t\t\t *  - 生成一个0-10的随机数\n\t\t\t * \t- 生成一个0-x之间的随机数\n\t\t\t * \t\tMath.round(Math.random()*x)\n\t\t\t * \n\t\t\t * \t- 生成一个1-10\n\t\t\t * \t- 生成一个x-y之间的随机数\n\t\t\t * \t\tMath.round(Math.random()*(y-x)+x)\n\t\t\t \n\t\t\t Math.random()*n --- 相当于将（0到1，包括0，不包括1）之间的数扩大n倍，此时能表示的范围为（0到n，包括0，但是不包括n）\n\t\t\t Math.random()*(y-x) -- 相当于将（0到1，包括0，不包括1）之间的数扩大（y-x）倍，此时能表示的范围为（0到 y-x ，包括0，但是不包括y-x）\n\t\t\t Math.random()*(y-x)+x -- 相当于将（0到 y-x）之间的数增大x，此时能表示的范围是（x到y，包括x，但是不包括y）\n\t\t\t Math.round(Math.random()*(y-x)+x) -- 相当于将（x到y，包括x，但是不包括y）之间的数进行四舍五入，此时能表示的范围是（x到y之间的所有整数，包括 x 和 y）\n\t\t\t */\n//随机生成 10 个 0到1的数\nfor(var i = 0; i &lt; 10 ; i++)&#123;\n   console.log(Math.random()); \n&#125;\n//随机生成 10 个 1到10 的数（不包含10）\nfor(var i = 0; i &lt; 10 ; i++)&#123;\n   console.log(Math.random()*10); \n&#125;\n//随机生成0到10的整数(包含1和10)\nfor(var i = 0; i &lt; 10 ; i++)&#123;\n   console.log(Math.round(Math.random()*10)); \n&#125;\n//随机生成一个 1 到 9 的数\nfor(var i = 0; i &lt; 10 ; i++)&#123;\n   console.log(Math.round(Math.random()*(9-1)+1)); \n&#125;\n\n\t\t\t/*\n\t\t\t * max() 可以获取多个数中的最大值\n\t\t\t * min() 可以获取多个数中的最小值\n\t\t\t */\nconsole.log(Math.max(1,45,43,33,5,4,226));  // 输出 226\nconsole.log(Math.min(1,45,43,33,5,4,226)); // 输出 1\n\n\t\t\t/*\n\t\t\t * Math.pow(x,y)\n\t\t\t * \t返回x的y次幂\n\t\t\t */\nconsole.log(Math.pow(2,3));  //返回 8\n\n\t\t\t/*\n\t\t\t * Math.sqrt()\n\t\t\t *  用于对一个数进行开方运算\n\t\t\t */ \nconsole.log(Math.sqrt(9));  //返回 3\n包装类\t\t\t/*\n\t\t\t * 基本数据类型\n\t\t\t * \tString Number Boolean Null Undefined\n\t\t\t * 引用数据类型\n\t\t\t * \tObject\n\t\t\t * \n\t\t\t * 在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象\n\t\t\t * \tString()\n\t\t\t * \t\t- 可以将基本数据类型字符串转换为String对象\n\t\t\t * \tNumber()\n\t\t\t * \t\t- 可以将基本数据类型的数字转换为Number对象\n\t\t\t *  Boolean()\n\t\t\t * \t\t- 可以将基本数据类型的布尔值转换为Boolean对象\n\t\t\t * \t但是注意：我们在实际应用中不会使用基本数据类型的对象，\n\t\t\t * \t\t如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果\n\t\t\t */\n//创建一个Number类对象 num\nvar num = new Number();\nnum.number = 1;\nconsole.log(num.number);  //输出 1\n//创建一个String类对象 str\nvar str = new String();\nstr.strs = \"hello\";\nconsole.log(str.strs);  //输出 hello\n//创建一个Boolean类对象 bool\nvar bool =  new Boolean();\nbool.flag = true;\nconsole.log(bool.flag); //输出 true\n\n\t\t\t/*\n\t\t\t * 可以给对象添加方法和属性，但是不能给基本数据类型添加属性和方法\n\t\t\t * \t当我们对一些基本数据类型的值去调用属性和方法时，\n\t\t\t * \t\t浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法\n\t\t\t * \t\t调用完以后，在将其转换为基本数据类型\n\t\t\t */\n\nvar a = 123;\na = a.toString();\nconsole.log(a);  //输出字符串 123\nconsole.log(typeof a);  //输出 string\n//这里之所以可以调用基本数据类型的额方式，其实是解析器在背后先将为number类型的a隐含的转换成Number类对象，并调用其身上的方法toString(),之后将将转换string‘值再返回给a，而不是返回Number对象；","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"this-构造函数-原型对象-原型","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/21/this-构造函数-原型对象-原型/","content":"this\t浏览器的解析器在每次调用函数时都会向函数内部传递一个隐含的参数 --- this ，this 指向一个对象 --- 函数执行的上下文（context）对象；\n\t根据函数的调用方式不同，this会指向不同的对象；\n    \t1.以函数的形式调用时，this指向window；\n        2.以方法的形式调用时，this指向当前调用方法的对象；\n        \n  function fun()&#123;\n      consolo.log(this);\n  &#125;\n\nfun();  //输出window；\n\nvar obj = &#123;\n    name:'LK',\n    fun:fun\n&#125;\nobj.fun();  //输出obj对象；\n\n在调用对象的方法时，可以在方法中通过this获取当前对象的其他属性值；\n\nvar obj2 = &#123;\n    name:\"obj2\",\n    fun:function()&#123;\n        console.log(this.name);\n    &#125;\n&#125;\nobj2.fun();  //输出obj2 ；\n\n工厂方法创建对象使用工厂方法可以快速创建对象；\n\t//定义一个可以生成包含name，age，gender属性值的对象的函数，返回值是对象；\n\tfunction createPerson(name,age,gender)&#123;\n        var obj = new Object();\n        obj.name = name;\n        obj.age = age;\n        obj.gender = gender;\n        obj.sayName = function()&#123;\n            console.log(this.name);\n        &#125;\n        return obj;\n    &#125;\n\n\tfunction createDog(name,age)&#123;\n        var obj = new Object();\n        obj.name = name;\n        obj.age = age;\n        obj.sayHello = function()&#123;\n            console.log(\"旺旺\");\n        &#125;\n        return obj;\n    &#125;\n\t\n\t//创建一个人的对象\n\tvar objPerson = createPerson(\"LK\",18,\"man\");\n\t//创建一个狗的对象\n\tvar objDog = createDog(\"lily\",1);\n\tconsole.log(objPerson);\n\tconsole.log(objDog);\n\t控制台输出均是Object，若不展开无法区分它们的区别；\n构造函数构造函数就是一个普通的函数，创建方法和普通函数一样，有一点不同的是构造函数的命名通常会首字母大写；\n\n在JS中直接调用的可以看成是普通函数，一旦使用 new 关键字就会把普通函数当成构造函数使用；\n\n构造函数的执行流程：\n\t1.首先创造一个对象；\n    2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象；\n    3.依次执行构造函数的代码；\n    4.将新建的对象作为返回值返回（构造函数是默认返回返回当前的新建对象的，即使不书写return也会返回；）；\n    \n 使用构造函数创建的对象，称为一类对象，也将一个构造函数称为一个类；我们将通过一个构造函数创建的对象称为是该类的实例；\n \n this的情况：\n\t\t\t * \t1.当以函数的形式调用时，this是window\n\t\t\t * \t2.当以方法的形式调用时，谁调用方法this就是谁\n\t\t\t * \t3.当以构造函数的形式调用时，this就是新创建的那个对象\n \n //定义一个Person类\n function Person(name,age,gender)&#123;\n     this.name = name;\n     this.age = age;\n     this.gender = gender;\n     this.sayName = function()&#123;\n         console.log(this.name);\n     &#125;\n     return this; //这一句有无都可以，构造函数默认返回this；但如果是当成普通函数调用的话，此时的this指向的是window；也就是说调用这个函数会往window身上设置name，age，gender等属性；\n &#125;\n\n//定义一个Dog类\nfunction Dog(name,age)&#123;\n    this.name = name;\n    this.age = age;\n    this.sayHello() = function()&#123;\n        console,log(\"旺旺\");\n    &#125;\n    return this;\n&#125;\n\n//创建一个Person类的实例 使用new关键字\nvar person = new Person(\"LK\",18,\"man\");\n//创建一个Dog类的实例\nvar dog = new Dog(\"lily\",1);\nconsole.log(person);\nconsole.log(dog);\n\n输出：\nPerson &#123;name: 'LK', age: 18, gender: 'man', sayName: ƒ&#125;\nDog &#123;name: 'lily', age: 1, sayHello: ƒ&#125;\n\n构造函数与工厂方式创建对象的不同在于可以看出构造函数创建的对象所属的类名；\n\n\t\t\t/*\n\t\t\t * 使用instanceof可以检查一个对象是否是一个类的实例\n\t\t\t * \t语法：\n\t\t\t * \t\t对象 instanceof 构造函数\n\t\t\t * 如果是，则返回true，否则返回false\n\t\t\t */\nconsole.log(person instanceof Person);  //输出true；\nconsole.log(person instanceof Dog);\t\t//输出false；\n原型 – prototype\t\t\t我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype\n\t\t\t * \t\t这个属性对应着一个对象，这个对象就是我们所谓的原型对象\n\t\t\t * \t如果函数作为普通函数调用prototype没有任何作用\n\t\t\t * \t当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性\n\t\t\t * \n\t\t\t * \t原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，\n\t\t\t * \t\t我们可以将对象中共有的内容，统一设置到原型对象中。\n\t\t\t * \n\t\t\t * 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，\n\t\t\t * \t如果没有则会去原型对象中寻找，如果找到则直接使用\n\t\t\t * \n\t\t\t * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，\n\t\t\t * \t这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了\n\n//声明一个全局作用函数\nfunction myClass()&#123;\n    \n&#125;\n//访问函数中的隐含属性prototype\nconsole.log(myClass.prototype);\n输出：\n&#123;constructor: ƒ&#125;\nconstructor: ƒ myClass()\n[[Prototype]]: Object\n可知函数身上确实有该prototype隐含属性；\n\n//声明Person类构造函数\n //定义一个Person类\n function Person(name,age,gender)&#123;\n     this.name = name;\n     this.age = age;\n     this.gender = gender;\n     this.sayName = function()&#123;\n         console.log(this.name);\n     &#125;\n     //默认返回this\n &#125;\n//向Person类的原型对象身上添加属性\nPerson.prototype.myName = \"我是Person类的原型对象的myName\";\n//向Person类的原型对象身上添加方法\nPerson.prototype.fun = function()&#123;\n    console.log(\"我是Person类原型对象身上的fun方法\");\n&#125;\n//创建一个Person类实例\nvar person1 = new Person(\"LK\",12,\"man\");\nvar person2 = new Person(\"Lily\",12,\"female\");\n//访问person1 和 person2 身上myName属性值\nconsole.log(person1.myName);\nconsole.log(person2.myName);\n输出：\n我是Person类的原型对象的myName\n我是Person类的原型对象的myName\n\n可知设置在构造函数的原型对象身上的属性和方法，同一个类（同一个构造函数）的实例都可以访问到；\n类的原型对象可以通过 实例的__proto__属性进行访问；该属性是在创建类实例是隐含添加的，同一个类的所有实例对象的__proto__属性值的指针都指向同一个原型对象，也就是一个类只有一个原型对象，也可以说是同一个类的所有实例对象共享同一个原型对象；\n\n//访问person1和person2对象上的__proto__属性\nconsole.log(person1.__proto__);\nconsole.log(person2.__proto__);\n均输出：\n&#123;myName: '我是Person类的原型对象的myName', fun: ƒ, constructor: ƒ&#125;\nfun: ƒ ()\nmyName: \"我是Person类的原型对象的myName\"\nconstructor: ƒ Person(name,age,gender)\n[[Prototype]]: Object\n\n//判断person1和person2对象的__proto__是否是同一个\nconsole.log(person1.__proto__ == person2.__proto__);\n输出 ： true；\n\n//判断Person类的原型对象和Person类实例对象的原型对象是否相等\nconsole.log(Person.prototype == person2.__proto__);\t\t\n输出 ： true；\n\n//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true\nconsole.log(\"toString\" in person1);  //输出true\n//可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性\n//使用该方法只有当对象自身中含有属性时，才会返回true\nconsole.log(person1.hasOwnProperty(\"toString\")); //输出false\n\n\t\t\t/*\n\t\t\t * 原型对象也是对象，所以它也有原型，\n\t\t\t * \t当我们使用一个对象的属性或方法时，会现在自身中寻找，\n\t\t\t * \t\t自身中如果有，则直接使用，\n\t\t\t * \t\t如果没有则去原型对象中寻找，如果原型对象中有，则使用，\n\t\t\t * \t\t如果没有则去原型的原型中寻找,直到找到Object对象的原型，\n\t\t\t * \t\tObject对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined\n\t\t\t */\nconsole.log(person1.__proto__.__proto__.hasOwnProperty(\"toString\")); //输出true\n\n\n优化构造函数中的方法  – 通用函数放在全局作用域声明//定义一个Person类\nfunction Person(name,age,gender)&#123;\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n    this.sayName = function()&#123;\n        console.log(this.name);\n    &#125;\n    //默认返回this\n&#125;\n\n在此构造函数中定义了一个sayName方法，在构造函数每执行一次创建一个新对象时，就会为这个新对象创建一个独属于自己的sayName方法，不同的对象实例需要在内存中占用不一样的堆内存区域，但其实每个Person实例对象的sayName方法的代码都是一致的，这样会导致内存资源的极大消耗；\n所以可以将通用的类方法放在全局作用域中声明；之后在类的构造函数中引用该全局作用域的函数；可以认为在创建每一个类实例对象时，它的身上都有一个sayName方法属性，但是它的sayName方法指针是指向全局作用域声明的sayName函数；\n   //声明全局的sayName函数\n   function sayName()&#123;\n       console.log(this.name);\n       //若将全局作用域声明的函数在类实例中使用时，此时的this不是指向window，而是此时调用该方法的类实例对象；\n   &#125;\n //定义一个Person类\nfunction Person(name,age,gender)&#123;\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n    //在类中使用全局的函数\n    this.sayName = sayName;\n    //默认返回this\n&#125;\n\n//创建一个Person类实例 \nvar person = new Person(\"LK\",17,\"man\");\n//调用person实例上的方法\nperson.sayName();\n输出 LK ；\n优化构造函数中的方法 – 通用函数在原型对象上声明将类的方法定义在全局作用域中，会污染全局作用域的命名空间，应该把类通用方法声明在类的原型对象身上；\n //定义一个Person类\n function Person(name,age,gender)&#123;\n     this.name = name;\n     this.age = age;\n     this.gender = gender;\n     //在类中使用全局的函数\n     this.sayName = sayName;\n     //默认返回this\n &#125;\n//向原型中添加sayName方法\n\t\t\tPerson.prototype.sayName = function()&#123;\n\t\t\t\talert(\"Hello大家好，我是:\"+this.name);\n\t\t\t&#125;;\n修改原型的toString方法//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值\n//如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法\n\tfunction Person(name , age , gender)&#123;\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.age = age;\n\t\t\t\tthis.gender = gender;\n\t\t\t&#125;\n//修改Person原型的toString\n\t\t\tPerson.prototype.toString = function()&#123;\n\t\t\t\treturn \"Person[name=\"+this.name+\",age=\"+this.age+\",gender=\"+this.gender+\"]\";\n\t\t\t&#125;;\n垃圾回收/*\n * 垃圾回收（GC）\n * \t- 就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾\n * \t\t这些垃圾积攒过多以后，会导致程序运行的速度过慢，\n * \t\t所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾\n *  - 当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，\n * \t\t此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，\n * \t\t所以这种垃圾必须进行清理。\n * \t- 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，\n * \t\t我们不需要也不能进行垃圾回收的操作\n * \t- 我们需要做的只是要将不再使用的对象设置null即可\n * \n */\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"对象-函数","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/20/对象-函数/","content":"对象重温JS的五种基本数据类型：\n\t1.String；\n    2.Number； --- NaN也属于Number类型；\n\t3.Boolean；\n    4.undefined；\n    5.NULL； --- typeof null 输出object，null为object的衍生；\n    \n    基本数据类型都是单一的值，值和值之间没有联系；\n    对象属于一种复合数据类型，在对象中可以保存多个不同数据类型的属性；\n    \n    对象的分类：\n    \t1.内建对象：由ES标准定义的对象，在任何ES的实现中都可以使用，比如 Math，String，Number，Boolean，Function，Object等；\n        2.宿主对象：由JS的运行环境提供的对象，目前主要指浏览器提供的对象，比如BOM，DOM；\n        3.自定义对象：由开发人员自己创建的对象；\n        \n     创建对象：\n     \t使用 new 关键字调用对象的构造函数\n\t\tvar obj = new Object();\n\t\t\n\t\t在对象中保存的值称为属性，向对象添加属性，语法：对象.属性名 = 属性值;\n\t\tobj.name = \"LK\";\n\n\t\t读取对象中的属性值，语法：对象.属性名\n\t\tconsole.log(obj.name);\n\t\t如果读取对象中没有的属性值，不会报错而是返回undefined；\n        \n        修改对象的属性值，语法：对象.属性名 = 新的属性值；\n        obj.name = \"ZK\";\n\t\t\n\t\t删除对象的属性，语法：delete 对象.属性值;\n\t\tdelete obj.name;\n\n\t属性名：对象的属性名不强制要求遵守标识符的规范；\n    \t如果要是用特殊的属性名，需要使用另一种方式读取属性值：\n        \t语法：对象[\"属性名\"]\n\t属性值：对象的属性值可以是任何类型的数据类型，5种基本数据类型，对象，函数等\n    \tin 运算符：可以通过该运算符检查一个对象中是否含有指定的属性，返回值为Boolean；\n\t\tconsole.log(\"name\" in obj);\n\t\t\n基本数据类型与引用数据类型在新建基本数据类型的变量时，都是直接在内存的栈中开辟内存空间存放数据；\n\tvar a = 123; //此时程序在栈顶开辟一个内存区域存放变量名 a 和变量值 123，此时栈顶指针上移一位；\n\tvar b = a; //此时程序在栈顶开辟一个内存区域存放变量名 b 和变量值 123，此时栈顶指针上移一位；\n\ta = 456; //在程序的内存区域中寻找变量a的存放地址，并修改其变量值为 456；\n\tconsole.log(\"a = \"+a); //输出 a = 456；\n\tconsole.log(\"b = \"+ b); //输出 b = 123;\n\t可知内存中存放的基本数据类型变量都是单独存放的，值与值之间不会影响；\n \n在新建引用型变量 -- 对象时，会在内存的栈区存放对象名和对象的堆内存地址，在堆内存中存放对象的数据信息；\n\tvar obj = new Object(); //创建一个名为 obj 的对象，在栈顶申请内存空间存放对象名和该对象的堆内存地址，此时obj已经申请了堆内存空间，但还未存放信息；\n\tobj.name = \"LK\"; //给obj新建属性name，值为 LK，数据信息将存储在obj的堆内存区域；\n\tvar obj2 = obj; //新建一个obj2 对象，在栈内存区域申请空间存放对象名 obj2 和它的堆内存地址，此时obj2的堆内存地址和obj的堆内存地址相同，也就是这两个对象的堆内存指针指向同一块内存区域；\n\tobj.name = \"ZK\"; //修改obj的name属性值；\n\tconsole.log(obj.name);\n\tconsole.log(obj2.name);\n\t均输出 ZK ；//可知对象如果保存的是同一个对象的地址引用，则通过一个对象修改属性值时，另一个也会受到影响；\n    \n    \t\t/*\n\t\t\t * 当比较两个基本数据类型的值时，就是比较值。\n\t\t\t * 而比较两个引用数据类型时，它是比较的对象的内存地址，\n\t\t\t * \t\t如果两个对象是一摸一样的，但是地址不同，它也会返回false\n\t\t\t */\n    \n对象字面量在日常开发中，使用对象字面量创建一个对象比较常用；\n\tvar obj = &#123;&#125;; //创建一个名为 obj 的空对象；\n\n\t\t\t/*\n\t\t\t * 使用对象字面量，可以在创建对象时，直接指定对象中的属性\n\t\t\t * 语法：&#123;属性名:属性值,属性名:属性值....&#125;\n\t\t\t * \t对象字面量的属性名可以加引号也可以不加，建议不加,\n\t\t\t * \t如果要使用一些特殊的名字，则必须加引号\n\t\t\t * \n\t\t\t * 属性名和属性值是一组一组的名值对结构，\n\t\t\t * \t名和值之间使用:连接，多个名值对之间使用,隔开\n\t\t\t * \t如果一个属性之后没有其他的属性了，就不要写,\n\t\t\t */\n\t\t\tvar obj2 = &#123;\n\t\t\t\t\n\t\t\t\tname:\"猪八戒\",\n\t\t\t\tage:13,\n\t\t\t\tgender:\"男\",\n\t\t\t\ttest:&#123;name:\"沙僧\"&#125;\n\t\t\t\t\n\t\t\t&#125;;\n枚举对象中的属性枚举对象中的属性 -- 遍历对象中的属性；\n\t使用 for ... in 语句\n\t\t语法:\n\t\t\tfor(var 变量 in 对象名)&#123;\n                要执行的语句；\n                ...\n            &#125;\n                \n            * for...in语句 对象中有几个属性，循环体就会执行几次\n\t\t\t * \t每次执行时，会将对象中的一个属性名赋值给变量\n\t\t\t */\n\t\t\t\n\t\t\tfor(var n in obj)&#123;\n\t\t\t\tconsole.log(\"属性名:\"+n);\n\t\t\t\t\n\t\t\t\tconsole.log(\"属性值:\"+obj[n]);\n\t\t\t&#125;\n\n\n函数\t\t\t/*\n\t\t\t * 函数 function\n\t\t\t * \t- 函数也是一个对象\n\t\t\t * \t- 函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）\n\t\t\t * \t- 函数中可以保存一些代码在需要的时候调用\n\t\t\t * \t- 使用typeof检查一个函数对象时，会返回function\n\t\t\t */\n创建函数：\n\t方法1，使用构造函数来创建一个函数对象（开发中基本不使用）\n    \t//将要封装的代码以字符串的形式传递给构造函数；\n    \tvar func = new Function(\"console.log('创建一个名为func的函数！')\");\n\n\t方法2，使用函数声明来创建一个函数\n    \t语法：\n        \tfunction 函数名([形参1，形参2，...])&#123;\n                语句;\n                ...\n            &#125;\n         \n      方法3，使用函数表达式来创建一个函数\n      \tvar 函数名 = function([形参1，形参2,...])&#123;\n            语句；\n            ...\n        &#125;\n            \n 调用函数：\n \t函数名();\n函数的参数可以在函数的()中来指定一个或多个形参（形式参数），多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值；\n\t\t/*\n\t\t * 在调用函数时，可以在()中指定实参（实际参数）\n\t\t * \t实参将会赋值给函数中对应的形参\n\t\t */\n\t\t/*\n\t\t * 调用函数时解析器不会检查实参的类型,\n\t\t * \t所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查\n\t\t * 函数的实参可以是任意的数据类型\n\t\t */\n\t\t/*\n\t\t * 调用函数时，解析器也不会检查实参的数量\n\t\t * \t多余实参不会被赋值\n\t\t * 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined\n\t\t * \n\t\t */\n函数的返回值* 可以使用 return 来设置函数的返回值\n* \t语法：\n* \t\treturn 值\n* \n* \treturn后的值将会会作为函数的执行结果返回，\n* \t\t可以定义一个变量，来接收该结果\n* \n*  在函数中return后的语句都不会执行\n* \n* \t如果return语句后不跟任何值就相当于返回一个undefined，\n* \t如果函数中不写return，则也会返回undefined\n* \n* \treturn后可以跟任意类型的值\n\n立即执行函数/*\n * 立即执行函数\n * \t函数定义完，立即被调用，这种函数叫做立即执行函数\n * \t立即执行函数往往只会执行一次\n */\n/*(function()&#123;\n\talert(\"我是一个匿名函数~~~\");\n&#125;)();*/\n\n(function(a,b)&#123;\n\tconsole.log(\"a = \"+a);\n\tconsole.log(\"b = \"+b);\n&#125;)(123,456);\n输出 a = 123;\n\tb = 456;\n对象中的函数//对象的属性值可以是任何的数据类型，也可以是个函数\nobj.sayName = function()&#123;\n\t\t\t\tconsole.log(obj.name);\n\t\t\t&#125;;\n\n\t\t\t/*\n\t\t\t * 函数也可以称为对象的属性，\n\t\t\t * \t如果一个函数作为一个对象的属性保存，\n\t\t\t * \t那么我们称这个函数时这个对象的方法\n\t\t\t * \t调用这个函数就说调用对象的方法（method）\n\t\t\t * \n\t\t\t * 但是它只是名称上的区别没有其他的区别\n\t\t\t * \n\t\t\t */\n作用域（scope）\t\t\t/*\n\t\t\t * 作用域\n\t\t\t * \t- 作用域指一个变量的作用的范围\n\t\t\t * \t- 在JS中一共有两种作用域：\n\t\t\t * \t\t1.全局作用域\n\t\t\t * \t\t\t- 直接编写在script标签中的JS代码，都在全局作用域\n\t\t\t * \t\t\t- 全局作用域在页面打开时创建，在页面关闭时销毁\n\t\t\t * \t\t\t- 在全局作用域中有一个全局对象window，\n\t\t\t * \t\t\t\t它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用\n\t\t\t * \t\t\t- 在全局作用域中：\n\t\t\t * \t\t\t\t创建的变量都会作为window对象的属性保存\n\t\t\t * \t\t\t\t创建的函数都会作为window对象的方法保存\n\t\t\t * \t\t\t- 全局作用域中的变量都是全局变量，\n\t\t\t * \t\t\t\t在页面的任意的部分都可以访问的到\n\t\t\t * \n\t\t\t * \t\t2.函数作用域\n\t\t\t * \n\t\t\t */\n\nvar a = 123;\nconsole.log(window.a); //输出 123 ；\n\nfunction func()&#123;\n    console.log(\"hello\");\n&#125;\nwindow.func();  //输出 hello；\n变量的提前声明\t\t\t/*\n\t\t\t * 变量的声明提前\n\t\t\t * \t- 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），\n\t\t\t * \t\t但是如果声明变量时不适用var关键字，则变量不会被声明提前\n\t\t\t * \n\t\t\t * 函数的声明提前\n\t\t\t * \t- 使用函数声明形式创建的函数 function 函数()&#123;&#125;\n\t\t\t * \t\t它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数\n\t\t\t * \t   使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用\t\n\t\t\t */\n\n&lt;script>\n    console.log(a);\n\tvar a = 123;\n\t输出 undefined ； 此时 a已经被提前声明，但是为赋值，所以为undefined；\n&lt;/script>\n\n&lt;script>\n    func(); //输出 \"我是一个fun函数\" ；因为fun() 已经被完全声明， 声明fun()的所有代码已经被全部执行；\n\tfun2();  // 报错 Uncaught TypeError: fun2 is not a function\n\t//函数声明，会被提前创建\n\tfunction fun()&#123;\n\t\t\t\tconsole.log(\"我是一个fun函数\");\n\t\t\t&#125;\n\t//函数表达式，不会被提前创建\n\t\t\tvar fun2 = function()&#123;\n\t\t\t\tconsole.log(\"我是fun2函数\");\n\t\t\t&#125;;\n\n&lt;/script>\n函数的作用域\t\t\t/*\n\t\t\t * 函数作用域\t\n\t\t\t * \t- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁\n\t\t\t * \t- 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的\n\t\t\t * \t- 在函数作用域中可以访问到全局作用域的变量\n\t\t\t * \t\t在全局作用域中无法访问到函数作用域的变量\n\t\t\t * \t- 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用(如果在函数中需要使用同名的全局变量，可以使用window.变量名获取)；\n\t\t\t * \t\t如果没有则向上一级作用域中寻找，直到找到全局作用域，\n\t\t\t * \t\t如果全局作用域中依然没有找到，则会报错ReferenceError\n\t\t\t * \t- 在函数中要访问全局变量可以使用window对象\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * 在函数作用域也有声明提前的特性，\n\t\t\t * \t使用var关键字声明的变量，会在函数中所有的代码执行之前被声明\n\t\t\t * \t函数声明也会在函数中所有的代码执行之前执行（函数中的函数）\n\t\t\t */\n\n* 在函数中，不适用var声明的变量都会成为全局变量\nfunction fun5()&#123;\n\t\t\t\t//d没有使用var关键字，则会设置为全局变量\n\t\t\t\td = 100;\n\t\t\t&#125;\n\t\t\tfun5();\n\t\t\t//在全局输出c\n\t\t\tconsole.log(\"d = \"+d);\n输出 d = 100;\n\n* 定义形参就相当于在函数作用域中声明了变量\nvar e = 23;\nfunction fun6(e)&#123;\n\t\t\t\talert(e);\n\t\t\t&#125;\nfun6(); \n//输出 undefined； 定义函数时定义了形参相当于声明了函数作用域中的变量e，所以在调用函数时不会往函数外的全局作用域寻找变量e；调用时未传入参数则输出undefined；\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"流程控制语法","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/19/流程控制-循环/","content":"流程控制语句JS中代码按照从上到下的顺序执行，通过流程控制语句可以控制程序的执行流程，流程控制语句分为 ：\n​        （1）条件判断语句；\n​        （2）条件分支语句；\n​        （3）循环语句；\n条件判断语句 — if语句语法一： if(条件表达式)&#123;\n    语句；\n    ....\n&#125;\nif语句在执行时，一旦括号里的条件表达式为true时，就执行其下的代码块；\n\n语法二： if(条件表达式)&#123;\n    \t\t语句；\n    \t\t...\n\t\t&#125;else if(条件表达式)&#123;\n            语句；\n            ....\n        &#125;else&#123;\n            语句;\n            ....\n        &#125;\n  当执行该语句时，会从上依次判断if后面的条件表达式，在该语句中，只有一个代码块会执行，一旦进入某个代码块，执行完毕后将结束整个if语句，不会继续往下判断if条件表达式；当所有的if条件表达式均为false时，将进入else代码块；\n条件分支语句 — switch语句语法 ： \n\tswitch(条件表达式)&#123;\n        case 表达式1:\n            语句；\n            ...\n            break;\n        case 表达式2::\n        \t语句；\n            ...\n            break;\n            \n            ....\n            \n         default:\n            语句；\n            ...\n            break;\n    &#125;\n\n\t在执行时会依次将case后面的表达式与switch后的条件表达式进行 全等比较（===） ,只有比较结果为true时才会执行当前case后的语句；\n\t在case语句后的代码块中最后需要写入 break 关键字，否则当前case执行完以后会继续执行后面的case语句（不用判断直接执行）；\n\t若所有的case语句的表达式与switch中的条件表达式比较均为false，则执行default语句（也可以不书写default语句，此时将结束switch语句）；\n    \n    if语句和switch语句功能上两者可互相代替；\n循环语句 — while循环循环语句： 通过循环语句可以反复执行一段代码多次；\n\nwhile循环  语法：\n\twhile(条件表达式)&#123;\n          语句；\n          ...\n          &#125;\n     \n     while语句在执行时先对条件表达式进行求值判断，若条件表达式为true，则进入循环体，循环体代码块执行完毕以后再判断条件表达式是否成立，是否需要进入下一次循环；否则终止循环；\n     \n   do...while 循环 语法\n     do&#123;\n         语句；\n         ...\n     &#125;while(条件表达式)\n         \n     do...while语句在执行时会先执行循环体，循环体执行完以后在对while的条件表达式进行判断，结果为true则继续执行循环体否则结束循环；\n         \n     这两个循环语句功能类似，while语句是先判断再循环，do...while语句是先执行再判断，所以do...while语句至少执行一次；\n循环语句 — for循环for 循环 语法：\n\tfor(初始化表达式;条件表达式;更新表达式)&#123;\n        语句;\n        ...\n    &#125;\n        \n    for循环执行流程：\n    \t1.执行初始化表达式，初始化变量（初始化表达式只会执行一次）；\n        2.执行条件表达式，判断是否进入循环；\n     \t3.执行更新表达式，更像表达式执行完以后在继续执行第二步；\n        \n        for循环的三个部分都可以省略，也可以写在外部，如果在for循环中不写任何表达式只写两个 ;  此时循环会是一个死循环会一直执行下去；\n        \n for循环可以嵌套使用；\nbreak和continue\tbreak关键字可以用来退出switch或循环语句，但是不能单在if语句中只用，break关键字会立即终止离它最近的那个循环语句；\n   \t可以为循环语句创建一个label，来标识当前的循环；\n    \tlabel:循环语句\n        在使用break语句时，可以在break后跟着一个label，这样break就会结束指定的循环而不是最近的循环；\n        \n     continue关键字可以跳过本次循环，同样continue也是默认只会离它最近的循环起作用；\n     \n     outer:\n\t\t\tfor(var i=0 ; i&lt;5 ; i++)&#123;\n\t\t\t\tconsole.log(\"@外层循环\"+i)\n\t\t\t\tfor(var j=0 ; j&lt;5; j++)&#123;\n\t\t\t\t\tbreak outer; //这里的break指定了结束外部的循环体\n\t\t\t\t\tconsole.log(\"内层循环:\"+j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n输出：外层循环0\n\n\n\t\t\touter:\n\t\t\tfor(var i=0 ; i&lt;5 ; i++)&#123;\n\t\t\t\tconsole.log(\"@外层循环\"+i)\n\t\t\t\tfor(var j=0 ; j&lt;5; j++)&#123;\n\t\t\t\t\tbreak; //这里的break会结束内部的循环体\n\t\t\t\t\tconsole.log(\"内层循环:\"+j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n输出：\n @外层循环0\n @外层循环1\n @外层循环2\n @外层循环3\n @外层循环4\n\n\t\touter:\n\t\t\tfor(var i=0 ; i&lt;5 ; i++)&#123;\n\t\t\t\tconsole.log(\"@--->\"+i);\n\t\t\t\tfor(var j=0 ; j&lt;5 ; j++)&#123;\n\t\t\t\t\tif(j == 3)&#123;\n\t\t\t\t\t\tcontinue; //这里的continue会结束内部for循环的档次循环；\n\t\t\t\t\t&#125;\t\n\t\t\t\t\tconsole.log(\"-->\"+j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\touter:\n\t\t\tfor(var i=0 ; i&lt;5 ; i++)&#123;\n\t\t\t\tconsole.log(\"@--->\"+i);\n\t\t\t\tfor(var j=0 ; j&lt;5 ; j++)&#123;\n\t\t\t\t\tif(j == 3)&#123;\n\t\t\t\t\t\tcontinue outer;// 这里的continue指定结束外部for循环的当次循环；\n\t\t\t\t\t&#125;\t\n\t\t\t\t\tconsole.log(\"-->\"+j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n输出：\n04.break和continue.html:65 @--->0\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n04.break和continue.html:65 @--->1\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n04.break和continue.html:65 @--->2\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n04.break和continue.html:65 @--->3\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n04.break和continue.html:65 @--->4\n04.break和continue.html:70 -->0\n04.break和continue.html:70 -->1\n04.break和continue.html:70 -->2\n练习 \t\t\t/*\n\t\t\t * 对于成绩大于60分的，输出'合格'。低于60分的，输出'不合格'\n             */\n\t\t  var score = 61;\n            switch (true)&#123;\n                case score >= 60 :\n                    console.log(\"合格\");\n                    break;\n                default :\n                    console.log(\"不合格\");\n            &#125;\n            console.log(typeof !!score);\n            console.log(!!score);\n\n输出：\n合格\nboolean\ntrue\n\nJS的switch中表达式可以是boolean值，但是java中不可以！！！在这里若把switch的表达式的 true 改为 score 则将只能执行default，因为switch中的表达式并不会自动进行类型转换，而是将switch的表达式与case的表达式进行全等比较（===）；\n\n\n\t\t\t/*\n\t\t\t * 从键盘接收整数参数，如果该数为1-7，打印对应的星期，否则打印非法参数。\n\t\t\t */\n\n             var day =parseInt(prompt(\"请输入数字（1~7）:\"));\n             switch (day)&#123;\n                 case 1:\n                     console.log(\"今天星期一\");\n                     break;\n                case 2:\n                     console.log(\"今天星期二\");\n                     break;\n                case 3:\n                     console.log(\"今天星期三\");\n                     break;\n                case 4:\n                     console.log(\"今天星期四\");\n                     break;\n                case 5:\n                     console.log(\"今天星期五\");\n                     break;\n                case 6:\n                     console.log(\"今天星期六\");\n                     break;\n                case 7:\n                     console.log(\"今天星期天\");\n                     break;\n      使用prompt()函数获取用户输入的参数，可传入一个字符串作为输入的提示，函数的返回值为string类型；\n      \n      \n      \t\t/*\n\t\t\t * 假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年\n\t\t\t */\n\n             var money = 1000;\n             var year = 0;\n             while(money &lt; 5000)&#123;\n                money = money * 1.05;\n                year++;\n             &#125;\n             console.log(\"需要\"+year+\"年\");\n                     \n             /* \n              质数练习\n             */\n                     \n            console.time(\"clock\");\n            for(var i = 2;i &lt;= 10000 ; i++)&#123;\n                var flag = true;\n                for(var j = 2; j &lt;= Math.sqrt(i); j++)&#123;\n                    if(i % j == 0)&#123;\n                        flag = false;\n                        break;\n                    &#125;\n                &#125;\n                if(flag)&#123;\n                    console.log(i+\"是质数\");\n                &#125;\n            &#125;\n            console.timeEnd(\"clock\");\n                     \n     console.time()函数开启一个计时器，需要传入一个字符串作为计时器的名字，\n     console.timeEnd()函数结束一个计时器，需要传入需要结束计时的计时器名称，将自动在控制台输出本次计时器所经历的时间；\n     Math.sqrt()函数可以获取一个数值的平方根，需要传入需要开方的数字，返回值为number类型中的浮点数；\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"运算符","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/18/运算符/","content":"运算符通过运算符可以对一个或多个值进行运算，并获取运算结果；\n一元运算符一元 : 只需要一个操作数；\n\" + \"号，正号不会对数字（number）产生任何影响；\n\" - \"号，负号可以对数字进行算术取反；\n\t对于非Number类型的数据来说，使用一元运算符时，会将其转换成number类型 --- 原理和使用Number()一致；\n自增和自减自增 ++ ；\n\t自增分为两种，前++和后++，这两者都会使原变量的值自增1；但是 i++ 和 ++i 的值是不一样的；\n    var i = 1;\n\tconsole.log(\"i++ = \" + i++);  //输出 i++ = 1;\n\ti = 1;\n\tconsole.log(\"++i = \" + ++i);  //输出 ++i = 2；\n\t可知 i++ 等于原变量的值，但是 ++i等于原变量自增1后的值；\n    即若 a = i++ ;  //即是将 a = i ；然后 i = i + 1； 即后加加是先使用原变量的值，之后原变量的值再自增1；\n\t\ta = ++i ; //即是将 i = i + 1 ； 然后 a = i ；即前加加是先原变量的值自增1，之后再将使用自增后的值；\n\t\t理解： 后加加（i++）里变量在前，+号在后，所以先使用原变量，之后原变量再自增；\n\t\t\t\t前加加（++i）里+号在前，变量在后，所以先变量自增1，之后再使用变量；\n\n自减 -- ；\n自减也分为两种 ，前-- 和 后-- ，这两者都会是原变量的值自减1， 但是 i-- 和 --i的值是不一样的；\n\t具体使用和 ++ 一致；\n\n\n算术运算符1.加法 \"+\" ：如果对两个字符串进行加法运算，会进行字符串的拼接，任何值和字符串相加都会想转换成字符串，然后进行字符串的拼接操作；\n   \t可以用利用这一特点进行任何数据类型进行字符串的隐式转换 ---- 实际上也是调用String()函数返回；\n    \tvar a = 123;\n \t\tconsole.log(a + '');  //输出字符串的“123”\n\n2.\"-\" , \"*\" , \"/\" , 任何值 做减法 ，乘法， 除法 运算时都会自动转换成Number类型；\n   \t可以利用这点将任何数据类型进行Number的隐式转换；\n       var a = \"123\";\n\tconsole.log(a-0);  //输出number类型的 123\n\n3.模运算 \"%\" : 求余数运算；\n逻辑运算符&amp;&amp; --- 与\n\t两个值中只要有一个false时就返回false，只有两个值为true时才返回true，如果第一个值为false则直接返回false不会往下检查；\n\n|| --- 或\n\t两个值中只要有一个true时就返回true，只有两个值均为false时才返回false，如果第一个值为true时直接返回true不会继续往下检查；\n    \n! --- 非\n\t对布尔值进行取反运算；\n    \t如果对非布尔值进行取反，则会将其转换为布尔值然后再取反；\n        可以利用对非布尔值去两次反，这样就可以实现将其他任意的数据类型进行布尔值的隐式转换；\n赋值运算符可以将符号右侧的值赋给符号左侧的变量；\n关系运行符通过关系运算符可以比较两个值之间ed大小关系；\n对于非数值使用关系运算符比较的情况：会将其转换成数字然后进行比较；\n\t如果比较的两侧都是字符串的时候，不会将其转换成数字比较，而是依次比较字符串中每一个字符的Unicode编码，一个一个字符进行比较，相比较的字符编码大，则该字符串就大，不会继续往下比较，若一个字符串是另一个字符串的前缀，则字符串长度长的大；\n编码在字符串中使用转义字符输入Unicode编码 --- \\u字符编码 -- \\u2620 ;\n在网页中使用Unicode编码是使用 &amp;#字符编码 编码需要转换成10进制；\n相等运算符使用 == 运算符来比较两侧的值是否相等；\n使用 != 运算符来比较两侧的值是否不相等；\n\n== 和 != 在比较不同的类型的值时，会自动将其转换成相同类型进行转换，之后再比较；\nconsole.log( null == 0); //输出false ；\nnull 比较特殊，比较运算符  >=   &lt;=   >   &lt; 会对其进行数据类型转换； 相等运算符 == != 不会对其进行数据类型转换。\n\nundefined衍生自 null ，所以这两个值做相等判断时，返回true；\nconsole.log( undefined == null );  //返回true；\n\nNaN不和任何值相等 ， 包括它本身；\nconsole.log( NaN == NaN );   //返回 false；\n要判断 变量的值是否为 NaN，可使用 isNaN() 函数；\nconsole.log(isNaN(NaN));  //返回 true；\n\n使用 === 和 !== 来判断两侧的值是否相等，但是它不会进行类型转换，若比较的数据两者类型不同，则直接判断为不相等；\n条件运算符（三元运算符）语法：  条件表达式?语句1:语句2;\n\t先执行条件表达式，若表达式值为true，则执行语句1，否则执行语句2；\n    如果条件表达式执行后值不是布尔值，会将其转换成布尔值后再执行后面的语句；\n   var a = 1;\n\tvar b = \"hello\";\n    a > b ? alert(\"a大\") : alert(\"b大\");  //执行语句2；\n运算符的优先级\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"JS-数据类型与转换","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/16/JS-数据类型与转换/","content":"Hello WorldJavaScript中常用的信息输出方法：\n\t1. alert(\"这是一条提示语句！\");   ---- 该方法在执行时将在浏览器弹出一个提示框；\n\n\t2.console.log(\"这是一条提示语句！\");  ---- 该方法在执行时将在浏览器的控制台输出信息；\n\n\t3.document.write(\"这是一条插入body标签的信息\"); ---- 该方法在执行的时候将在网页的body标签中输出信息；\n\t\t\t该方法默认将信息插入到body标签的开头；\nJavaScript编写原则1. 内部代码 ---- JavaScript代码要求写在&lt;script>&lt;/script>标签体内；\n\n2. 外部代码 ---- 将JS代码写在其他的js文件中，之后通过&lt;script src=\"../index.js\">&lt;/script>引入外部js文件；\n\t用于引入外部js文件的script标签体内书写的代码不再进行解析；\n   \n3. 简单业务可直接写在html的标签中，但是耦合性太高，日常开发不推荐使用；--- 在按钮与超链接中的使用：\n\t\t&lt;button onclick=\"alert(\"我是点击按钮的提示信息！\")\">按钮&lt;/button>\n\t\t&lt;a href=\"javascript: alert(\"点击超链接的提示信息！\")\">我是一个超链接&lt;/a>\n\n4. JS代码中严格区分大小写；\n\n5. JS中每一条语句结束使用 ; 结尾，若未使用时浏览器在解析时会自动添加上，但这会消耗一定的浏览器性能。而且自动添加时可能会添加错地方；\n\n6. JS中会忽略多个空格和换行；\n变量与标识符字面量 --- 不可改变的值 如 1,2，3 ....  字面量是可以直接使用的，但在实际开发中我们不会直接使用字面量；\n\n变量 --- 变量可以用来保存字面量，而且变量的值是可以随便改变的，更加方便使用，可以使用变量对字面量进行描述；\n\n\t\t声明变量 --- var a;  &#x2F;&#x2F; 声明了一个名字为 a 的变量；\n\t\t变量赋值 --- a &#x3D; 123; &#x2F;&#x2F; 将变量 a 的值设置为 123 --- number类型；\n\t\t声明变量并赋值 --- var b &#x3D; 123; &#x2F;&#x2F; 声明一个变量名为 b 并直接赋值为 123 --- number类型；\n\n标识符 --- JS中所有可以自主命名的都称为标识符（为方便开发给变量取得名字）\n\t\t\t变量名 函数名 属性名 都属于标识符；\n            命名标识符是需要遵循的规则：\n            \t（1）标识符中可以含有字母，数字，_ ,$;\n\t\t\t\t(2)标识符不能以数字开头；\n                  (3)标识符不能是ES中关键字或者是保留字；\n                （4）标识符一般采用驼峰命名法 --- 首字母小写，其余单词的仅首字母大写；\n\t\tJS底层中保存标识符实际采用Unicode编码，所以理论上使用中文命名变量也是可行的，但是不推荐使用；\n基本数据类型JS中共有6中数据类型： String，Number，Boolean，Undefined， NULL，Object；\n\t其中前五种属于基本数据类型；\n    Object属于引用数据类型；\n    \n    1.String --- 字符串\n\t\t使用引号引起来的数据，可以使用单引号或者双引号，但是不能两者混合使用（一边单引号一边双引号）；\n        在字符串中使用 \\  作为转义字符\n        \t\\&#39;表示 &#39; , \\&quot; 表示 &quot; , \\n 表示换行， \\t 制表符(Tab缩进) \n     \n    2.Number --- 数值（整数，浮点数）\n\t\tNumber.MAX_VALUE --- 表示Number类型能表示ed最大值；\n\t\tNumber.MIN_VALUE --- 表示Number能表示的大于0的最小正数\n\t\tInfinity --- 表示正无穷；\n\t\t-Infinity --- 表示负无穷；\n\t\tNaN --- 一个特殊的数值 ---Not a Number\n        \n可以使用 运算符 typeof 来检查变量的数据类型 ---- typeof NaN 返回 number；\n\t若使用两个字符串进行相乘时，返回的是一个NaN\n    \t如：var a &#x3D; &quot;abc&quot; * &quot;def&quot;  -- 此时 console.log(a) 控制台打印NaN\n        \n        JS中整数的运算基本可以保证精确度（不溢出的话），但是浮点数的计算不能保证很高的精确度（因为所有的数值在计算中计算时都会转换成二进制进行计算，但是有些小数使用二进制是永远不能精确表示的 例如 0.1 就不能使用二进制精确表示）\n\n      3.Boolean --- 布尔值\n\t\t\t布尔值只有 true 和false 两个值，true -- 真，false -- 假\n        \n       4.NULL --- 空值\n\t\t\tNULL类型只有一个值 --- null --- 表示一个空的对象\n\t\t\t使用 typeof null --- 返回 object 原因如下：\n    1995年JavaScript语言的第一版，所有值都设计成32位，其中最低的3位用来表述数据类型，object对应的值是000。当时，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值）,完全没考虑null，只把它当作object的一种特殊值，32位全部为0。 这是typeof null返回object的根本原因。\n               \n       5.Undefined -- 未定义\n       \t\t该类型只有一个 --- undefined ；\n            使用 typeod undefined -- 返回undefined\n强制类型转换强制类型转换 --- 指将一个数据类型强制转换为其他的数据类型，这里主要讲String，Number，Boolean三种基本数据类型的转换；\n转换成String类型方法一：调用基本数据类型的toString()方法，该方法将返回一个string类型的结果，不影响原变量；\n\tNumber类型：  var a &#x3D; 123;\n\t\t\t\tvar b &#x3D; a.toString();\n\t\t\t\tconsole.log(b);\n\t\t\t\tconsole.log(typeof b);\n\t\t\t控制台输出字符串 &quot;123&quot; 类型为string；\n            \n     Boolean类型： var a &#x3D; true;\n\t\t\t\tvar b &#x3D; a.toString();\n\t\t\t\tconsole.log(b);\n\t\t\t\tconsole.log(typeof b);\n\t\t\t控制台输出字符串 &quot;true&quot; 类型为string；\n            \n      null和undefined这两个基本数据类型身上没有 toString() 方法，调用将导致报错；\n      \n方法二：调用String() 方法，并将需要转换的的数据作为参数传入；\n\t\tString()传入Number，Boolean这两个基本数据类型是，其实就是调用这两者身上的toString()方法；\n        \n        String()传入null和undefined时，直接返回字符串 &quot;null&quot; &quot;undefined&quot;\n\t\t\tvar a &#x3D; null;\n\t\t\tvar b &#x3D; String(a);\n\t\t\tconsole.log(b);\n\t\t\tconsole.log(typeof b);\n\t\t控制台输出 字符串 :&quot;null&quot; 和 string\n转换成Number类型方法一：使用Number函数 --- 将要转换的数据传入\n\t\tString类型： 如果是纯数字的字符串，则转换结果是数字\n        \t\t\t如果字符串中包含其他非数字内容，转换结果是NaN\n                    如果字符串是一个空串或者是全是空格的字符串，转换结果是 0 \n\t\tvar a &#x3D; &quot;123&quot;;\n\t\ta &#x3D; Number(a);\n\t\tconsole.log(a);\n\t\tconsole.log(typeof a);\n\t控制台输出 数值 123, 为number类型；\n\n\t\tvar a &#x3D; &quot;123sddfe&quot;;\n        a &#x3D; Number(a);\n\t\tconsole.log(a);\n\t\tconsole.log(typeof a);\n\t控制台输出 NaN ，为number类型；\n    \n    \tvar a &#x3D; &#39;&#39;;\n\t\ta &#x3D; Number(a);\n\t\tconsole.log(a);\n\t\tconsole.log(typeod a);\n\t控制台输出 数值 0，为number类型；\n    \n方法二：parseInt() --- 把一个字符串转换为一个整数；\n\t\tparseFloat() --- 把一个字符串转换为一个浮点数；\n\n\t\tparseInt() ,parseFloat() 方法均是在遇到字母时停止转换，返回一个NaN值\n        \n        var a &#x3D; &quot;123dfhgdsh&quot;;\n\t\ta &#x3D; parseInt(a);\n\t\tconsole.log(a);\n\t控制台输出 数值 123；\n    \t\n    \tvar a &#x3D; &quot;d2323bsdhfgb&quot;\n        a &#x3D; parseInt(a);\n\t\tconsole.log(a);\n\t控制台输出 NaN --parseInt()在执行时依次解析每一个字符，一旦遇到非数字以外的字符将停止继续解析，解析后若没有数值将返回NaN值；\n    \n    parseFloat() --- 解析时遇到第一次小数点时不会停止解析，若遇到数数字和小数点外的字符则停止解析，或者是第二次遇到小数点就停止解析，若解析后没有数值则返回NaN；\n\n\t\tvar a &#x3D;&quot;.41564efdwe&quot;\n        a &#x3D; parseFloat(a);\n\t\tconsole.log(a);\n\t控制台输出浮点数 0.41564；\n    \n    \tvar a &#x3D; &quot;..4234sfdf32423&quot;\n        a &#x3D; parseFloat(a);\n\t\tconsole.log(a);\n\t控制点输出 NaN ；\n    \n    \n    如果parseInt()和parseFloat()中穿入的是非字符串是，它会将传入的参数先转换成字符串之后转进行转换成number类型；\n\t\t\n转换成Boolean类型使用Boolean()方法将其他的数据类型转换成Boolean类型；\n\t\t数字 ---&gt; Boolean  ， 除了 0 和 NaN ，其他数据都是转换成true；\n        字符串 ---&gt; Boolean ， 除了 空串，其他的字符串都是转换成true；\n        null 和 undefined 都会转换成 false；\n        object 数据类型也会转换成true；\n其他进制的数字在js中，16进制数字需要以0x开头，8进制数字以0开头，2进制数字需要以0b开头；\n​        可以在parseInt()中传递第二个参数，用来指定数字的进制\n​        var a = parseInt(0xff,16);\n","categories":["JavaScript基础"],"tags":["WEB前端"]},{"title":"媒体查询","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/15/媒体查询/","content":"响应式布局响应式布局 --- 网页根据浏览设备会窗口的大小呈现出不同的效果\n\t\t使用响应式布局是一个页面适用于所有设备\n\t\t通过媒体查询 -- 可以为不同的设备，或者设备的不同状态来分别设置样式\n媒体查询语法： @media 查询规则&#123;&#125;\n\t\t媒体类型：all -- 所有设备\n\t\t\t\tprint -- 打印设备（只有页面在打印时样式才呈现出来）\n\t\t\t\tscreen -- 带屏幕的设备\n\t\t\t\tspeech -- 屏幕阅读器\n\t\t可以使用 , 连接多个媒体类型 表示一个 或 的关系\n\t也可以在媒体类型前添加一个 only 表示只有 （为了兼容一些老版本浏览器）\n\n\t\t媒体特性：width -- 视口宽度\n\t\t\t\theight -- 视口高度\n\t\t\t\tmin-width -- 视口的最小宽度（当视口的宽度大于这个宽度时生效）\n\t\t\t\tmax-width -- 视口的最大宽度（当视口的宽度小于这个宽度时生效）\n\n\t\t断点 --- 样式切换到额分界点 --- 网页样式发生变化的点\n\t\t常用断点：\n\t\t\t\t小于768 -- 超小屏幕 -- max-width = 768px\n\t\t\t\t大于768 -- 小屏幕 -- min-width = 768px\n\t\t\t\t大于992 -- 中型屏幕 -- min-width = 992px\n\t\t\t\t大于1200 -- 大屏幕 -- min-width = 1200px\n\n&lt;style>\n @media only screen and (min-width: 500px) and (max-width:700px)&#123;\n     /*\n     \t当视口的宽度大于500px且视口的宽度小于700px时 body的样式如下：\n     */\n             body&#123;\n                background-color: #bfa;\n             &#125;\n         &#125;\n  &lt;/style>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"像素-视口-移动端","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/14/移动端/","content":"像素前端开发中像素分成两种，CSS像素和物理像素；\n\n\t物理像素 --- 屏幕中一个个的发光小点，分辨率就是指横向和纵向上屏幕的发光小点个数；\n\n\tCSS像素 --- 在编写网页时，我们使用的就是CSS像素，浏览器在解析网页时需要把CSS像素转换成物理像素来显示；\n\t\t一个CSS像素最终由几个物理像素显示由浏览器决定：\n\t\t\t默认情况下PC端网页的一个CSS像素等于一个物理像素；\n视口（viewport）视口 --- 屏幕中用来显示网页的区域\n\t\t可以通过查看视口的大小来确定CSS像素和物理像素的比值；\n\n\t默认情况下，在不同的屏幕中，单位像素是不同的，像素越小屏幕会越清晰；\n移动端移动端默认的视口大小是980px（CSS像素），默认情况是移动端的像素比是 980/（移动设备宽度）\n\t在编写移动页面时，要确保有一个比较合理的像素比：\n\t\t设备像素比：一个设备的物理像素与逻辑像素之比\n\t\t2个物理像素 ：1css像素 或者  3个物理像素 ：1css像素 \n\n可以通过设置meta标签来设置视口大小，每一款移动设备在设计时都会有一个最佳的像素比 ---- 完美视口\n\n将网页的视口设置为完美视口，写入如下代码：\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\twidth：该属性被用来控制视窗的宽度，可以将width设置为320这样确切的像素数，也可以设为device-width这样的关键字，表示设备的实际宽度，一般为了自适应布局，普遍的做法是将width设置为device-width。\n\n\theight：该属性被用来控制视窗的高度，可以将height设置为640这样确切的像素数，也可以设为device-height这样的关键字，表示设备的实际高度，一般不会设置视窗的高度，这样内容超出的话采用滚动方式浏览。\n\n\tinitial-scale：该属性用于指定页面的初始缩放比例，可以配置0.0～10的数字，initial-scale=1表示不进行缩放，视窗刚好等于理想视窗，当大于1时表示将视窗进行放大，小于1时表示缩小。这里只表示初始视窗缩放值，用户也可以自己进行缩放，例如双指拖动手势缩放或者双击手势放大。\n\n\tmaximum-scale：该属性表示用户能够手动放大的最大比例，可以配置0.0～10的数字。\n\n\tminimum-scale：该属性类似maximum-scale，用来指定页面缩小的最小比例。通常情况下，不会定义该属性的值，页面太小将难以浏览。\n\n\tuser-scalable：该属性表示是否允许用户手动进行缩放，可配置no或者yes。当配置成no时，用户将不能通过手势操作的方式对页面进行缩放。\nvw适配不同设备的完美视口大小不一样，不同设备视口和像素比不同，所以同样的375个像素在不同设备下意义不同；\n\n所以在移动端开发时，不能再使用px来进行布局；\n\n移动端开发使用 vw -- 视口宽度（viewport width）来进行布局；\n\t100vw = 一个视口的宽度\n\t1 vw = 1% 视口宽度\n\tvw 永远相对于视口宽度进行计算\n\n设计图的宽度一般都为 750px 或者 1125px （因为早期iPhone6的宽度为375px，所以一般会让CSS像素是设备像素的2到3倍）\n\n现在大部分移动web页面采用更加完善的rem或者vw加flex的方案来进行适配。\n\n\tRem适配方案是当下流行并且兼容性最好的移动端适配解决方案，它支持大部分的移动端系统和机型，Rem实际上是一个字体单位，即rem（font size of the root element）是指相对于根元素的字体大小的单位，简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 所以Rem适配方案的适配原理就是：将我们之前写px的单位换成rem单位，然后根据屏幕大小动态设置根元素&lt;html>的font-size大小，那么只要跟元素的font-size改变，对应的元素的大小就会改变，从而达到在不同屏幕下的适配的目的。\n    \n           html&#123;\n            /* \n                网页中字体大小最小是12px，不能设置一个比12像素还小的字体\n                    如果我们设置了一个小于12px的字体，则字体自动设置为12px\n\t\t\t\t\n        \t\t这里以设计图宽度为750px为例，则此时有100vw = 750px；\n        \t\t换算：\n                0.1333333vw = 1px\n\n                5.3333vw = 40px  将根元素里的rem增大40倍\n      \n            */\n            font-size: 5.3333vw;\n        \t这里设置根元素的字体大小为 5.3333vw ，也就是 40px ；后续布局中使用的1rem也就等于40px；\n        \t所以后续使用rem布局时，元素的宽度需要除于40 才能得到正确的布局比例vw --- 1rem/40 = 1px；\n        &#125;\n\n        \n参考文章：https://zhuanlan.zhihu.com/p/114562780\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"flex布局","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/14/flex布局/","content":"弹性盒&lt;html>\n&lt;style>\n/*\nFlex --- 弹性盒、伸缩盒\n\t\t- CSS中的一种布局手段 用来代替浮动来完成页面布局\n\t\t- flex 可以使元素具有弹性，让元素可以跟随页面的大小的改变而改变\n\t\t- 弹性容器\n\t\t\t- 要使用弹性盒，必须先将一个元素设置为弹性容器\n\t\t\t- 通过 display ： flex 设置块级弹性容器\n\t\t\t- display：inline-flex 设置为行内的弹性容器\n\t\t- 弹性元素\n\t\t\t- 弹性容器的子元素是弹性元素（弹性项）\n\t\t\t- 弹性元素可以同时是弹性容器\n    &lt;/style>\n    &lt;/html>\n弹性容器的属性&lt;htmL>\n    &lt;style>\n        \n  flex-direction 指定容器中弹性元素的排列方式\n                可选值：\n                    row 默认值，弹性元素在容器中水平排列（左向右）\n                        - 主轴 自左向右\n                    row-reverse 弹性元素在容器中反向水平排列（右向左）\n                        - 主轴 自右向左\n                    column 弹性元素纵向排列（自上向下）\n                    column-reverse 弹性元素方向纵向排列（自下向上）\n\n主轴：弹性元素的排列方向称为主轴\n侧轴：与主轴垂直方向的称为侧轴\n        \n        flex-wrap: \n                设置弹性元素是否在弹性容器中自动换行\n                可选值：\n                    nowrap 默认值，元素不会自动换行\n                    wrap 元素沿着辅轴方向自动换行\n                    wrap-reverse 元素沿着辅轴反方向换行\n     /* flex-flow:  wrap 和 direction 的简写属性 */\n            /* flex-flow: row wrap; */\n    \n    justify-content\n                    - 设置浏览器如何沿着主轴上的弹性元素之间和周围分配空间\n                    - 可选值：\n                        flex-start 元素沿着主轴起边排列\n                        flex-end 元素沿着主轴终边排列\n                        center 元素居中排列\n                        space-around 空白分布到元素两侧\n                        space-between 空白均匀分布到元素间\n                        space-evenly 空白分布到元素的单侧\n    \n    \n/* Positional alignment */\njustify-content: center;     /* 居中排列 */\njustify-content: start;      /* Pack items from the start */\njustify-content: end;        /* Pack items from the end */\njustify-content: flex-start; /* 从行首起始位置开始排列 */\njustify-content: flex-end;   /* 从行尾位置开始排列 */\njustify-content: left;       /* Pack items from the left */\njustify-content: right;      /* Pack items from the right */\n\n/* Baseline alignment */\njustify-content: baseline;\njustify-content: first baseline;\njustify-content: last baseline;\n\n/* Distributed alignment */\njustify-content: space-between;  /* 均匀排列每个元素\n                                   首个元素放置于起点，末尾元素放置于终点 */\njustify-content: space-around;  /* 均匀排列每个元素\n                                   每个元素周围分配相同的空间 */\njustify-content: space-evenly;  /* 均匀排列每个元素\n                                   每个元素之间的间隔相等 */\njustify-content: stretch;       /* 均匀排列每个元素\n                                   'auto'-sized 的元素会被拉伸以适应容器的大小 */\n\n/* Overflow alignment */\njustify-content: safe center;\njustify-content: unsafe center;\n\n/* Global values */\njustify-content: inherit;\njustify-content: initial;\njustify-content: unset;\n        \n    ul&#123;\n            width: 800px;\n            height: 200px;\n            border: 10px solid red;\n            display: flex;\n            text-align: center;\n            flex-wrap: nowrap;\n            /* 2.设置弹性元素不在弹性容器中自动换行 \n            当弹性容器的宽度不足时且弹性元素的伸缩系数均设置为0时\n                此时弹性元素的宽度会溢出弹性容器\n            */\n            flex-wrap: wrap;\n            /* 3.设置弹性容器的中弹性元素自动换行 弹性容器的宽度不足时\n                弹性元素会在弹性容器中换行 沿辅轴方向（此时主轴方向为水平自左向右 则辅轴方向为自上向下）\n            */\n            flex-wrap: wrap-reverse;\n            /* 4.设置弹性容器的中的弹性元素沿辅轴反方向自动换行 （自下向上）*/\n            justify-content: flex-start;\n            /* 5.设置弹性容器分配主轴上的空白空间 --- flex-start 弹性元素沿主轴起边排列 */\n            justify-content: flex-end;\n            /* 6.弹性元素沿主轴的终边摆列 -- 只影响有空白空间的元素 不影响已沾满一行的弹性元素 */\n            justify-content: center;\n            /* 弹性元素在空白中居中排列 */\n            justify-content: space-around;\n            /* 空白分布到弹性元素的两侧 两弹性元素间的间隔和弹性元素距离边框的距离不一定相等*/\n            justify-content: space-between;\n            /* 空白均匀分布到弹性元素的间隔中 弹性元素与边框间不分布空白*/\n            justify-content: space-evenly;\n            /* 空白均匀分到弹性元素间的两侧 弹性元素间和弹性元素到边框的距离相等 */\n        &#125;\n        ul li:nth-child(odd)&#123;\n            background-color: #bfa;\n            width: 300px;\n            height: 50px;\n        &#125;\n        ul li:nth-child(even)&#123;\n            background-color: skyblue;\n            flex-shrink: 0;\n             /* 1.此时增大奇数项的宽度 且让其的收缩系数变为0 即不让其缩小 */   \n            height: 50px;\n            width: 200px;\n        &#125;\n        \n        \n       align-content : 设置了浏览器如何沿着弹性布局的辅轴在内容项之间和周围分配空间。\n\t\t\n/* 基本位置对齐 */\n/*align-content不采用左右值 */\nalign-content: center;     /* 将项目放置在中点 */\nalign-content: start;      /* 最先放置项目 */\nalign-content: end;        /* 最后放置项目 */\nalign-content: flex-start; /* 从起始点开始放置flex元素 */\nalign-content: flex-end;   /* 从终止点开始放置flex元素 */\n\n/* 默认对齐 */\nalign-content: normal;\n\n/*基线对齐*/\nalign-content: baseline;\nalign-content: first baseline;\nalign-content: last baseline;\n\n/* 分布式对齐 */\nalign-content: space-between; /* 均匀分布项目\n                                 第一项与起始点齐平，\n                                 最后一项与终止点齐平 */\nalign-content: space-around;  /* 均匀分布项目\n                                 项目在两端有一半大小的空间*/\nalign-content: space-evenly;  /* 均匀分布项目\n                                 项目周围有相等的空间 */\nalign-content: stretch;       /* 均匀分布项目\n                                 拉伸‘自动’-大小的项目以充满容器 */\n\n/* 溢出对齐 */\nalign-content: safe center;\nalign-content: unsafe center;\n\n/* 全局属性 */\nalign-content: inherit; /* 继承 */\nalign-content: initial;  /* 初始值 */\nalign-content: unset; /* 未设置 */\n\n    &lt;/style>\n&lt;/htmL>\n弹性元素的属性&lt;html>\n    &lt;style>\n    弹性元素的属性：\n                    flex-grow 指定弹性元素的伸展的系数 默认值为0\n                    - 当父元素有多余空间的时，子元素如何伸展\n                    - 父元素的剩余空间，会按照比例进行分配\n                    flex-shrink 指定弹性元素的收缩系数 默认值为1\n                    - 当父元素中的空间不足以容纳所有的子元素时，如果对子元素进行收缩\n    \n     ul&#123;\n            width: 600px;\n            height: 100px;\n            border: 10px red solid;\n            text-align: center;\n            /* 此时ul的高度由内容撑开 */\n            /* 1.给元素开启fles布局 */\n            display: flex;\n            /* 2.ul一开启弹性布局 它里面的子元素都变成弹性元素 此时li在ul里横向排列 */\n            flex-direction: row;\n            /* 3.设置弹性元素的排列方式 flex-direction : row ---默认值 横向排列；自左向右 */\n            flex-direction: column;\n            /* 4.将弹性元素的排列方式改为纵向排列 自上向下 */\n            flex-direction: row-reverse;\n            /* 5.将弹性元素的排列方式改为反向的横向排列 此时主轴方向为水平自右向左 */\n            flex-direction: column-reverse;\n            /* 6.将弹性元素的排列方式改为反向的纵向排列 此时主轴方向为垂直自下向上 */\n            flex-direction: row;\n        &#125;\n        ul li:nth-child(odd)&#123;\n            background-color: #bfa;\n            width: 200px;\n            flex-grow: 1;\n            /* 7.设置奇数项的li的弹性伸展系数 -- 此时若将ul的高度变高 \n                父元素高度变高后 多出来的空白区域将均分成2份 有第1个和第3个li伸展\n            */\n            /* 9.将父元素的宽度调小后 子元素的宽度将自动调整\n                父元素的不够的宽度将由里面的所有子元素共同承担 -- 即若父元素宽度变小200px 则此时父元素里的4个子元素各自减少50px\n                (前提是每个子元素都没有单独设置收缩系数 flex-shrink)\n            */\n            flex-shrink: 2;\n            /* 10.给奇数项设置弹性系数为2 则此时200px均分成6份 奇数项li缩小 200px*(1/3) = 133.33px */\n        &#125;\n        ul li:nth-child(even)&#123;\n            background-color: skyblue;\n            width: 200px;\n            /* 此时元素在ul中纵向排列 */\n            flex-grow: 2;\n            /* 8.此时将偶数项的li弹性伸展系数设置为2 则之前的空白将均分成6份 此时偶数项li各占2份，奇数项li各占1份 */\n            /* flex-shrink: 1; */\n        &#125;\n        \n        align-items: \n                - 元素在辅轴上如何对齐\n                - 元素间的关系\n                    - 可选值：\n                        stretch 默认值，将元素的长度设置为相同的值\n                        flex-start 元素不会拉伸，沿着辅轴起边对齐\n                        flex-end 沿着辅轴的终边对齐\n                        center 居中对齐\n                        baseline 基线对齐\n        \n        \n/* Basic keywords */\nalign-items: normal;\nalign-items: stretch;\n\n/* Positional alignment */\nalign-items: center; /* Pack items around the center */\nalign-items: start; /* Pack items from the start */\nalign-items: end; /* Pack items from the end */\nalign-items: flex-start; /* Pack flex items from the start */\nalign-items: flex-end; /* Pack flex items from the end */\nalign-items: self-start;\nalign-items: self-end;\n\n/* Baseline alignment */\nalign-items: baseline;\nalign-items: first baseline;\nalign-items: last baseline; /* Overflow alignment (for positional alignment only) */\nalign-items: safe center;\nalign-items: unsafe center;\n\n/* Global values */\nalign-items: inherit;\nalign-items: initial;\nalign-items: unset;\n        \n        ul&#123;\n            width: 600px;\n            height: 900px;\n            border: 10px red solid;\n            display: flex;\n            /* 设置ul开启弹性布局 */\n            flex-flow: row wrap;\n            /* 设置ul开启横向排列 且自动换行 （自动换行要生效需要把li的收缩属性关闭） */\n            align-items: stretch;\n            /* 设置弹性元素在辅轴上的长度相同 --- 指在同一主轴上的元素 其高度一致 默认值*/\n            align-items: flex-start;\n            /* 设置弹性元素不会拉伸 高度由其自身决定 弹性元素对着辅轴起边对齐 */\n            align-items: flex-end;\n             /* 设置弹性元素不会拉伸 高度由其自身决定 弹性元素对着辅轴终边对齐 */\n             align-items: center;\n              /* 设置弹性元素不会拉伸 高度由其自身决定 弹性元素对着辅轴居中对齐 */\n              align-items: baseline;\n        &#125;\n\n        li&#123;\n            width: 200px;\n            background-color: #bfa;\n            font-size: 50px;\n            text-align: center;\n            line-height: 100px;\n            flex-shrink: 0;            \n        &#125;\n        li:nth-child(1)&#123;\n            /* align-self: 用来覆盖当前弹性元素上的align-items */\n            /* align-self: stretch; */\n        &#125;\n\n        li:nth-child(2)&#123;\n            background-color: pink;\n        &#125;\n\n        li:nth-child(3)&#123;\n            background-color: orange;\n        &#125;\n\n        li:nth-child(4)&#123;\n            background-color: yellow;\n        &#125;\n\n        li:nth-child(5)&#123;\n            background-color: chocolate;\n        &#125;\n        \n        \n        元素基础长度\n\n                flex-basis 指定的是元素在主轴上的基础长度\n                    如果主轴是 横向的 则 该值指定的就是元素的宽度\n                    如果主轴是 纵向的 则 该值指定的是就是元素的高度\n                    - 默认值是 auto，表示参考元素自身的高度或宽度\n                    - 如果传递了一个具体的数值，则以该值为准\n        \n        \n         ul&#123;\n            width: 900px;\n            border: 10px red solid;\n            /* 设置弹性盒 */\n            display: flex;\n            flex-direction: column;\n        \n        &#125;\n\n        li&#123;\n            width: 200px;\n            height: 100px;\n            background-color: #bfa;\n            font-size: 50px;\n            text-align: center;\n            line-height: 100px;\n            /* flex: initial; */\n            flex-basis: 300px;\n        &#125;\n        li:nth-child(1)&#123;\n            /* order 决定弹性元素的排列顺序 */\n            order: 2;\n        &#125;\n\n        li:nth-child(2)&#123;\n            background-color: pink;\n            /* flex-grow: 2; */\n            order: 3;\n        &#125;\n\n        li:nth-child(3)&#123;\n            background-color: orange;\n            /* flex-grow: 3; */\n            order: 1;\n        &#125;\n    &lt;/style>\n&lt;/html>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"less基础语法","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/13/less基础语法/","content":"less介绍/*\n\tless 是一门 css的预处理语言\n\t\t可以看成是css的增强版 用法基本和css一致 在此基础上扩展了一些功能\n\t\t浏览器并不能直接解析less语法 需要使用插件将写好的less文件转换为css文件\n*/\nCSS原生变量与计算函数&lt;style>\n\t html&#123;\n            /* css原生也支持变量的设置 */\n            /* 设置颜色变量和长度变量 \n                语法 --变量名 在使用时需要使用var(--变量名)读取\n            */\n            --color:#ff0;\n            --length:200px;\n        &#125;\n\n        .box1&#123;\n            /* calc()计算函数 --- calculation\n            \t在函数中可以直接输入计算表达式\n            直接输入表达式时 符号与数值之间使用空格间隔开\n            */\n            width: calc(200px*2);\n            height: var(--length);\n            background-color: var(--color);\n        &#125;\n\n        .box2&#123;\n            width: var(--length);\n            height: var(--length);\n            color: var(--color);\n        &#125;\n\n        .box3&#123;\n            width: var(--length);\n            height: var(--length);\n            border: 10px solid var(--color);\n        &#125;\n&lt;/style>\nless基本语法在less文件中可以使用 @import \"XXX.less\" 来引入其他的less文件\n\t在less中所有的数值都可以直接进行计算 + - * /\n    \t在使用除法时 需要使用()将除法的运算表达式包括起来\n 在less 文件中 可使用 // 符号进行行注释 也可以使用 /* */ 符号进行块注释\n    但是使用 // 符号的单行注释不会被解析到 css 文件中，但是 块注释符号会被解析到 css 文件中\n \n    在less文件中父子元素的样式可以直接嵌套写在一起\n    \n    .box1&#123;\n    background-color: #bfa;\n\n    .box2&#123;\n        background-color: #ff0;\n\n        .box4&#123;\n            color: red;\n        &#125;\n    &#125;\n\n    .box3&#123;\n        background-color: orange;\n    &#125;\n        \n        // 这段代码解析成css文件时，可知box1有3个孩子 box2 box3 ，而box2 也有一个孩子 box4 ；\n&#125;\n\nless中的变量 --- 在变量中可以存储一个任意的值；\n\t并且可以在需要的时候任意修改其中的值；\n\t语法： @变量名\n// 定义一个变量名为 a ,值为 200px 的变量；\n\t@a:200px;\n几乎所有数值都可以使用变量表示，类名也可以使用变量来表示：\n// 定义一个类变量，要表示的类名为 box\n\t@c: box;\n\n读取变量值：\n\t当直接使用则以 @变量名 的形式使用即可 --- width : @a;\n当变量作为类名使用时或者变量的值只是作为一部分使用时必须以 @&#123;变量名&#125; 的形式使用\n.@&#123;c&#125;&#123;\n    width: @a;\n&#125;\n\n当变量发生重名时，优先使用比较近的重名变量；\n\n可以先使用变量再定义变量，但不推荐这样使用；\n\nless 4.0 新语法：变量引用\n.widget &#123;\n  color: #efefef;\n  background-color: $color;\n&#125;\n编译成CSS文件后：\n.widget &#123;\n  color: #efefef;\n  background-color: #efefef;\n    //在这里使用 $color 引用之前定义的color的值；\n&#125;\n\n父元素选择器：使用 &amp; 符号选择当前元素的父元素；\n.demo&#123;\n    width: 200px;\n    height: 200px;\n\n    .demo1&#123;\n        width: 100px;\n        height: 100px;\n        background-color: #bfa;\n        &amp;:hover&#123;\n            height: 300px;\n            // 此时 &amp; 在类demo1中 所以使用 &amp; 父元素选择器选中的是类demo1\n        &#125;\n    &#125;\n\n    &amp;:hover&#123;\n        width: 300px;\n        //在这里使用 &amp; ，此时 &amp; 是demo类的直系儿子 所以此时 &amp; 选中的是 demo类\n    &#125;\n&#125;\n// 可知 &amp; 选中的是使用该符号虽在层的父元素 ， 而不是祖先元素；\n\n:extend() 对当前选择器扩展指定选择器的样式 --- 样式扩展\n\n.p1&#123;\n    width: 200px;\n    height: 200px;\n&#125;\n.p2:extend(.p1)&#123;\n    color:red;\n&#125;\n\n编译后的css代码：\n.p2:&#123;\n    width:200px;\n    height:200px;\n    color:red;\n    // 也就是说使用:extend(要扩展的类) --- 效果是在选中的需要的扩展类基础上进行样式的添加，可以看成是类p2在继承类p1的基础上添加新的样式；\n&#125;\n\n.p3&#123;\n    .p1();\n    color:red;\n    //这里是直接对指定的样式进行引用，这里就相当于将类p1的样式在这里进行了复制\n    // 此时类p3 的样式和类p2 一致\n&#125;\n\n\nmixin混合：在使用类选择器的使用在类名后面添加一个()，此时我们就相当于添加了一个mixin混合\n\tmixin混合类在解析时不会被单独解析成一个类，而是在引用该mixin混合类的类类上直接添加mixin类的属性；\n\n.p4()&#123;\n    width: 100px;\n    height: 100px;\n&#125;\n\n.p5&#123;\n    .p4;\n    //这里的引用p4类可以添加括号也可以不添加；效果一致\n&#125;\n\n编译成CSS代码后：\ncss文件中不会单独存在p4类\n.p5 &#123;\n  width: 100px;\n  height: 100px\n&#125;\n\n带参数的混合函数：\n.test(@W:100px,@h:200px,@bg-color:red)&#123;\n    width:@w;\n    height:@h;\n    border:1px solid @bg-color;\n    //此时设置了一个可以传入三个参数的test混合类，传入参数时未声明时需要按照顺序传入参数\n    //若未传入参数则使用默认值；\n    //注意该混合类在解析成css时也不会单独存在；\n&#125;\n.p6&#123;\n    .test(200px,300px,#bfa);\n    //此时p6类引用test混合类，并依次传入三个参数 三个值将依次对应width height color；\n    .test(300px)\n    //此时只传入一个参数 对应width 其他两个参数使用默认值；\n    .test(@bg-color:red,@h:100px,@w:200px);\n    //此时指定混合函数传入的三个参数，依次对应color，height，width 此时不用按照顺序传入参数也可；\n&#125;\n\naverage() ---- 颜色平均函数 该函数用来求输入的两个颜色数值的平均数\nspan&#123;\n    color: average(red,blue);\n&#125;\n编译成CSS代码后\nspan &#123;\n  color: #800080\n&#125;\n\ndarken() ---- 颜色深度改变函数 该函数用改变输入颜色的深浅\nbody:hover&#123;\n    background-color: darken(#bfa,50%);\n&#125;\n编译成CSS代码后\nbody:hover &#123;\n  background-color: #2a0\n&#125;","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"平移-旋转-缩放","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/12/平移-旋转-缩放/","content":"元素的变形包括平移，旋转，缩放；\n平移通过开启 transform 属性中的 translateX(),translateY(),translateZ() 开启元素的平移效果；\n\ttranslateX() --- 开启元素的水平平移；\n\ttranslateY() --- 开启元素的垂直平移；\n\ttranslateZ() --- 开启元素的视距方向的平移（需要设置网页视距 perspective）\n\t\n  .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 开启元素的水平平移 */\n            transform: translateX(50%) translateY(50%);\n            /* 可知元素的平移是以自身的大小为标准计算，按照当前元素在文档流中的位置进行平移，而且平移的元素不脱离文档流\n                也不影响其他元素 可以看成是提高了层级\n                元素若还有其他的平移 直接写在同一个transform 里面 使用空格将每一个平移计算隔开\n            */\n        &#125;\n\n     width: 300px;\n            height: 300px;\n            background-color: #bfa;\n            margin: 50px auto;\n            /* 开启元素的Z轴平移 */\n            transform: translateZ(200px);\n            /* 在html设置网页视距perspective无效 \n                需要在body标签设置perspective\n                perspective一般在800px 到 1200px间\n            */\n        &#125;\n旋转通过开启 transition 的rotateX() rotateY() rotateZ() 实现元素的 旋转效果；\n\trotateX() --- 水平旋转 （想象成网页平面上的元素围绕着水平线旋转 是空间上的旋转 body标签开启perspective属性后 立体效果比较明显）\n\trotateY() --- 垂直旋转 （想象成网页平面上的元素围绕着竖直线旋转）\n\trotateZ() --- 围绕Z轴旋转（因为Z轴是指向我们的脸，所以此时网页平面上的元素旋转为在网页上的平面旋转 相当于俯视视角 此时无立体效果）\n\n.demo&#123;\n            width: 320px;\n            height: 320px;\n            margin: 200px auto;\n            transition:  all 5s;\n        &#125;\n        .demo img&#123;\n            width: 320px;\n            height: 320px;\n        &#125;\n body:hover .demo&#123;\n\n            /*\n                通过旋转可以使元素沿着x y 或 z旋转指定的角度\n                    rotateX()\n                    rotateY()\n                    rotateZ()\n            */\n            /* transform: rotateZ(.25turn); */\n            /* transform: rotateY(180deg) translateZ(400px); */\n            /* transform: translateZ(400px) rotateY(180deg) ; */\n            transform: rotateX(1turn);\n            /* 是否显示元素的背面 */\n            /* backface-visibility: hidden; */\n        &#125;\n缩放通过开启 transition 中的 scaleX() scaleY() scale() 开启元素的缩放\n\tscaleX() --- 水平方向上的缩放；\n\tscaleY() --- 垂直方向上的缩放；\n\tscale() --- 双方向上的缩放；\n\n .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            display: inline-block;\n            /* margin: 20px auto; */\n        &#125;\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            display: inline-block;\n        &#125;\n        .demo:hover&#123;\n            transform: scaleX(120%);\n            /* 设置元素垂直方向上放大为自己的20% \n                可知此时元素的缩放不影响别的元素 也不脱离文档流\n            \t即此时的元素缩放不影响其他元素的所在文档流的位置\n            */\n        &#125;\n\n&lt;div class=\"demo\">&lt;/div>\n&lt;div class=\"demo1\">&lt;/div>\n\n transform-style: preserve-3d;\n            /* 只有开启transform-style 才能看出3D立体效果 */\n\n注意：在测试时发现 translateZ() 也就是在视距方向上平移时 值为%表示不生效；","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"过渡与动画","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/11/动画/","content":"过渡通过过渡指定一个属性发生变化时的切换方式；\n\ntransition-property : 属性指定要执行的过渡属性（大部分属性都支持过渡效果，注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡，若属性值是 auto 则过渡无法生效）;\n\ttransition-property : height,width,all; 多个属性值使用逗号隔开，all 关键字则指定所有可计算的属性；\n\ntransition-duration ： 指定过渡效果的持续时间 单位 ： s 和 ms ；\n\ntransition-timing-function ：过渡的时序函数 --- 指定过渡的执行速度方式；\n\t可选值：\n\t\tease 默认值 --- 慢速开始 先加速后再减速\n\t\tlinear 匀速运动\n\t\tease-in 加速运动\n\t\tease-out 减速运动\n\t\tease-in-out 先加速后减速\n\t\tcubic-bezier() 来指定时序函数  \n\t\tsteps() 分布执行过渡效果 --- 可以设置两个值（步数，end&#x2F;start）\n\t\t\tend --- 在时间结束时执行过渡（默认值）\n\t\t\tstart --- 在时间开始时执行过渡\n\t即使指定不一样的过渡时序函数执行时间都是按transition-duration指定\n\ntransition-delay ： 过渡效果的延迟，等待一段时间后再执行过渡，单位 ： s ms \n\n\n .demo&#123;\n           width: 700px;\n           height: 700px;\n           background-color: grey;\n           overflow: hidden;\n        &#125;\n        .demo1&#123;\n            width: 100px;\n            height: 100px;\n            background-color: #bfa;\n            &#x2F;* 设定demo1开始的位置 *&#x2F;\n            margin-left: 0;\n            &#x2F;* 设置demo1过渡的属性 --- margin-left *&#x2F;\n            transition-property: margin-left;\n            &#x2F;* 设置demo1的过渡持续效果 *&#x2F;\n            transition-duration: 2s;\n            &#x2F;* 设置demo1的过渡时序函数 --- 默认值*&#x2F;\n            transition-timing-function: ease;\n        &#125;\n        .demo:hover div&#123;\n            margin-left: 600px;\n        &#125;\n        .demo2&#123;\n            width: 100px;\n            height: 100px;\n            margin-top: 200px;\n            background-color: #bfa;\n            &#x2F;* 设定demo1开始的位置 *&#x2F;\n            margin-left: 0;\n            &#x2F;* 设置demo1过渡的属性 --- margin-left *&#x2F;\n            transition-property: margin-left;\n            &#x2F;* 设置demo1的过渡持续效果 *&#x2F;\n            transition-duration: 2s;\n            &#x2F;* 设置demo1的过渡时序函数 --- 使用曲线定义*&#x2F;\n            transition-timing-function: cubic-bezier(0,1.65,1,-0.77);\n            &#x2F;* 设置demo2延迟两秒再开始过渡 *&#x2F;\n            transition-delay: 2s;\n        &#125;\n        .demo3&#123;\n            width: 100px;\n            height: 100px;\n            margin-top: 200px;\n            background-color: #bfa;\n            &#x2F;* 设定demo1开始的位置 *&#x2F;\n            margin-left: 0;\n            &#x2F;* 设置demo1过渡的属性 --- margin-left *&#x2F;\n            transition-property: margin-left;\n            &#x2F;* 设置demo1的过渡持续效果 *&#x2F;\n            transition-duration: 2s;\n            &#x2F;* 设置demo1的过渡时序函数 --- steps*&#x2F;\n            transition-timing-function: steps(3,end);\n            &#x2F;* 指定过渡的时序为步骤的话 过渡效果会将整个默认过程均分为几个步骤 只展现那几步的状态\n            *&#x2F;\n        &#125;\n\ntransition 属性可以同时设置过渡的相关属性，只要求持续时间要写在延迟时间之前，其他属性顺序随便；\n动画动画：动画和过渡类似，都可实现一些动态的效果；\n\t两者不同的是过渡需要在某个属性发生变化时才触发执行，而动画可以自动触发执行；\n\nanimation-name : 要对当前元素生效的关键帧名字；\nanimation-duration ：动画执行的时间；\nanimation-delay ： 动画执行的延迟时间；\nanimation-timing-function ：动画执行的时序函数；\nanimation-iteration-count ：动画的执行次数；\n\t可选值：次数（具体数值）；  infinite（无限执行）；\nanimation-direction ：指定动画的执行方向；\n\t可选值：normal --- 默认值 从from 到 to 关键帧执行 每次都是这样；\n\t\t\treversal --- 从 to 到 from 关键帧执行 每次都是这样；\n\t\t\talternate --- 从 from 到 to 执行关键帧 重复执行时反向执行上一次的动画；\n\t\t\talternate-reverse --- 从 to 到 from 运行 重复执行动画时反向执行；\nanimation-play-state ： 设置动画的执行状态；\n\t可选值： running --- 默认值 动画执行； paused --- 动画暂停；\nanimation-fill-mode ： 动画的填充模式；\n\t可选值：none --- 默认值 动画执行完毕后元素回到原位置；\n\t\t\tforwards --- 动画执行完毕元素停在结束的位置；\n\t\t\tbackwards --- 动画延时等待时，元素就会处于开始位置；\n\t\t\tboth --- forwards 和 backwards 结合\n\n.demo&#123;\n            width: 700px;\n            height: 700px;\n            background-color: #bfa;\n        &#125;\n         /* 设置关键帧 */\n         @keyframes demo1-move&#123;\n                /* from表示动画开始的位置和状态 */\n                from&#123;\n                    margin-left: 0;\n                    background-color: aqua;\n                &#125;\n                /*  to 表示动画结束的位置 也可以用100% 表示 */\n                to&#123;\n                    background-color: orange;\n                    margin-left: 600px;\n                &#125;\n            &#125;\n        .demo1&#123;\n            width: 100px;\n            height: 100px;\n            background-color: skyblue;\n            /* 使用刚设置的关键帧 */\n            animation-name: demo1-move;\n            /* 设置动画的执行时长 */\n            animation-duration: 3s;\n            /* 设置动画的执行次数 迭代次数*/\n            animation-iteration-count: 3;\n            /* 设置动画的执行时序函数 */\n            animation-timing-function: ease;\n            /* 设置动画的执行方向 交替反向执行*/\n            animation-direction: alternate;\n            /* 设置动画的启动延时 */\n            animation-delay: 1s;\n            /* 设置动画的执行状态 */\n            /* animation-play-state: paused; */\n            /* 设置动画的执行填充  执行完以后停在执行结束的位置 */\n            animation-fill-mode: both;\n        &#125;\n\nanimation 属性：简写形式 除了执行时长必须要写在延时启动时间之前 其他属性设置顺序随意；","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"小米网站首页练习","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/10/小米网站首页练习/","content":"顶部导航栏\n\t小米首页的布局都是在一个外部容器宽占100%中放入一个内部容器布局，其中内部大容器的宽度都是一致 1226px ，这样可以通过设置水平的margin为auto达到内部元素水平居中；\n\t\n\t导航栏布局较简单：\n\t内部容器为一个大的div\n\t\t里面划分为3个ul\n\t\t\t左边的ul 开启 float:left\n\t\t\t右边的两个ul均开启 float:right; (注意float的先后顺序)\n\t\t每一个ul里的li元素均开启float:left使li元素可排列在同一排\n\t在开发中应设置li中的a标签转换为 block 元素 以使其高度与外部的div一致 增大a标签的可点击范围；\n\t\n\n导航栏设置主要难度在弹出层的设置：在鼠标移入 下载app 的li标签时 其下部应该展示下载的二维码，具体设置如下：\n\t\n1.应该设置弹出层的div放在a标签里面，这样才能确保在鼠标移入a标签时弹出层出现且在鼠标移入弹出层时a标签依旧保持hover效果，而且网页中的弹出层是可以点击的；\n\t\t\t&lt;li>\n                    &lt;a href=\"javascript:;\" class=\"app\">下载app\n                        &lt;div class=\"qrcode\">\n                            &lt;img src=\"./mi_images/download.png\">\n                            &lt;span>小米商城APP&lt;/span>\n                        &lt;/div>\n                    &lt;/a>\n                &lt;/li>\n\n2.a标签开启相对定位（此时弹出层div为其子元素），所以弹出层div要开启绝对定位来设置弹出的位置；\n\n3.弹出层的过渡效果通过设置弹出层div的高度开始为0，当鼠标移入a标签时，弹出层div高度逐渐增大到正常高度，使用transition属性设置，transition属性的开启设置在要变化的元素身上！！！\n\n4.购物车的弹出层实现方法和上述相似，我这里的购物车是一个单独的ul，而且这个ul里面只有一个li，所以我将弹出层和a标签放置在同级，为兄弟关系；\n&lt;!-- 右侧购物车 -->\n            &lt;ul class=\"shop-cart\">\n                &lt;li>\n                    &lt;a href=\"javascript:;\">\n                        &lt;i class=\"fas fa-shopping-cart\">&lt;/i>\n                        购物车（0）\n                    &lt;/a>\n                    &lt;div class=\"mycart\">\n                        &lt;span>购物车中还没有商品，赶紧选购吧！&lt;/span>\n                    &lt;/div>\n                &lt;/li>\n            &lt;/ul>\n\n5.弹出层的小三角箭头：通过绝对定位这是一个宽高均为0，但是有边框的div，再将不需要的边框设为透明可以实现小三角；\n&lt;style>\n.app::after&#123;\n    display: none;\n    content: '';\n    border: 8px solid transparent;\n    border-bottom-color: white;\n    height: 0;\n    width: 0;\n    /* 要设置宽度才能实现居中 */\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n&#125;\n&lt;/style>\n\n注意要设置弹出层的层级 z-index；  \nlogo栏\nlogo栏布局也是一个大的div中划分为三个部分，其中左侧div中是两个a标签，中间的是商品分类，采用ul布局，右侧的搜索框中是一个输入框和按钮；\n\n主要的难度是logo区图片的切换：\n\t外层的div实现设置好大小，且开启overflow：hidden，以此隐藏div外的图片；\n\t外层div开启相对定位，内部的两个a标签开启绝对定位，当鼠标移入div时，通过改变图片的left偏移量来实现图片的平移，通过给两个a标签开启transition属性实现过渡效果；\n\n中间的ul布局中的li中的a标签应该同父元素高度一致，ul中的最后一个li放的是弹出层，弹出层的绝对定位通过外部容器的相对定位来定位，以此实现弹出层的宽度为100%；\n\nul中的第一个li为隐藏元素，该元素里面有一个纵向的导航栏，该导航栏的绝对定位相对于这第一个隐藏元素li的相对定位；\n录播图区块\n轮播图区块设置主要在切换按钮的雪碧图和右下角的小圆点按钮\n\n雪碧图和小圆点均是开启绝对定位，相对于放入img元素的父元素的相对定位；\n伪元素边框\n该元素的边框均是通过给div中的li元素添加伪元素；\n&lt;style>\n     .home-shop-wrapper .shortcut li::before&#123;\n        content: '';\n        width: 64px;\n        height: 1px;\n        background-color: #665e57;\n        /* background-color: red; */\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        margin: 0 auto\n    &#125;\n    .home-shop-wrapper .shortcut li::after&#123;\n        content: '';\n        width: 1px;\n        height: 70px;\n        background-color: #665e57;\n        /* background-color: red; */\n        position: absolute;\n        left: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto 0;\n    &#125;\n&lt;/style>\n固定工具栏\n使用固定定位一个ul列表；其右侧的弹出层相对于它的每一个li元素定位，当鼠标移入li时，a标签的下一个兄弟元素展示；\n广告卡片展示\n卡片均开启相对定位，当鼠标移入时修改卡片的top属性，加上阴影box-shadow实现卡片效果；\n\n总结/*\n\t这次的小米首页布局历时了几天才完成，虽然内容不多，但是算得上是第一次完成比较完整的网页布局，开发网页都需要先考虑好元素的摆放布局，之后再考虑样式问题；\n\t这个网页使用了相对布局，绝对布局，固定布局，也是第一次接触到transition过渡属性；\n\t在练习时发现了类选择器的优先级问题，写的详细的类选择器优先级较高；\n\t总的来说这次练习再次复习了一下之前所学的知识，对布局的等式有了进一步理解；\n*/\n\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"011-表格-表单","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/06/011-表格-表单/","content":"1.表格使用 table 标签 在网页中创建表格\n\ttr 标签表示表格中的一行\n\ttd 标签表示表格中的一个单元格\n\t\t可在table标签中设置表格的边框属性 默认为没有边框\n\t\ttable是块元素 但是其默认的宽度不会是占满一行 而是由内容撑开 其他的由浏览器自动调整margin-right\n\n&lt;!-- 创建一个表格 -->\n    &lt;!-- 在table标签中 设置border边框属性 -->\n    &lt;table border=\"1px\" >\n        &lt;tr>\n            &lt;td>学号&lt;/td>\n            &lt;td>姓名&lt;/td>\n            &lt;td>年龄&lt;/td>\n        &lt;/tr>\n        &lt;tr>\n            &lt;td>001&lt;/td>\n            &lt;td>gbfdhsj&lt;/td>\n            &lt;!-- 使用rowspan属性合并行单元格 -->\n            &lt;td  rowspan=\"2\">man&lt;/td>\n        &lt;/tr>\n        &lt;tr>\n            &lt;td>001&lt;/td>\n            &lt;td>Kods&lt;/td>\n            \n        &lt;/tr>\n        &lt;tr>\n            &lt;td>001&lt;/td>\n            &lt;!-- 使用colspan属性设置列单元格合并 -->\n            &lt;td colspan=\"2\">Kods&lt;/td>\n        &lt;/tr>\n    &lt;/table>\n\n\n表格可以分为三个部分 thead -- 头部 ； tbody -- 主体 ； tfoot -- 底部 ；\n\t在行中使用th来表示表格的首行的单元格 此时用于表示表格的列值名称 th表示的单元格文字默认加粗\n\n&lt;table border=\"1px\" width=\"400px\" style=\"margin:20px auto;\">\n        &lt;thead>\n            &lt;tr>\n                &lt;th>学校&lt;/th>\n                &lt;th>名字&lt;/th>\n                &lt;th>分数&lt;/th>\n                &lt;th>专业&lt;/th>\n            &lt;/tr>\n        &lt;/thead>\n        &lt;tbody>\n            &lt;tr>\n                &lt;td>惠州学院&lt;/td>\n                &lt;td>hjihu&lt;/td>\n                &lt;td>111&lt;/td>\n                &lt;td>计算机&lt;/td>\n            &lt;/tr>\n            &lt;tr>\n                &lt;td>惠州学院&lt;/td>\n                &lt;td>hjihu&lt;/td>\n                &lt;td>111&lt;/td>\n                &lt;td>计算机&lt;/td>\n            &lt;/tr>\n            &lt;tr>\n                &lt;td>惠州学院&lt;/td>\n                &lt;td>hjihu&lt;/td>\n                &lt;td>111&lt;/td>\n                &lt;td>计算机&lt;/td>\n            &lt;/tr>\n            &lt;tr>\n                &lt;td>惠州学院&lt;/td>\n                &lt;td>hjihu&lt;/td>\n                &lt;td>111&lt;/td>\n                &lt;td>计算机&lt;/td>\n            &lt;/tr>\n        &lt;/tbody>\n    &lt;/table>\n\nborder-spacing: 指定边框之间的距离 此时指两边框间的距离 不是边框重合\nborder-spacing: 0px; 两边框相邻间隔为0\nborder-collapse: collapse; 设置边框的合并 此时指两边框合并为一条边框 \n\n table&#123;\n            width: 500px;\n            margin: 30px auto;\n            border: 1px solid black;\n            /* 此时在css文件中设置table的边框样式只有外边框 单元格此时没有边框 */\n            border-spacing: 0px;\n            /* 2.利用border-spacing属性设置边框间的间隔为0px\n                此时的边框为2px\n            */\n            border-collapse: collapse;\n            /* 3.设置边框重合 此时边框只有1px*/\n        &#125;\n        td&#123;\n            border: 1px solid black;\n            /* 4.此时给每一个单元格设置外边框 加上table的外边框此时呈现双边框效果 */\n            text-align: center;\n            /* 5.设置单元格中文字居中 */\n            /* 单元格中的元素默认垂直居中 */\n            /* vertical-align: top; */\n        &#125;\n        table  tr:nth-child(odd)&#123;\n            background-color: #bfa;\n            /* 在写代码时若我们没有使用tbody 浏览器在解析时也会自动加上tbody' */\n            /* 设置奇数行背景颜色 */\n        &#125;\n        table tr:nth-child(even)&#123;\n            background-color: aliceblue;\n        &#125;\n2.表单在网页中使用 form 标签创建表单\n\t在action中值为处理表单收集到的信息发送的服务器地址\n\t表单中输入的信息可选input标签 通过选择type类型来设置输入类型\n\t\ttext -- 文本\n\t\tpassword -- 密码\n\t\tradio -- 单选框（单选框需要使用同一组name值来限定）\n\t\tcheckbox -- 多选框\n\t\tcolor -- 颜色选择器\n\t表单元素必须指定name属性\n\treadonly 将表单项设置为只读，数据会提交\n\tdisabled 将表单项设置为禁用，数据不会提交\n    autofocus 设置表单项自动获取焦点\n\nautocomplete=\"off\" 关闭自动补全\n\t\t\n  &lt;form action=\"target.html\">\n        &lt;div class=\"title\">\n            &lt;h1>用户注册&lt;/h1>\n        &lt;/div>\n        &lt;div class=\"info-input\">\n            &lt;label for=\"username\">姓名&lt;/label>\n            &lt;input type=\"text\" id=\"username\" name=\"username\" placeholder=\"请输入用户名\" autocomplete=\"off\" value=\"1212\" readonly autofocus>\n        &lt;/div>\n        &lt;div class=\"info-input\">\n            &lt;label for=\"password\">密码&lt;/label>\n            &lt;input type=\"password\" id=\"password\" name=\"password\" placeholder=\"请输入密码\" value=\"1212\" disabled>\n        &lt;/div>\n        &lt;div>\n            &lt;label for=\"sex\">性别&lt;/label>\n            &lt;input type=\"radio\" value=\"1\" name=\"sex\" id=\"sex\" checked>男\n            &lt;input type=\"radio\" id=\"sex\" value=\"2\" name=\"sex\">女\n        &lt;/div>\n        &lt;div>\n            &lt;label for=\"major\">专业&lt;/label>\n            &lt;select id=\"major\" name=\"major\">\n                &lt;option value=\"1\">计算机&lt;/option>\n                &lt;option value=\"2\" selected>数学&lt;/option>\n            &lt;/select>\n        &lt;/div>\n        &lt;div>\n            &lt;label for=\"hobby\">爱好&lt;/label>\n            &lt;input type=\"checkbox\" name=\"bobby\" id=\"hobby\" value=\"1\">篮球\n            &lt;input type=\"checkbox\" name=\"bobby\" id=\"hobby\" value=\"2\">足球\n            &lt;input type=\"checkbox\" name=\"bobby\" id=\"hobby\" value=\"3\">跑步\n        &lt;/div>\n        &lt;input type=\"color\" name=\"\" id=\"\">\n        &lt;input type=\"submit\" value=\"注册\">\n    &lt;/form>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"010-背景-颜色渐变","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/05/010-背景/","content":"1.背景background-color 设置背景颜色\n\nbackground-image 设置背景图片\n\t可以同时设置背景颜色和背景图片 此时背景颜色会成为背景图片的背景色\n\t\t1.如果背景图片小于当前的元素大小 背景图片会自动在元素中平铺\n\t\t2.如果背景图大于元素 将会溢出父元素 溢出元素的背景无法显示\n\t\t3.若背景图片和元素一样大 则会直接正常显示\n\n background-repeat 用来设置背景的重复方式\n         可选值：\n                repeat 默认值 ， 背景会沿着x轴 y轴双方向重复\n                repeat-x 沿着x轴方向重复\n                repeat-y 沿着y轴方向重复\n                no-repeat 背景图片不重复\n\n background-position 用来设置背景图片的位置\n                    设置方式：\n                        通过 top left right bottom center 几个表示方位的词来设置背景图片的位置\n                            使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center\n\n                        通过偏移量来指定背景图片的位置：\n                            水平方向的偏移量 垂直方向变量\n\n.demo&#123;\n            width: 300px;\n            height: 300px;\n            background-color: #bfa;\n\n            /* 设置背景图片 */\n            background-image: url('./img/1.png');\n            /* 1.原背景图片 大小为  128* 128 此时背景图小于元素\n                此时背景图默认在元素中重复平铺展示\n            */\n\n            /* width: 100px;\n            height: 100px; */\n            /* 2.将元素大小修改成小于背景图 此时溢出元素的背景无法显示 */\n\n            /* width: 128px;\n            height: 128px; */\n            /* 3.此时元素与背景图大小一致 正常显示 */\n\n            background-repeat: repeat;\n            /* 4.设置背景图的重复方式 此时背景图小于元素 \n            且重复方式为 repeat默认值 此时背景图水平垂直方向上均重复*/\n\n            /* background-repeat: repeat-x; */\n            /* 5.设置背景图重复方式为水平重复 此时垂直方向上无重复 */\n\n            /* background-repeat: repeat-y; */\n            /* 6.设置背景图垂直重复 此时背景图水平方向上无重复 */\n\n            background-repeat: no-repeat;\n            /* 7.设置背景图水平垂直方向上均无重复 */\n\n            background-position: 0 0;\n            /* 8.设置背景图偏移量来设置背景图的位置 此时 0 0 为默认值 \n                为父元素文档流中的位置 元素的内边距区开始计算\n            */\n\n            background-position: 10px 20px;\n            /* 9.第一个值为水平方向上的偏移（正值时图片向右移动）\n                第二个值为垂直方向上的偏移（正值时图片向下移动）\n            */\n\n            background-position: center center;\n            /* 10. 通过方位词来设置背景图的位置 */\n\n        &#125;\n\nbackground-clip 设置背景范围\n\t可选值 : border-box 默认值 此时背景图会出现在边框的下边\n\t\t\tpadding-box 此时背景不会出现在边框下边 但会出现在内容区和内边距区\n\t\t\tcontent-box 此时背景只会出现在内容区\n\n.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n\n            border: 10px transparent solid;\n            /* 给元素添加10px 的透明边框  */\n            padding: 10px;\n            /* 给元素添加 10 px 的内边距区 */\n            background-clip: border-box;\n            /* 1.此时的background-clip 值为border-box 默认值 此时背景会出现在边框区 和 内边距区*/\n            background-clip: padding-box;\n            /* 2.设置background-clip 值为 padding-box \n            此时背景颜色不会出现在边框区 此时元素的外边框因背景透明不可见 */\n            background-clip: content-box;\n            /* 3.设置背景颜色只出现在内容区 此时内边距区因背景透明不可见 */\n\n        &#125;\n\nbackgroung-origin 设置背景图偏移量（background-position）的计算原点\n\t可选值： padding-box 默认值 此时计算原点从内边距区处开始计算\n\t\t\tcontent-box 背景图偏移量计算原点从内容区开始\n\t\t\tborder-box 背景图偏移量的计算原点从边框处开始计算\n\nbackground-size 设置背景图的大小 第一个值表示宽 第二个值表示高\n\t若只写一个值 则默认第二个值是auto\n\tcover --- 图片的比例不变 将元素铺满\n\tcontain --- 图片比例不变 将图片在元素中完整显示\n\nbackground-attachment 设置背景是否会跟随元素移动\n\t可选值 : scroll 默认值此时背景图会跟随元素移动\n\t\t\tfixed 背景图会固定在页面中 不会跟随元素移动\n\n.demo1&#123;\n            width: 1920px;\n            height: 1000px;\n            background-color: #bfa;\n            background-image: url('./img/2.jpg');\n            /* 此时背景图远大于元素 溢出部分无法显示 */\n\n            background-size: 500px;\n            /* 1.通过设置background-size 设置背景图的宽为500px 此时高等比例缩小\n            此时背景图在元素内平铺 效果和 contain 一致\n            */\n\n            background-size: cover;\n            /* 2.图片的比例不变 将元素铺满 */\n            /* background-size: contain; */\n            /* 3.图片的比例不变 将图片在元素中完整显示 可能会出现重复平铺 */\n            background-repeat: no-repeat;\n            /* 4.设置背景图不重复平铺 */\n\n            border: 10px solid red;\n            padding: 20px;\n            /* 设置外边框个内边距 此时背景图延伸到内边距区 */\n\n            background-origin: padding-box;\n            /* 5.设置背景图的偏移计算原地为内边距区 */\n            /* background-position: 10px 10px; */\n            \n            background-origin: content-box;\n            /* 6.设置背景图的偏移计算原点为内容区 */\n\n            background-origin: border-box;\n            /* 7.设置背景图偏移量计算原点为外边框区 */\n\n            background-attachment: scroll;\n            /* 8.设置背景图跟随元素移动 scroll 为默认值 */\n\n            background-attachment: fixed;\n            /* 9.设置背景图以原图大小固定在在页面中元素文档流的位置 \n                溢出的背景不可见 滑动页面元素移动时背景不会动\n                想象是移动画框 画固定在原地\n            */\n        &#125;\n2.背景色渐变1.水平垂直线性渐变渐变 ： 一个颜色向其他颜色过渡的效果 \nPS： 渐变是图片！！ 需通过background-image 来设置\n\tlinear-gradient 线性渐变 颜色沿着一条直线发生变化\n\t线性渐变的开头 可以指定一个渐变的方向\n\t\tto left ； to right ； to bottom ； to top ； to top left ...\n\t\tdeg --- 度数 ； turn --- 圈数 ；\n\t渐变可以同时指定多个颜色 多个颜色情况下平均分布；\n\t\t可以手动指定渐变的分布情况；\n\n.box2&#123;\n            width: 200px;\n            height: 200px;\n            background-image: linear-gradient(red,green);\n            /* 设置线性渐变 从红色到绿色 默认情况上是 从上到下渐变 各占一半分布 */\n\n            background-image: linear-gradient(to right,red,yellow);\n            /* 设置从左到右的线性渐变 从红色到绿色 */\n\n            background-image: linear-gradient(to left, red,yellow 50px,gold 100px ,orange 150px,grey 200px);\n            /* 设置从左到右由红色开始渐变到黄色占50px \n                再由黄色渐变到金色 占50px\n                再由金色渐变到橘色 占50px\n                再由橘色渐变到灰色 占50px\n            */\n\n            background-image: linear-gradient(90deg, red,yellow );\n            /* 0度 时为从下到上渐变 90deg为顺时针旋转90度 此时为由红色到黄色 从左到右水平线性渐变*/\n\n            background-image: linear-gradient(0.25turn,red,yellow);\n            /* 0turn为从下到上渐变  0.25turn相当于顺时针旋转90度*/\n        &#125;\n2.径向渐变background-image：radial-gradient（） 可设置径向渐变（放射性效果）\n\t默认情况下径向渐变的形状根据元素的形状来计算 正方形 --- 圆形； 长方形 --- 椭圆形；\n\t也可以手动指定径向渐变的大小\n\t\t1.circle ； 2.ellipse ； \n\t指定渐变的位置\n\t\tradial-gradient（大小 at 位置 ， 颜色 位置， 颜色 位置，颜色 位置）\n\t\t\t\t大小：circle 圆形；ellipse 椭圆形；closest-side 近边；closest-corner 近角； \n\t\t\t\t\tfarthest-side 远边； farthest-corner 远角；\n .box2&#123;\n            width: 200px;\n            height: 200px;\n            background-image: radial-gradient(circle at 50px 50px,red,yellow);\n            /* 设置径向渐变  */\n        &#125;\n详见参考官方文档  ： https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/radial-gradient()","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"009-字体和图标","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/02/009-字体和图标/","content":"1.默认字体格式设置网页字体属性 \n\t1. color 设置元素的字体颜色\n\t2. font-size 设置字体的大小 单位 px em（以父元素为标准） rem（以根元素body为标准）\n\t\t1em / 1rem =1默认字体大小\n\t3. font-family 字体族 设置字体的样式 \n\t\t可选值 ： serif 衬线字体 ； sans-serif 非衬线字体 ； monospace 等宽字体 ；\n\t\tfont-family 可同时指定多个字体 多个字体间用 , 隔开 字体生效时优先使用第一个 往后以此类推\n\t4. font-weight 字重 设置字体的加粗\n\t\t可选值 ： normal 默认值； bold 加粗； \n\t5. font-style 字体风格\n\t\t可选值 ： normal 默认值； italic 斜体；\n\t\t\n.demo1&#123;\n            border: 2px red solid;\n            /* 设置demo1 字体颜色 */\n            color: skyblue;\n            /* 设置demo1 字体大小 */\n            font-size: 18px;\n            /* 设置demo1 字体样式 非衬线字体*/\n            font-family: sans-serif;\n        &#125;\n        .demo2&#123;\n            border: 2px red solid;\n            color: green;\n            font-size: 1em;\n            font-family: monospace;\n        &#125;\n        .demo3&#123;\n            border: 2px red solid;\n            color: aqua;\n            font-size: 2rem;\n            font-family: serif;\n        &#125;\n\n\n字体的简写格式\nfont 可以设置字体相关的所有属性 语法： font: 字体大小/行高 字体族 行高 可以省略不写 如果不写使用默认值\n\t p&#123;\n            border: 2px red solid;\n            font: 30px/40px monospace;\n            /* 将字体设置为 大小为 30px 行高为40px 字体族为等宽字体 */\n            font: italic bold 30px serif;\n            /* 将字体设置为 斜体 粗体 大小为30px 行高默认 字体族为衬线字体 */\n        &#125;\n&lt;p>遇沉沉不语之士，且莫输心；见悻悻自好之人，应须防口。 --菜根谭·概论&lt;/p>\n2.使用自定义字体格式在 &lt;style> 标签中导入自已的字体样式资源\n\n\t@font-face&#123;\n        /* 指定字体在网页中使用时的名字 */\n        font-family: '自己起的字体名字';\n        src: url('字体所在的路径') format(\"truetype\")\n&#125;\n.demo4&#123;\n            border: 2px red solid;\n            color: black;\n            font-size: 1em;\n            /* 使用自定义字体样式 */\n            font-family: myfont;\n        &#125;\n3.矢量图标–Awesome的使用1.下载 https://fontawesome.com/\n            2.解压\n            3.将css和webfonts移动到项目中\n            4.将all.css引入到网页中\n            5.使用图标字体\n                - 直接通过类名来使用图标字体\n                    class=\"fas fa-bell\"\n                    class=\"fab fa-accessible-icon\"\nPS ： class 中 只有fas 和 fab 是免费的 当图标字体加载不出来的应在fas 和 fab 中切换尝试\n\n&lt;link rel=\"stylesheet\" href=\"./fa/css/all.css\">\n\n方法1：\n &lt;!-- 通过直接在标签类名使用图标 -->\n    &lt;i class=\"fas fa-spider\" style=\"font-size: 40px; color: red;\">&lt;/i>\n\n方法2：\n &lt;!-- 通过使用实体编码使用图标  &amp;#x实体编码; -->\n    &lt;i class=\"fas\" style=\"font-size: 25px;\">&amp;#xf6be;&lt;/i>\n\n方法3：在伪元素选择器中使用图标\np::before&#123;\n            /* 使用 \\ 加实体编码 作为图标的表示 */\n            content: '\\f0a4';\n            font-size: 30px;\n            /* 必须指定图标族名 Font Awesome 5 Brands/Free 二选一 */\n            font-family: 'Font Awesome 5 Free';\n        &#125;\n        p::after&#123;\n            content: '\\f0a5';\n            font-size: 30px;\n            font-family: 'Font Awesome 5 Free';\n        &#125;\n    &lt;p>\n        好一似今朝沦落人，且回首往昔荣华日。 --鼻子\n    &lt;/p>\n4.阿里字体库使用–iconfont1.在阿里图标库官网选择需要的图标 添加至项目 下载项目并解压\n2.将文件放入网页静态资源中 通过 link 引入样式 iconfont.css 文件\n3.使用方法和Awesome基本一致 在标签中使用时类名均为 iconfont\n\t&lt;link rel=\"stylesheet\" href=\"./MyiconFont/iconfont.css\">\n\n方法1：\n\t&lt;!-- 使用标签类名使用图标 -->\n    &lt;i class=\"iconfont icon-a-1\">&lt;/i>\n\n方法2：\n    &lt;!-- 使用实体编码使用图标 -->\n    &lt;i class=\"iconfont\">&amp;#xe733;&lt;/i>\n\n方法3：\n p::before&#123;\n     \t\t/* 转义编码为实体编码&amp;#x 后的字符 */\n            content: '\\e73f';\n            font-family: 'iconfont';\n            font-size: 100px;\n        &#125;\n \t&lt;p>\n        万物皆有裂痕，那是光照进来的地方。 --颂歌\n    &lt;/p>\n5.行高行高指文字占有的实际高度 可通过 line-height 指定行高\n行高可以直接指定一个大小（px em）\n                        也可以直接为行高设置一个整数\n                            如果是一个整数的话，行高将会是字体的指定的倍数\n 行间距 = 行高 - 字体大小\n 字体框 - 字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度\n \t\t\t行高会在字体框的上下平均分配\n\n.demo&#123;\n            /* 设置字体大小 */\n            font-size: 50px;\n            /* 设置边框 */\n            border: 2px red solid;\n            /* 设置行高 */\n            line-height: 50px;\n            /* 1.此时文字和行高一致 若此时文字的行高小于字体大小的话 文字将叠在一起 */\n            line-height: 60px;\n            /* 2.此时行高大于字体大小 即实际上文字的高度小于文字所在行的高度 此时可见文本行间距较大 */\n        &#125;\n&lt;div class=\"demo\">\n        但使文章有风骨，岂凭时间庸人辱。 --知乎Lorem ipsum, dolor sit amet consectetur adipisicing elit. Corrupti iste reiciendis aliquid consectetur porro autem aut recusandae odit, sint, quis adipisci odio obcaecati quas maxime ducimus exercitationem est! Repellat, ad.\n    &lt;/div>\n6.文本的样式1.文本水平，垂直对齐text-align 属性可设置文本的水平对齐方式\n\t可选值：left 左对齐；right 右对齐；center 居中对齐； justify 两端对齐；\n.demo&#123;\n            border: 2px red solid;\n            font: 30px monospace;\n            text-align: center;\n            /* 1.居中对齐 */\n            text-align: left;\n            /* 2.居左对齐 */\n            text-align: justify;\n            /* 3.两端对齐 */\n            text-align: right;\n            /* 4.居右对齐 */\n        &#125;\n\nvertical-align 属性设置元素的垂直对齐方式\n\t可选值： baseline 默认值 基线对齐\n\t\t\ttop 顶部对齐\n\t\t\tbottom 底部对齐\n\t\t\tmiddle 居中对齐\n\n\t\t.demo1&#123;\n            font: 50px monospace;\n            border: 2px red solid;\n        &#125;\n        span&#123;\n            border: 1px blue solid;\n            font: 30px serif;\n            vertical-align: baseline;\n            /* 1.设置基线对齐 默认值 */\n            vertical-align: top;\n            /* 2.设置垂直顶部对齐 此时span元素在行间以父元素的顶部对齐 */\n            vertical-align: bottom;\n            /* 3.设置垂直底部对齐 此时span 元素在行间以父元素的底部对齐 底部对齐低于基线对齐 */\n            vertical-align: middle;\n            /* 4.设置垂直居中对齐 此时span元素在行间以父元素中的x的中心点为基准对齐*/\n        &#125;\n&lt;div class=\"demo1\">\n        上善若水，水善利万物而不争。x&lt;span>Hellox督导室覅女卫&lt;/span> --老子·道经·第八章\n    &lt;/div>\n2.文本修饰text-decoration 设置文本修饰\n\t可选值：none 什么都没有； underline 下划线； line-through 删除线； overline 上划线；\n\n .demo1&#123;\n            font: 30px monospace;\n            text-decoration: none;\n            /* 1.text-decoration : none 此时文本无效果 */\n            text-decoration: line-through;\n            /* 2.删除线效果 */\n            text-decoration: underline;\n            /* 3.下划线效果 */\n            text-decoration: overline;\n            /* 4上划线效果 */\n        &#125;\n&lt;div class=\"demo1\">\n        凡事都有一个与一望而知不同的真相 --约翰·勒卡雷\n    &lt;/div>\n\nwhite-space 设置网页如何处理空白\n\t可选值： normal 正常 默认值； nowrap 不换行； pre 保留空白；\n\n .demo2&#123;\n            font: 30px sans-serif;\n            white-space: normal;\n            /* 1.normal 正常 此时网页解析时 多个空格解析成一个空格 */\n            white-space: nowrap;\n            /* 2.nowrap 不换行 此时网页解析时文本段不换行 */\n            white-space: pre;\n            /* 3.pre 保留空白 此时网页解析时按照编辑器里文本的格式解析*/\n        &#125;\n&lt;div class=\"demo2\">没有人愿意承认自己是孤独的，孤独很可耻。            \n           --此间的少年Lorem ipsum dolor sit amet consectetur adipisicing elit. Nobis eos praesentium repellendus, facilis iure ullam accusamus? Quis, culpa numquam itaque voluptatem ullam magni tenetur, asperiores consequuntur necessitatibus nostrum ut dolores!\n        &lt;/div>\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"008-position布局","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/01/008-position布局/","content":"1.position布局​    定位（position）是一种布局手段 通过定位可以将元素摆放到任意位置\n​        使用position属性来开启定位：\n​                可选值  1.static 默认值 此时元素为不开启定位\n​                            2.relative 开启元素相对定位\n​                            3.absolute 开启元素绝对定位\n​                            4.fixed 开启元素固定定位\n​                            5.sticky 开启元素粘滞定位\n      偏移量（offset）：元素开启定位后 可以通过偏移量来设置元素的位置\n\n​                        top —  定位元素和定位位置上边的距离 top值越大 定位元素越靠下\n​                        bottom — 定位元素和定位位置下边的距离 bottom值越大 定位元素越靠上\n​                        left —  定位元素和定位位置左侧的距离 left值越大 定位元素越靠右\n​                        right —  定位元素和定位位置右侧的距离 right值越大 定位元素越靠左\n2.相对定位当元素的position属性为 relative 时 开启相对定位 \n\t- 相对定位的特点：\n                            1.元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化\n                            2.相对定位是参照于元素在文档流中的位置进行定位的\n                            3.相对定位会提升元素的层级\n                            4.相对定位不会使元素脱离文档流\n                            5.相对定位不会改变元素的性质块还是块，行内还是行内\n.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 1.初始三个div垂直排列 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            position: relative;\n            /* 2.demo2开启相对定位 但是还未设置偏移量\n                开启相对定位的元素不会脱离文档流 所以demo3的位置不会发生变化\n            */\n            left: 0px;\n            right: 0px;\n            /* 3.给元素的相对定位偏移量设置为 left 0 right 0 让其回到参照原点 可知\n                相对定位的参照原点为其在文档流时候的位置\n            */\n            left: 200px;\n            top: -200px;\n            /* 4.给元素依照参照原点 向右移动200px 向上移动200px 使其与demo1水平相邻排列*/\n            left: 70px;\n            /* 5.将元素demo2向右水平移动的距离改为70px 可见现在demo2遮盖住了demo1 所以可知相对定位会提升元素的层级\n                应为开启相对定位的元素未脱离文档里 不会改变元素的块级元素性质 而且开启相对定位的元素 其文档流后的元素不会因为其移动为改变布局\n            */\n        &#125;\n        .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: green;\n            /* demo3全程不移动 虽然demo已经移走 但是demo2还占据文档流中的位置 */\n        &#125;\n\t&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3&lt;/div>\n3.绝对定位当元素的position属性值为 absolute 时 元素开启绝对定位\n\t- 绝对定位的特点：\n                    1.开启绝对定位后，如果不设置偏移量元素的位置不会发生变化\n                    2.开启绝对定位后，元素会从文档流中脱离\n                    3.绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开\n                    4.绝对定位会使元素提升一个层级\n                    5.绝对定位元素是相对于其包含块进行定位的\n包含块( containing block )\n                        - 正常情况下：\n                            包含块就是离当前元素最近的祖先块元素\n                            &lt;div> &lt;div>&lt;/div> &lt;/div>\n                            &lt;div>&lt;span>&lt;em>hello&lt;/em>&lt;/span>&lt;/div>\n\n                        - 绝对定位的包含块:\n                            包含块就是离它最近的开启了定位的祖先元素，\n                                如果所有的祖先元素都没有开启定位则根元素就是它的包含块\n\n                        - html（根元素、初始包含块）\n.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            /* 1.初始demo1和demo2垂直相邻排列 */\n            position: absolute;\n            /* 4.demo2 开启绝对定位 demo2脱离文档流 所以demo3向上移动部位\n                但是demo2还未设置偏移量 所以demo2位置不发生变化\n                但是明显demo2遮挡住了demo3 可知开启绝对提升了元素的层级\n            */\n            top: 0;\n            left: 0;\n            /* 5.让demo2回到定位参照原点 可知此时demo2回到了最左上角 */\n            /* 8. 可知demo2此时的包含块是html根标签 所以回到最左上角 */\n        &#125;\n        .demo3&#123;\n            width: 400px;\n            height: 400px;\n            background-color: greenyellow;\n        &#125;\n        .demo4&#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n            position: relative;\n            /* 6.demo4 开启相对定位  未设置偏移量 此时demo4位置不发生变化*/\n        &#125;\n        .demo5&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            /* 2.初始demo3里包含demo4，demo4包含demo5 */\n            position: absolute;\n            /* 3.demo5开启绝对定位 还未设置偏移量 页面布局不发生变化 */\n            top: 0;\n            left: 0;\n            /* 7.让demo5回到定位参照原点 可见demo5回到了demo4文档流所在位置\n                可知绝对定位的参照原点是距其最近的开启了定位的包含块\n                    若元素的祖先们均未开启定位 则该元素的定位参照原点为html根包含块\n            */\n        &#125;\n\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4\n            &lt;div class=\"demo5\">5&lt;/div>\n        &lt;/div>\n    &lt;/div>\n\nPS：实际开发中 使用绝对定位和相对定位较多\n4.固定定位元素的position属性值为 fixed 时 元素开启固定定位\n\t特点：固定定位为绝对定位的一种 用法性质基本和绝对定位一致 \n\t\t\t唯一不同的是固定定位的参照原点一直都是浏览器的视口\n\t\t\t固定定位的元素不会随网页的滚动条移动\n .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 250px;\n            height: 250px;\n            background-color: skyblue;\n            position: fixed;\n            /* 2.demo2开启固定定位 */\n            top: 0;\n            left: 0;\n            /* 3. demo2回到定位参照原点 此时demo2位于页面最左上角 demo2此时脱离文档流 demo3上移*/\n        &#125;\n        .demo3&#123;\n            width: 300px;\n            height: 300px;\n            background-color: yellowgreen;\n            position: relative;\n            /* 4.demo3开启相对定位 */\n        &#125;\n        .demo4&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            position: fixed;\n            /* 1.demo4开启固定定位 此时未设置偏移量时 demo4固定在网页的这个位置不动 */\n            top: 0;\n            left: 0;\n            /* 5.demo4也回到定位参照原点 可知 此时demo4也会在demo2所在位置\n                可知固定定位的参照原点是浏览器的网页视口\n            */\n             left: 400px;\n            /* 让demo4从参照原点向右移动400px */\n        &#125;\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4&lt;/div>\n    &lt;/div>\n\n5.粘滞定位粘滞定位\n                    - 当元素的position属性设置为sticky时则开启了元素的粘滞定位\n                    - 粘滞定位和相对定位的特点基本一致，\n                        不同的是粘滞定位可以在元素到达某个位置时将其固定\n粘滞定位只能调整top 和 left 且调整top是不影响元素的原位置 只有在滑动元素要离开这一页面时才生效\n\n  .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: beige;\n        &#125;\n        .demo2&#123;\n            width: 250px;\n            height: 250px;\n            background-color: skyblue;\n            position: sticky;\n            /* 1.demo1 开启粘滞定位 特点和相对定位差不多 元素不脱离文档流 */\n            left: 0;\n            top: 0;\n            /* 2.demo2 回到参照原点  此时网页下滑时demo2在浏览器视口位置保持不动*/\n            left: 200px;\n            /* 3. demo2 向左移动200px 此时网页下滑时 demo2在浏览器视口向左移动200px的位置保持不变 */\n            top: 20px;\n            /* 4. 未滑动时demo2位置不发生变化 可知设置top未滑动页面时不影响元素原位置 \n                在页面下滑时 页面会停留在参照浏览器视口而偏移的位置\n            */\n        &#125;\n        .demo3&#123;\n            width: 100px;\n            height: 100px;\n            background-color: dodgerblue;\n        &#125;\n\n&lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3&lt;/div>\n6.绝对定位元素的布局开启绝对定位以后 水平方向的布局的等式需要再加入 left right 两个值\n left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块的内容区的宽度\n此时规则和之前一样只是多添加了两个值：\n                            当发生过度约束：\n                                如果9个值中没有 auto 则自动调整right值以使等式满足\n                                如果有auto，则自动调整auto的值以使等式满足\n\n                        - 可设置auto的值\n                            margin width left right\n\n                        - 因为left 和 right的值默认是auto，所以如果不指定left和right\n                            则等式不满足时，会自动调整这两个值\n\n 垂直方向布局的等式的也必须要满足\n   bottom + top + margin-top/bottom + padding-top/bottom + border-top/bottom + height = 包含块的高度\n\n .demo1&#123;\n            width: 300px;\n            height: 300px;\n            background-color: #bfa;\n            position: relative;\n            /* 4.demo1开启相对定位 因此demo2的包含块更改为demo1所在的文档流位置 */\n        &#125;\n        .demo2&#123;\n            width: 100px;\n            height: 100px;\n            background-color: skyblue;\n            /* 1.此时demo1 和 demo2 上边距重叠 */\n            position: absolute;\n            /* 2.demo2开启绝对定位 */\n            left: 0;\n            top: 0;\n            /* 3.demo2回到定位参照原点 此时其父元素还没开启定位 所以其包含块应该是html根元素*/\n            right: 0;\n            /* 5.设置 right == 0 但是水平的等式 过度约束仍然成立 此时浏览器自动调整right不为0以满足等式 */\n            margin-left: auto;\n            /* 6.设置demo2 的margin-left为auto 此时等式不成立是 浏览器优先调整margin-left为最大值以满足等式 */\n            margin-right: auto;\n            /* 7.此时demo2 的margin-right 也为auto 此时浏览器自动调整水平两边的margin值相等 达到居中 */\n            bottom: 0;\n            margin: auto;\n            /* 8.此时demo2的水平 垂直方向上margin 均为 auto 所以浏览器优先调整margin 达到水平垂直居中 */\n        &#125;\n &lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n\n\nPS： 在绝对定位中 若定位元素未设置宽高时 且此时的margin == auto（四个方向），right=left=top=bottom=0 时 此时浏览器自动优先调整元素宽高为父元素大小以满足等式\n\t即margin与宽高均为auto时（元素开启绝对定位后 脱离文档流 元素的宽高默认被内容撑开 可看作为auto）此时宽高将被调整成最大值\n7.元素的层级对于开启了定位元素，可以通过z-index属性来指定元素的层级\n                    z-index需要一个整数作为参数，值越大元素的层级越高\n                        元素的层级越高越优先显示\n\n                    如果元素的层级一样，则优先显示靠下的元素\n\n                    祖先的元素的层级再高也不会盖住后代元素\n\n .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            position: relative;\n            /* 1.开启相对定位 */\n            z-index: 1;\n            /* 11.给demo1设置层级 此时demo1层级变为最高 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            position: absolute;\n            /* 2.开启绝对定位 */\n            top: 20px;\n            left: 40px;\n            /* 5. 此时移动demo2的位置 此时demo2 的参照原点是html根元素 可知demo2 的层级高于demo1 */\n        &#125;\n        .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gold;\n            /* 3.此时demo3移动到demo2下面 因为demo2已脱离文档流 且demo2此时的层级高于demo3*/\n            position: absolute;\n            /* 4.demo3也开启绝对定位 越靠后的元素层级越高 所以此时demo3层级高于demo2 */\n            left: 80px;\n            top: 40px;\n            /* 6. 此时移动demo3的位置 此时demo3 的参照原点是html根元素 可知demo3 的层级高于demo2 */\n            z-index: 2;\n            /* 12.给demo3设置层级 此时demo3层级高于demo1 demo3的层级此时最高 但可知祖先的层级再高也不会遮挡后代元素 */\n        &#125;\n        .demo4&#123;\n            width: 100px;\n            height: 100px;\n            background-color: green;\n            /* 7.demo4 完全被包含在demo3中 */\n            position: absolute;\n            /* 8.demo4开启绝对定位 还没设置偏移量 所以位置不变 且demo4已没有元素 */\n            top: 0;\n            left: 0;\n            /* 9.此时demo4回到定位参照原点 可知此时demo4的包含块是demo3 */\n            top: 120px;\n            left: 140px;\n            /* 10.移动 demo4的位置 可知此时demo4 的层级高于demo3 此时层级为 demo1 &lt; demo2 &lt; demo3 &lt; demo4 */\n        &#125;\n &lt;div class=\"demo1\">1&lt;/div>\n    &lt;div class=\"demo2\">2&lt;/div>\n    &lt;div class=\"demo3\">3\n        &lt;div class=\"demo4\">4&lt;/div>\n    &lt;/div>","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"007-float布局","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/03/01/007-float布局/","content":"1.浮动布局（Float）浮动： 使用 float 属性设置 默认值为none； left 元素向左移动； right 元素向右移动；\n\tPS：一旦元素开启了float属性 此元素将脱离文档流 水平布局的等式便不再强制成立\n\t\t不占用文档流的元素浮动后 还在文档流的元素将自动补上\n\n .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 此时没开启float时 块级元素独占一行 盒子的可见框大小为 200px * 200px 浏览器将自动调整margin-right */\n            float: left;\n            /* 开启float 后 margin-right == 0 元素脱离文档流*/\n        &#125;\n        .demo1&#123;\n            width: 205px;\n            height: 205px;\n            background-color: green;\n            /* 此时demo1自动补上文档流中的demo离开的位置 此时demo1完全被浮动的demo遮挡 不可见 */\n        &#125;\n&lt;div class=\"demo\">&lt;/div>\n&lt;div class=\"demo1\">&lt;/div>\n\n浮动的特点： 按元素的浮动顺序排列 排在后面的浮动元素所在高度不会超过其前面浮动元素的所在高度\n                                排在前面的浮动元素越接近父元素的边界 但无法超出父元素\n2.浮动布局与文字浮动布局最早用来解决文字环绕问题 浮动元素不会遮住文字 文字会自动环绕在浮动元素周围\n.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 开启float后 div上浮 但不会遮住span中的文本 */\n        &#125;\n.content&#123;\n           \n            float: left;\n            /* 可知行内元素开启float 脱离文档流后 特点变得和块元素一样 */\n        &#125;\n\n &lt;span class=\"content\">Lorem ipsum dolor sit amet consectetur adipisicing elit. Molestiae enim officia dolore non dolor eligendi maxime et quis, accusamus laborum pariatur praesentium, saepe dolores ipsa est libero delectus itaque ullam!&lt;/span>\n &lt;div class=\"demo\">&lt;/div>\n\n.test1&#123;\n            background-color: #bfa;\n            /* 未开启float时 div默认独占一行 不主动设置宽高的时候 div宽度默认100% 高度由内容撑开 */\n            float: left;\n            /* 开启float 后 块级元素div 脱离文档流 此时元素的宽高默认由内容撑开 */\n        &#125;\n &lt;div class=\"test1\">\n        我是一个类名为 test1 的div\n        &lt;div class=\"test2\">我是在test1类里的div&lt;/div>\n  &lt;/div>\n\n\n脱离文档流的特点：\n                    块元素：\n                        1、块元素不在独占页面的一行\n                        2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开\n\n                    行内元素：\n                        行内元素脱离文档流以后会变成块元素，特点和块元素一样\n\n                    脱离文档流以后，不需要再区分块和行内了\n\nPPS ： float元素 默认宽高均由内容撑开 但也可以手动设置宽高 此时不再区分块元素和内联元素\n3.高度塌陷问题在普通布局中 外层的块级元素高度默认由内部的块级元素高度撑开 但若父元素内部的子元素开启浮动后 父元素高度将丢失\n\n        .box1&#123;\n            /* 1.不设置宽高 默认其由子元素撑开 */\n            /* 2.设置边框 */\n            border: 5px red solid;\n        &#125;\n        .box2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 3.此时子元素将父元素撑开 */\n            float: left;\n            /* 4.开启子元素浮动后 子元素脱离文档流 将无法撑开父元素高度 */\n        &#125;\n\t &lt;div class=\"box1\">\n        &lt;div class=\"box2\">&lt;/div>\n    &lt;/div>\n4.BFC（块级格式化环境）解决高度塌陷问题 BFC(Block Formatting Context) 块级格式化环境\n                    - BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC\n                        开启BFC该元素会变成一个独立的布局区域\n                    - 元素开启BFC后的特点：\n                        1.开启BFC的元素不会被浮动元素所覆盖\n                        2.开启BFC的元素子元素和父元素外边距不会重叠\n                        3.开启BFC的元素可以包含浮动的子元素\n\n                    - 可以通过一些特殊方式来开启元素的BFC：\n                        1、设置元素的浮动（不推荐）\n                        2、将元素设置为行内块元素（不推荐）\n                        3、将元素的overflow设置为一个非visible的值\n                            - 常用的方式 为元素设置 overflow:hidden 开启其BFC 以使其可以包含浮动元素\n .box1&#123;\n            /* 1.不设置宽高 默认其由子元素撑开 */\n            /* 2.设置边框 */\n            border: 5px red solid;\n            overflow: hidden;\n            /* 5.父元素开启 BFC 使其可以包含浮动元素 此时父元素不会被浮动元素遮挡*/\n            \n        &#125;\n        .box2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* 3.此时子元素将父元素撑开 */\n            float: left;\n            /* 4.开启子元素浮动后 子元素脱离文档流 将无法撑开父元素高度 浮动的子元素遮挡住了父元素*/\n        &#125;\n &lt;div class=\"box1\">\n        &lt;div class=\"box2\">&lt;/div>\n &lt;/div>\n\n\nBFC   解决外边距重叠问题\n .demo1&#123;\n            width: 400px;\n            height: 400px;\n            background-color: #bfa;\n            overflow: hidden;\n            /* 3.父元素开启BFC 父元素的外边距与子元素的外边距不重叠 实现子元素在父元素中下移 而父元素不下移 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            /* 1.此时子元素与父元素的外边距重叠 */\n            margin-top: 200px;\n            /* 2.此时父元素 与 子元素 一起下移*/\n        &#125;\n\n &lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n5.clear在普通的块级元素的垂直布局中 若文档流中有元素由于浮动脱离文档流后 该元素之后的文档流元素位置将发生移动 \n\t若不希望元素受到浮动的影响 可使用clear 属性清除浮动元素产生的影响\nclear\n                    - 作用：清除浮动元素对当前元素所产生的影响\n                    - 可选值：\n                        left 清除左侧浮动元素对当前元素的影响\n                        right 清除右侧浮动元素对当前元素的影响\n                        both 清除两侧中最大影响的那侧\n\n                    原理：\n                        设置清除浮动以后，浏览器会自动为元素添加一个上外边距，\n                            以使其位置不受其他元素的影响\n\n \t\t.demo1&#123;\n            width: 400px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 1.此时demo1开启浮动 文档流中其后的demo2 和 demo3 位置将发生移动 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            clear: left;\n            /* 2.demo2 开启clear ：left 清除其前面元素demo1 左浮带来的影响 */\n            float: right;\n            /* 3.此时demo2 开启右浮 demo3位置发生改变 */\n        &#125;\n        .demo3&#123;\n            width: 400px;\n            height: 100px;\n            background-color: green;\n            clear: right;\n            /* demo3 开启 clear ： right 消除demo2右浮的影响 */\n        &#125;\n&lt;div class=\"demo1\">1&lt;/div>\n&lt;div class=\"demo2\">2&lt;/div>\n&lt;div class=\"demo3\">3&lt;/div>\n6.clearfix解决高度塌陷.demo&#123;\n            /* 1.demo不设置宽高 默认其的高度由子元素撑开 此时默认width为100% */\n            border: 5px red solid;\n        &#125;\n        .test&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            float: left;\n            /* 2.开启子元素浮动 父元素高度塌陷 */\n        &#125;\n        .demo::after&#123;\n            content: '';\n            display: block;\n            clear: both;\n            /* 3.使用伪类选择器 在父元素的最后加入内容\n                    加入的内容为：\n                        1.''空字符串\n                        2.将这个字符串转换成block元素\n                        3.因为这个字符串元素在浮动元素test后面 使用clear 清除浮动影响\n                        使用clear相当于在这个字符串元素身上加上了 margin-top 高度为test的高度 所以此时父元素相当于被这个字符串元素撑开\n            \n            这里也不推荐使用block 推荐使用table\n            */\n        &#125;\n\n&lt;div class=\"demo\">\n\t &lt;div class=\"test\">&lt;/div>\n&lt;/div>\n\n\n最终的clearfix样式：\n/* clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 */\n        .clearfix::before,\n        .clearfix::after&#123;\n            content: '';\n            display: table;\n            clear: both;\n        &#125;\nPS：这里将字符串元素转换成table类型 是因为block不能将父子元素的外边距分离开\n\t而采用table可以实现外间距分离和高度塌陷\n\n\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"006-文档流-盒模型","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/27/006-文档流-盒模型/","content":"1.文档流（normal flow）​    在文档流中，内联元素默认从左到右流，遇到阻碍或者宽度不够的自动换行，继续按照从左到右的方式布局；块级元素独占一行，按照从上到下的方式布局。\n​    文档流是网页的基础 所创建的元素默认在文档流中排列\n元素在文档流中有什么特点：\n        - 块元素\n            - 块元素会在页面中独占一行(自上向下垂直排列)\n            - 默认宽度是父元素的全部（会把父元素撑满）\n            - 默认高度是被内容撑开（子元素）\n\n        - 行内元素\n            - 行内元素不会独占页面的一行，只占自身的大小\n            - 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素\n                则元素会换到第二行继续自左向右排列（书写习惯一致）\n            - 行内元素的默认宽度和高度都是被内容撑开\n2.盒模型（Box Model）盒模型 ： 可以将网页中的任何元素都看成一个矩形\n\t\t每一个盒子都由以下几个部分组成：\n\t\t1.内容区（content）\n\t\t2.内边距（padding）\n\t\t3.边框（border）\n\t\t4.外边距（margin）\n\n\t内容区 内边距 边框 都会影响可见盒模型的大小！！！\n\n\n\n1.内容区（content）内容区的大小由 width 和 height 两个属性设置\n/* 设置 demo 盒子的大小 */\n        .demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n        &#125;\n2.边框（border）要想在网页的盒子显示边框 必须要设置三个属性 border-width border-color border-style\n\t\tborder-width 和 border-color 有默认值 可省略不写（border-width默认3px border-color默认使用盒子的color）\n\t（1）border-width：可用来指定盒子四个方向的边框宽度 有默认值 3px\n\t\t\t\t值的情况：四个值 ----上 右 下 左 （顺时针）\n\t\t\t\t\t\t三个值 ---- 上 左右 下\n\t\t\t\t\t\t两个值 ---- 上下 左右\n\t\t\t\t\t\t一个值 ---- 上下左右\n\t\tborder-xxx-width： 可单独指定任意一边的宽度 xxx---top right  bottom  left\n\t（2）border-color: 可用来指定盒子边框的颜色 有默认值 使用color值\n\t\t\t\t使用规则与border-width 基本相同\n\t\t\t\t也有border-xxx-color可使用\n\t（3）border-style ： 用来指定边框的样式 没有默认值 none\n\t\t\t\tsolid 表示实线\n                  dotted 点状虚线\n                  dashed 虚线\n                  double 双线\n\t\t\t\nborder简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求\n\t\tborder: red 10px solid (三者顺序任意 需用空格间隔开)\n 除了border以外还有四个 border-xxx\n                       border-top\n                       border-right\n                       border-bottom\n                       border-left   用来单独设置每一条边框的具体样式\n\t\t\t也有 border-xxx-style 可使用\n\n \t\t/* 设置demo1 盒子的边框样式 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n            border-width: 10px;\n            border-color: red;\n            border-style: solid;\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n          /* 设置demo2 盒子的边框样式 */\n          .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n           border: 10px red solid;\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n         /* 设置demo3 盒子的边框样式 */\n         .demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 设置边框样式 */\n           border-style: solid;\n           \n           border-top-style: double;\n\n           /* 此时边框宽度使用默认值 边框颜色使用默认值 black */\n\n            /* 此时的盒子大小为 边框 + 内容 为 220 * 220  */\n        &#125;\n\n3.内边距（padding）​    内容区和边框之间的是内边距区 一共有四个方向的内边距 padding-top/right/bottom/left \n​    内边距的设置会影响盒子的大小  背景颜色会延伸到内边距区 内边距区不能单独设置背景颜色\npadding 内边距的简写属性同 border-width 相同 可同时指定四个方向的内边距大小\n\n /* 设置demo1 盒子的外边距 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n\n\n            /* 设置内边距 20px 此时盒子的高度为220px 盒子的背景颜色延伸到内边距区*/\n            /* padding-top: 20px; */\n            /* 内边距区不能单独设置背景颜色 */\n\n            /* 直接设置4个方向的内边距大小 */\n            padding: 10px 20px 30px 40px;\n\n            border: red 10px solid;\n        &#125;\n\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: black;\n            /* demo2盒子在demo1盒子中 大小与demo1的内容区大小一致 此时设置demo1 的内边距 直接影响demo1\n                盒子的整体大小\n                此时demo1的整体高度为240px\n            */\n\n\n\n            padding-top:10px;\n\n            /* 设置demo2 盒子的内边距不影响demo1的盒子大小 此时 设置demo2 内边距 padding-top 10px \n                此时demo2 整个盒子的高度变为210px\n                因为demo1此时边框距demo2 的边框还差 20px 所以两者边框未重叠\n            */\n\n            border: blue 10px solid;\n\n            /* 此时设置；两盒子的边框 demo2 的盒子高度达到230px 此时与demo1 的边框重合 \n                demo2 此时覆盖了demo1 的padding-bottom 30px    \n            */\n        &#125;\n\n\t&lt;div class=\"demo1\">\n        &lt;div class=\"demo2\">&lt;/div>\n    &lt;/div>\n\n\n盒子的可见框的大小，由内容区 内边距 和 边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算\n4.外边距（margin）​    外边距不会影响盒子可见框的大小 只影响盒子排放的位置 一共有四个方向的外边距\n                 margin-top\n                            - 上外边距，设置一个正值，元素会向下移动\n                 margin-right\n                            - 默认情况下设置margin-right不会产生任何效果\n                 margin-bottom\n                            - 下外边距，设置一个正值，其下边的元素会向下移动\n                 margin-left\n                            - 左外边距，设置一个正值，元素会向右移动\n                - margin也可以设置负值，如果是负值则元素会向相反的方向移动\n\n                - 元素在页面中是按照自左向右的顺序排列的，\n                    所以默认情况下如果我们设置的左和上外边距则会移动元素自身\n                    而设置下和右外边距会移动其他元素\n\n                - margin的简写属性\n                    margin 可以同时设置四个方向的外边距 ，用法和padding一样\n\n                - margin会影响到盒子实际占用空间\n\n\t\t/* 设置demo1盒子的外边距样式 */\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n\n            /* 设置外边框 */\n            border: 10px red solid;\n\n            /* 设置外边距大小 */\n            margin: 30px 20px 50px 100px;\n\n            /* 从效果可知此时盒子在设置margin-top 和 margin-left 时才会移动自身的位置 */\n        &#125;\n\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: gainsboro;\n\n            /* 调整demo1 的 margin-bottom 时 demo2 的位置会下移 */\n             margin: 10px;\n\n            /* 此处其实有垂直方向上的 两个盒子 的margin-bottom 和 margin-top 重叠 */\n        &#125;\n\n&lt;div class=\"demo1\">&lt;/div>\n&lt;div class=\"demo2\">&lt;/div>\n5.盒模型的水平布局块元素独占一行 元素在其父元素中的水平方向的位置由以下几个属性共同决定\n\t\t\t\t\t  margin-left\n                        border-left\n                        padding-left\n                        width\n                        padding-right\n                        border-right\n                        margin-right\n\t刚好是盒子从外到内在到内 从左到右的水平宽度之和\n一个元素在其父元素的水平布局中必须满足以下等式：\nmargin-left+border-left+padding-left+width+padding-right+border-right+margin-right = 其父元素内容区的宽度 （必须满足）\n\n若以上等式右边之和小于父元素宽度 称为 过度约束 此时等式会自动调整\n\t\t调整原则：1.这七个值中没有为 auto 的值的时候 浏览器自动调整margin-right值使等式成立\n\t\t\t\t2.如果 width margin-left margin-right 三个值中有为 auto 值的 浏览器会自动优先调整auto使等式成立\n\t\t\t\t\t如果 width 和 margin-left/right 均设置为auto 则宽度会默认调整到最大 margin为0\n\t\t\t\t\t如果只有连个外边距为auto width固定值 此时会自动调整到margin-left=margin-right\n\t\t\t\t\t\t\t实现元素在父元素中居中\n\n \t.demo&#123;\n            width: 1000px;\n            height: 400px;\n            background-color: #bfa;\n        &#125;\n        .demo2&#123;\n            width: 300px;\n            height: 200px;\n            background-color: yellowgreen;\n            /* 此时demo2的宽度300px 就算小于其父元素的1000px\n                两个demo2共同排放在其父元素demo中 也不可能排放在同一排\n\n                此时 过度约束 成立 没有设置auto值 浏览器调整 demo2的margin-right 为 700px 使等式成立 \n\n                此时demo2的宽度总和占满以父元素 所以 demo3 自动被挤出父元素换行\n            */\n        &#125;\n        .demo3&#123;\n            width: 300px;\n            height: 200px;\n            background-color: yellow;\n\n        &#125;\n        .demo4&#123;\n            width: 1000px;\n            height: 400px;\n            background-color: #bfa;\n        &#125;\n        .demo5&#123;\n            /* width 和 margin 均为 auto 此时width为最大 margin为0 */\n            width: auto;\n            margin: auto;\n            height: 200px;\n            background-color: yellowgreen;\n        &#125;\n        .demo6&#123;\n            /* width 为 400px ， margin 均为 auto 此时；水平两边margin值相等 实现元素在父元素中居中 */\n            width: 400px;\n            margin: auto;\n            height: 200px;\n            background-color: yellowgreen;\n        &#125;\n &lt;div class=\"demo\">\n        &lt;div class=\"demo2\">&lt;/div>\n        &lt;div class=\"demo3\">&lt;/div>\n    &lt;/div>\n\n    &lt;hr>\n\n    &lt;div class=\"demo4\">\n        &lt;div class=\"demo5\">&lt;/div>\n        &lt;div class=\"demo6\">&lt;/div>\n    &lt;/div>\n6.盒模型的垂直布局默认情况下父元素的高度被内容撑开\n .demo&#123;\n            width: 500px;\n            background-color: #bfa;\n            /* 父元素不设置高度 */\n        &#125;\n        .test&#123;\n            width: 200px;\n            height: 200px;\n            background-color: green;\n            /* 子元素高度设置为200px 此时父元素的高度被撑开 为200px */\n        &#125;\n&lt;div class=\"demo\">\n        &lt;div class=\"test\">&lt;/div>\n    &lt;/div>\n\n子元素在父元素的内容区中排列 如果子元素大小超过父元素 称子元素从父元素中 溢出（overflow）\n\t使用 overflow 属性处理溢出的子元素\n\n\t\t\t\t可选值：\n                        visible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示\n                        hidden 溢出内容将会被裁剪不会显示\n                        scroll 生成两个滚动条，通过滚动条来查看完整的内容\n                        auto 根据需要生成滚动条\n .demo1&#123;\n            width: 500px;\n            height: 200px;\n            background-color: #bfa;\n           \n\n            /* overflow属性应写在父元素中 */\n             /* overflow: visible;  */\n            /* overflow默认值为 visible 即显示溢出不作处理 */\n            /* overflow: hidden; */\n            /* overflow: scroll; */\n            /* overflow: auto; */\n            \n        &#125;\n        .test1&#123;\n            width: 200px;\n            height: 400px;\n            background-color: yellowgreen;\n            /* 此时子元素高度超过父元素 从中溢出 */\n        &#125;\n&lt;div class=\"demo1\">\n        &lt;div class=\"test1\">&lt;/div>\n    &lt;/div>\n\n还有 \t\t\toverflow-x: 调整水平溢出\n                overflow-y:调整垂直溢出\n7.外边距的折叠盒子的相邻垂直方向外边距（margin）会发生重叠现象\n\t1.兄弟元素 间的相邻垂直外边距取两者之间最大值（当两者都为正值时）\n\t\t相邻两外边距一正一负时取两者之和\n\t\t若两外边距都是负值时取绝对值大的\n\n\t\t.demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            margin-bottom: 50px;\n\n            /* 将demo1 的margin-bottom 设置为 负值 */\n            margin-bottom: -30px;\n\n\n            /* 此时两盒子的垂直外边距均为负值 取demo1 的外边距 -30 px （绝对值较大） */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: yellowgreen;\n\n            /* 此时demo1的margin-bottom值为50px\n                设置demo2 的margin-top 为50px\n            */\n            margin-top: 50px;\n            /* 可知发生外边距折叠 此时盒子布局和只设置demo1 margin-bottom 50px 效果一致 */\n\n            margin-top: 100px;\n            /* 若将demo2的 margin-top 设置为100 px 两盒子间的间隔 取demo2\n                    外边距（100px较大）\n            */\n\n            margin-top: -20px;\n            /* 若将demo2 的margin-top 值设置为 -20 px 此时两盒子的间隔为 50px-20px=30px 取两者之和 */\n        &#125;\n\n&lt;div class=\"demo1\">&lt;/div>\n&lt;div class=\"demo2\">&lt;/div>\n\n实际开发中 兄弟间的边距折叠现象是有利的 不用去处理\n\n\t2.父子元素相邻外边距\n\t\t\t子元素的外边距会传递给父元素\n\t\t\t父子外边距折叠会影响页面布局 需要处理\n\n        /* 父子间元素 */\n\n        .demo3&#123;\n            width: 500px;\n            height: 500px;\n            background-color: #bfa;\n            /* 设置父元素的边框 */\n            border: 2px red solid;\n            /* 给父元素设置边框后 就将父子的边框分离开来 此时 子元素的外边距不会传递给父元素 */\n        &#125;\n        .demo4&#123;\n             border: 2px red solid;\n            /* 只设置子元素的边框无法分离父子元素的边框 需要在父元素处设置边框 */\n            width: 250px;\n            height: 250px;\n            background-color: yellowgreen;\n\n            /* 设置子元素的外边距 */\n            margin-top: 50px;\n            /* 可知此时子元素的外边距与父元素的外边距重叠 设置子元素外边距时父元素的外边距也一起变化 */           \n        &#125;\n \t&lt;div class=\"demo3\">\n        &lt;div class=\"demo4\">&lt;/div>\n    &lt;/div>\n8.行内元素的盒模型行内元素不支持设置宽度和高度\n\t行内元素可以设置padding border margin 都是垂直方向均无效 不影响布局\n\t\t.demo1&#123;\n            width: 200px;\n            height: 200px;\n            /* 设置高度和宽度均无效 */\n            background-color: #bfa;\n            margin-top: 1000px;\n            /* 设置垂直外边距无效 */\n            margin-left: 100px;\n            margin-right: 100px;\n            /* 设置水平外边距有效 */\n        &#125;\n        .demo2&#123;\n            width: 200px;\n            height: 200px;\n            /* 设置高度和宽度均无效 */\n            background-color: yellowgreen;\n            margin-top: 1000px;\n            /* 设置垂直外边距无效 */\n            margin-left: 100px;\n            margin-right: 100px;\n            /* 设置水平外边距有效 相邻水平间距取两者之和*/\n        &#125;\n &lt;span class=\"demo1\">我是类名为demo1 的span&lt;/span>\n &lt;span class=\"demo2\">我是类名为demo2 的span&lt;/span>\n\n行内元素的两个属性：\n\t（1）display 用来设置元素显示的类型\n\t\t\t\t\t  inline 将元素设置为行内元素\n                        block 将元素设置为块元素\n                        inline-block 将元素设置为行内块元素 \n                                行内块，既可以设置宽度和高度又不会独占一行\n                        table 将元素设置为一个表格\n                        none 元素不在页面中显示\n\t（2）visibility 用来设置元素的显示状态\n   \t\t\t\t\t  visible 默认值，元素在页面中正常显示\n                        hidden 元素在页面中隐藏 不显示，但是依然占据页面的位置\t\n\n  .box1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            display: inline;\n            /* div变成行内元素后 宽度和高度设置将失效 */\n        &#125;\n  &lt;div class=\"box1\">我是一个变成行内元素的div&lt;/div>\n  &lt;div class=\"box1\">我是一个变成行内元素的div&lt;/div>\n\n.test1&#123;\n            background-color: #bfa;\n            display: block;\n            /* 将span的display属性设置为 block span将变为块元素 独占一行 */\n        &#125;\n .test2&#123;\n            background-color: palegoldenrod;\n            display: none;\n            /* display 属性设置为 none 元素将隐藏 */\n        &#125;\n .test3&#123;\n            background-color: pink;\n            visibility: hidden;\n            /* visibility属性设置为 hidden 将元素隐藏 但还是在网页占据位置\n                display ： none 元素不再网页中占据位置空间\n            */\n        &#125;\n\t&lt;span class=\"test1\">我是类名为 test1 的span&lt;/span>\n    &lt;span class=\"test2\">我是类名为 test2 的span&lt;/span>\n    &lt;span class=\"test3\">我是类名为 test3 的span&lt;/span>\n9.盒子的尺寸默认情况下 盒子可见框有 content padding border 三者决定\n\tbox-sizing 用来设置盒子尺寸的计算方式（即设置 width 和 height 的作用）\n\t\t可选值：content-box 为默认值 此时设置的 width 和height 均为content大小\n\t\t\t\tborder-box 此时width 和 height 设置整个盒子的可见框大小\n\t\t.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            border: 10px red solid;\n            box-sizing: content-box;\n            /* 默认值 此时width 和 height 为content 大小 */\n        &#125;\n        .demo1&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            border: 10px red solid;\n            box-sizing: border-box;\n            /* 此时width 和 height 决定整个盒子可见框大小 */\n        &#125;\n10.轮廓和圆角（1）轮廓：outline 用来设置元素的轮廓线 用法和border一致\n\t\t\t轮廓和边框不同的是轮廓不会影响可见框的大小\n.demo&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* border: 10px red solid; */\n            outline: 10px red solid;\n            /* outline 属性不影响页面布局 \n                outline会遮住下面的行内元素 但是border不会\n            */ \n        &#125;\n&lt;div class=\"demo\">&lt;/div>\n    &lt;span>hello&lt;/span>\n\n（2）阴影：box-shadow 用来设置元素的阴影效果 阴影不会影响页面布局\n\t\t\t   第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动\n                第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动\n                第三个值 阴影的模糊半径\n                第四个值 阴影的颜色\n \t.demo2&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n           box-shadow: 20px 5px 30px rgba(0, 0, 0, .4);\n        &#125;\n（3）圆角： border-radius 用来设置圆角 圆角设置的圆的半径大小\n\t\t\t/* border-top-left-radius:  */\n            /* border-top-right-radius */\n            /* border-bottom-left-radius:  */\n            /* border-bottom-right-radius:  */\n\t border-radius 可以分别指定四个角的圆角\n                    四个值 左上 右上 右下 左下\n                    三个值 左上 右上/左下 右下 \n                    两个个值 左上/右下 右上/左下  \n\t.demo3&#123;\n            width: 200px;\n            height: 200px;\n            background-color: #bfa;\n            /* border-radius: 30px; */\n            /* 50% 为圆形 */\n            /* border-radius: 50%; */\n\n            border-radius: 10px / 55px;\n            /* 设置椭圆角 第一个值为 垂直半轴 第二个值为 水平半轴*/\n        &#125;\n3.练习line-height 值设置为与父元素的height相等时 此时可让子元素中的字体在父元素中垂直居中\ntext-decoration ：none 为去除超链接下划线样式\n\npadding的设置增加的大小属于盒子 margin的设置增加的大小不属于盒子\ndisplay：inline-block 将元素转换成行内块元素\n重温伪元素选择器 ::before&#123;&#125;\n\n设计页面时先考虑整体布局 先实现整体布局效果 再进一步修改每处细节样式\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"005-样式继承-选择器权重-单位-颜色","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/27/005-样式继承-选择器权重-单位-颜色/","content":"1.样式的继承​    为一个元素设置的样式会自动应用到他的所有后代子元素身上\n​    注意：并不是所有样式都会继承，如 背景，布局相关样式都不会继承\n.box&#123;\n           /* box中的颜色样式会自动继承到box的所有子类身上 */\n           color: blue;\n\n           width: 200px;\n           height: 200px;\n\n           /* 背景颜色不会继承到后代中 但是后代子元素的背景默认为透明 所以看上去同父元素背景颜色一致*/\n           background-color: gray;\n       &#125;\n\n       /* 选择box中的所有span字元素 */\n       div > span, div > p >span&#123;\n           /* background-color: red; */\n           /* 调整透明度 */\n           opacity: .5; \n       &#125;\n2.选择器的权重内联样式        1,0,0,0\nid选择器        0,1,0,0\n类和伪类选择器   0,0,1,0\n元素选择器       0,0,0,1\n通配选择器       0,0,0,0\n继承的样式       没有优先级\n\n比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的）,\n      选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器\n                如果优先级计算后相同，此时则优先使用靠下的样式\n\n可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式，\n       注意：在开发中这个玩意一定要慎用！\n\n /* 选择box中的第一个p元素设置样式 */\n         .box :first-child&#123;\n             /* 这里的第一个p元素不生效 但是第二个p元素的span元素样式生效 因为span是p标签的中的第一个子元素 */\n             color: red;\n         &#125;\n         /* 选中id为 demo的span标签 */\n         #demo&#123;\n             /* id选择器优先级高于类选择器和伪类选择器 */\n             color: aqua;\n         &#125;\n\n&lt;div class=\"box\" >\n        我是一个类名叫box的div\n        &lt;!-- p元素中的内联样式优先级最高 -->\n        &lt;p style=\"color: skyblue;\">\n            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deserunt repellat vero, eveniet dolore ducimus temporibus iure inventore. Nihil ea blanditiis delectus repellat fuga corrupti? Minus voluptate commodi asperiores aspernatur quam!\n        &lt;/p>\n\n        &lt;p>\n            &lt;span id=\"demo\">我是p元素中的span&lt;/span>\n            &lt;br>&lt;br>\n            &lt;span>我是p元素中的第二个span元素&lt;/span>\n        &lt;/p>\n    &lt;/div>\n3.像素单位（1）像素 -- px\n（2）百分比 -- %\n（3）em -- 相对于以元素的字体大小来计算 默认字体大小是16px\n\t\t\t1em = 1font-size  em根据所在元素字体大小计算而改变\n（4）rem -- 根据根元素（root -- html）的字体大小来改变\n\n.demo&#123;\n            /* 设计一个box */\n            width: 400px;\n            height: 400px;\n            background-color: green;\n        &#125;\n        .test&#123;\n            /* 这是在demo里的的一个div 大小根据父容器大小改变 */\n            width:50%;\n            height: 50%;\n            background-color: bisque;\n            /* 改变元素字体大小 */\n            font-size: 12px;\n        &#125;\n        .t1&#123;\n            /* em根据所在元素字体大小改变 */\n            font-size: 30px;\n            width: 5em;\n            height: 5em;\n            background-color: blue;\n        &#125;\n        .t2&#123;\n            /* rem根据body根元素的字体大小改变 */\n            width: 5rem;\n            height: 5rem;\n            background-color: red;\n        &#125;\n        html&#123;\n            font-size: 25px;\n        &#125;\n  &lt;div class=\"demo\">\n        &lt;div class=\"test\">\n            &lt;div class=\"t1\">\n                &lt;div class=\"t2\">&lt;/div>\n            &lt;/div>\n        &lt;/div>\n    &lt;/div>\n4.颜色颜色单位：\n                   在CSS中可以直接使用颜色名来设置各种颜色\n                       比如：red、orange、yellow、blue、green ... ...\n                       但是在css中直接使用颜色名是非常的不方便\n\n                   RGB值：\n                       - RGB通过三种颜色的不同浓度来调配出不同的颜色\n                       - R red，G green ，B blue\n                       - 每一种颜色的范围在 0 - 255 (0% - 100%) 之间\n                       - 语法：RGB(红色,绿色,蓝色)\n\n                   RGBA:\n                       - 就是在rgb的基础上增加了一个a表示不透明度\n                       - 需要四个值，前三个和rgb一样，第四个表示不透明度\n                           1表示完全不透明   0表示完全透明  .5半透明\n\n                   十六进制的RGB值：\n                       - 语法：#红色绿色蓝色\n                       - 颜色浓度通过 00-ff\n                       - 如果颜色两位两位重复可以进行简写  \n                           #aabbcc --> #abc\n                   \n                   HSL值 HSLA值\n                       H 色相(0 - 360)\n                       S 饱和度，颜色的浓度 0% - 100%\n                       L 亮度，颜色的亮度 0% - 100%\n\t\t\t\t  A 透明度 0% - 100%\ndiv&#123;\n           margin-right: 20px;\n       &#125;\n       .demo1&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           background-color: red;\n       &#125;\n       .demo2&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 三个值依次表示 红 黄 蓝 */\n           background-color: rgb(255, 0, 0);\n       &#125;\n       .demo3&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 四个值依次表示 红 黄 蓝 透明度（0~1） */\n           background-color: rgba(255, 0, 0, 1);\n       &#125;\n       .demo4&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用16进制表示 红黄蓝依次使用两个16进制数表示 当每个颜色的两位数字相同时可以采用只写一位的简写 */\n           background-color: #f00;\n       &#125;\n       .demo5&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用 hsl 表示颜色 时三个值依次表示 色相 饱和度 亮度 hsl中的色相取值在0~360 可看成一个圆盘 0和360都是红色\n               饱和度 和 亮度 的取值在0%~100%\n           */\n           background-color: hsl(360, 100%, 50%);\n       &#125;\n       .demo6&#123;\n           float: left;\n           width: 100px;\n           height: 100px;\n           /* 使用 hsla 表示颜色 时四个值依次表示 色相 饱和度 亮度 透明度 hsl中的色相取值在0~360 可看成一个圆盘 0和360都是红色\n               饱和度 和 亮度 透明度 的取值在0%~100%\n               透明度 0% 表示不透明 此时元素不显示\n           */\n           background-color: hsl(360, 100%, 50%, 100%);\n\n      &lt;div class=\"demo0\">\n       &lt;div class=\"demo1\">&lt;/div>\n       &lt;div class=\"demo2\">&lt;/div>\n       &lt;div class=\"demo3\">&lt;/div>\n       &lt;div class=\"demo4\">&lt;/div>\n       &lt;div class=\"demo5\">&lt;/div>\n       &lt;div class=\"demo6\">&lt;/div>\n   \t&lt;/div>     \n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"004-CSS选择器","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/26/004-CSS选择器/","content":"1.CSS语法简介&lt;!--\n\t方式1 内联样式/行内样式：在标签内通过style属性设置元素样式\n\t\t内联样式：属性:值; 使用 ; 来间割属性\n\t\t该方式不能实现样式复用\n-->\n&lt;p style=\"color:green; font-size:20px;\">\n    这里是一段p元素文字\n&lt;/p>\n\n!!!注意在实际开发中不要轻易使用内联样式\n\n&lt;!-- \n\t方式2 内部样式表：在head标签内写style标签\n\t\t\t语法 样式选择器&#123;color: red;&#125;   \n\t方式3 外部样式表：通过引入外部css文件\n\t\t\t在head中通过link标签引入\n-->\n&lt;link rel=\"stylesheet\" href=\"这是css文件路径\">\n\n在实际开发中推荐使用方式3 css文件可实现复用\n\ncss文件中的注释符号为  /*  这是注释 */\n2.CSS选择器1.常用选择器（1）元素选择器：根据标签名选中指定元素 页面中所有该元素的标签都有效\n\t语法：标签名&#123;&#125;  如p&#123;&#125;，h1&#123;&#125; ，h2&#123;&#125; body&#123;&#125;\n（2）id选择器： 根据标签的id选中元素\n\t语法：#id名&#123;&#125; 如 #box&#123;&#125;， #big&#123;&#125;\n\t\t使用id选择器时 不提倡id重复 即id选择器只选中一个标签元素\n\t\t\t同id名是 目前的id选择器都将生效 效果和类选择器相同 但不推荐使用相同id\n（3）类选择器：使用类名选择一组相同类名的元素\n\t语法：.className&#123;&#125;,如 .类名&#123;&#125; \n（4）通配选择器：选中页面所有元素\n\t语法：*&#123;&#125; \n\n\np&#123;\n    这是元素选择器\n    color: red;\n&#125;\n#red&#123;\n     这是id选择器\n     color: red;\n&#125;\n.box&#123;\n    这是类选择器\n    color: red;\n&#125;\n*&#123;\n    这是通配选择器\n    效果和元素选择器 body&#123;&#125; 相同 选中所有元素\n&#125;\n2.复合选择器（1）交集选择器：选中同时复合多个条件的元素\n\t语法：选择器1选择器2选择器3&#123;&#125;  \n\t\t交集选择器中如果有元素选择器 需使用元素选择器开头\ndiv.box&#123;\n    这是一个交集选择器 选择一个类名为box的div元素\n    color:red;\n&#125;\n\n\t（2）并集选择器：同时选择多个选择器对应的元素\n     语法：选择器1,选择器2,选择器3&#123;&#125;\ndiv,span,h1&#123;\n    这是一个并集选择器 同时选中div，span，h1 三种标签\n    color: red;\n&#125;\n3.关系选择器父元素\n          - 直接包含子元素的元素叫做父元素\n      子元素\n          - 直接被父元素包含的元素是子元素\n      祖先元素\n          - 直接或间接包含后代元素的元素叫做祖先元素\n          - 一个元素的父元素也是它的祖先元素\n      后代元素\n          - 直接或间接被祖先元素包含的元素叫做后代元素\n          - 子元素也是后代元素\n      兄弟元素\n          - 拥有相同父元素的元素是兄弟元素\n1.子元素选择器（1）子元素选择器：选中指定父元素中的指定子元素\n\t\t\t语法：父元素 > 子元素\ndiv.box > span &#123;\n    /* 选中类名为box的div中的所有span子元素 只选中子元素*/\n    color: red;span &#123;\n            color: aqua;\n            /* 1.给所有span元素设置颜色 */\n            &#125;\n            .demo1 > span&#123;\n            color: red;\n            /* 2.选择demo1 中下属的直接子元素（不包括子元素的后代） 可见只有demo1\n                下的子元素才有效果 demo1的孙子元素及其以后未被选中！\n            */\n          &#125;\n&#125;\n\n&lt;div class=\"demo1\">\n        &lt;span>Span #1, in the div.\n            &lt;span>Span #2, in the span that's in the div.&lt;/span>\n          &lt;/span>\n          &lt;span>我是demo中的第三个span子元素&lt;/span>\n    &lt;/div>\n2.后代元素选择器(2)后代元素选择器：选中指定元素中的后代元素\n\t\t\t语法：祖先 后代\n \t\tspan &#123;\n            color: aqua;\n            /* 1.给所有span元素设置颜色 */\n            &#125;\n\t\t em&#123;\n                color: aqua;\n        \t&#125;\n.demo2 span&#123;\n              color: red;\n              /* 可知此时选中了demo2中的所有span后代元素 包括demo2子元素的后代 \n                这一点适合子元素选择器不一样的\n                demo2中的后代em元素未被选中\n              */\n          &#125;\n&lt;div class=\"demo2\">\n        &lt;span>\n            深情隐现眉宇间，他人已知我相思。 --阴阳师\n            &lt;span>\n                深情隐现眉宇间，他人已知我相思。 --阴阳师\n            &lt;/span>\n        &lt;/span>\n        &lt;span>\n            深情隐现眉宇间，他人已知我相思。 --阴阳师\n            &lt;span>\n                深情隐现眉宇间，他人已知我相思。 --阴阳师\n                &lt;em>\n                    深情隐现眉宇间，他人已知我相思。 --阴阳师\n                &lt;/em>\n            &lt;/span>\n        &lt;/span>\n    &lt;/div>\n3.下一个兄弟元素选择器(3)选择下一个兄弟\n\t\t\t语法:前一个 + 下一个\n  .demo3 > :nth-child(2) + li&#123;\n              /* 选中demo3 的所有后代元素中的第2个后代 的下一个元素 */\n              color: red;\n              /* 可知兄弟选择器只选中第三个li子元素 即兄弟元素选择器选择指定的\n                    元素的下一个元素\n              */\n          &#125;\n&lt;ul class=\"demo3\">\n        &lt;li>南风知我意，吹梦到西洲。 --西洲曲&lt;/li>\n        &lt;li>南风知我意，吹梦到西洲。 --西洲曲&lt;/li>\n        &lt;li>南风知我意，吹梦到西洲。 --西洲曲&lt;/li>\n        &lt;li>南风知我意，吹梦到西洲。 --西洲曲&lt;/li>\n    &lt;/ul>\n4.所有兄弟元素选择器（4）选择下边所有兄弟\n\t\t\t语法：兄 ~ 弟\n #one ~ span&#123;\n              color: red;\n              /* 此时选中了 id 名为 one 的span元素后面同级的span兄弟（不包括兄弟的后代）   */\n          &#125;\n&lt;div class=\"demo4\">\n        &lt;span id=\"one\">曾经沧海难为水，除却巫山不是云。 --离思五首·其四&lt;/span>&lt;br>\n        &lt;span id=\"two\">曾经沧海难为水，除却巫山不是云。 --离思五首·其四\n            &lt;span id=\"three\">曾经沧海难为水，除却巫山不是云。 --离思五首·其四&lt;/span>\n        &lt;/span>\n        &lt;br>\n        &lt;span id=\"four\">曾经沧海难为水，除却巫山不是云。 --离思五首·其四&lt;/span>\n    &lt;/div>\n4.属性选择器属性选择器：选择指定属性的标签元素\n\t\t语法：（1）[属性名=属性值] 选择含有指定属性和指定元素值的标签\n如 p[name=\"box\"]&#123;\n    选择name值等于“box”的p标签\n&#125;\n\t\t（2）选择属性值以指定值开头的元素  [属性名^=属性名]\n如 p[name ^= \"box\"]&#123;\n    选择name值以“box”开头的p标签\n&#125;\n\t\t（3）选择属性值以指定值结尾的元素  [属性名 $= 属性值]\n如p[name $= \"box\"]&#123;\n    选择name值以“box”结尾的元素的p标签\n&#125;\n\t\t（4）选择属性值中含有某值的元素  [属性名 *= 属性值]\n如 p[name *= \"box\"]&#123;\n    选择name值中含有“box”的p标签\n&#125;\n5.伪类选择器伪类选择器：伪类 （不存在的类 特殊的类 伪类用来描述一个元素的特殊状态）\n\t\t\t\t\t\t如：第一个子元素 被点击的子元素等\n\t\t\t\t\t\t语法： : 开头\n\t\t\t   :first-child 第一个子元素\n                :last-child 最后一个子元素\n                :nth-child() 选中第n个子元素\n                    特殊值：\n                        n 第n个 n的范围0到正无穷\n                        2n 或 even 表示选中偶数位的元素\n                        2n+1 或 odd 表示选中奇数位的元素\n\n                    - 以上这些伪类都是根据所有的子元素进行排序\n\n                :first-of-type\n                :last-of-type\n                :nth-of-type()\n                    - 这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序\n\n            - :not() 否定伪类\n                - 将符合条件的元素从选择器中去除\n\n /* 使用伪类选择器 选择 类名为demo 的ul 中的第一个li子元素 */\n        .demo > li:first-child&#123;\n            /* 这里选择第一个子元素 */\n            color: yellow;\n            font-size: 20px;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的最后一个li子元素 */\n        .demo > li:last-child&#123;\n            /* 这里选择最后一个子元素 */\n            color: skyblue;\n            font-size: 50px;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的第奇数个li子元素 */\n        .demo > li:nth-child(2n+1)&#123;\n            /* 这里选择第奇数个子元素 */\n            background-color: red;\n        &#125;\n          /* 使用伪类选择器 选择 类名为demo 的ul 中的第偶数个li子元素 */\n          .demo > li:nth-child(2n)&#123;\n            /* 这里选择第偶数个子元素 */\n            background-color: gray;\n        &#125;\n          /* 使用伪类选择器 选择 类名为demo 的ul 中的第一个span子元素 */\n          .demo > span:first-of-type&#123;\n            background-color: orange;\n        &#125;\n        /* 使用伪类选择器 选择 类名为demo 的ul 中的除最后一个span子元素 */\n        .demo > span:not(:last-child)&#123;\n           font-size: 30px;\n        &#125;\n\nexample： \n.first span:nth-child(2n+1)&#123;\n    /* 此时选择的是first类中的所有后代中 排在奇数位的span元素 \n    \t即如果此时first类中第三个直接子元素不是span类型的元素则不被选中\n    也就是所除了span元素外的后代元素也参与排列\n    */\n&#125;\n\n.first span:nth-of-type(2n+1)&#123;\n    /* 此时选中的是first类中的所有后代 排在奇数位的span元素\n    \t但是此时只有后代元素是span类型才参与排列\n    */\n&#125;\n\ndiv:only-child&#123;\n    /* 此时选择只有一个孩子元素的div中的孩子 */\n&#125;\n\nmain:only-of-type&#123;\n    /* 此时选中mian标签中 所有没有同类型兄弟的后代元素 */\n&#125;\n6.元素的伪类元素的伪类： 用于指定特殊元素 \n\t\t\t如 a标签的 link visited（这两个只有a标签能用） hover active\n  \t\t/* \n            :link 用来表示没访问过的链接（正常的链接）\n         */\n        a:link&#123;\n            color: red; \n        &#125;\n        /* \n            :visited 用来表示访问过的链接\n            由于隐私的原因，所以visited这个伪类只能修改链接的颜色\n        */\n        a:visited&#123;\n            color: orange; \n            /* font-size: 50px;   */\n        &#125;\n\n         button:hover&#123;\n             /* 点击按钮时按钮颜色变红 */\n             color: red;\n         &#125;\n\n         button:active&#123;\n             /* 点击按钮是按钮变大 */\n             width: 100px;\n         &#125;\n\n7.伪元素选择器伪元素选择器：\t表示页面中不真实存在的元素（特殊位置）\n\t\t\t\t伪元素 使用 :: 开头\n\t            ::first-letter 表示第一个字母\n                ::first-line 表示第一行\n                ::selection 表示选中的内容\n                ::before 元素的开始 \n                ::after 元素的最后\n                    - before 和 after 必须结合content属性来使用\n/* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的第一个字母 */\n        #demo::first-letter&#123;\n            /* 选中文本段第一个字母 */\n            font-size: 30px;\n            color: blue;\n        &#125;\n\n        /* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的开始 */\n        #demo::before&#123;\n            /* 选中文本段的起始 */\n            content: '##';\n        &#125;\n         /* 使用伪元素选择器 选择 id 为 demo 的p标签内文本段的末尾 */\n         #demo::after&#123;\n            /* 选中文本段的末尾 */\n            content: '##';\n        &#125;\n\n\t使用 ::before 和 ::after 时 加入的文本content也算第一个字母！！！","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"003-列表-超链接-图片-音视频","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/25/003-列表-超链接-图片-音视频/","content":"1.列表​    html中分为三种列表：有序，无序，定义列表\n&lt;!-- 无序列表 unordered list-->\n&lt;ul>\n    &lt;li>序号1&lt;/li>\n    &lt;li>序号2&lt;/li>\n    &lt;li>序号3&lt;/li>\n&lt;/ul>\n\n\n&lt;!-- 有序列表 ordered list-->\n&lt;ol>\n    &lt;li>无序1&lt;/li>\n    &lt;li>无序1&lt;/li>\n    &lt;li>无序1&lt;/li>\n&lt;/ol>\n\n&lt;!-- 定义列表 description list\n\t使用dl创建定义列表 使用dt表示定义名 dd对定义进行说明\n-->\n&lt;dl>\n    &lt;dt>定义名&lt;/dt>\n    &lt;dd>解释说明&lt;/dd>\n&lt;/dl>\n日常中多使用无序列表 ul标签 在li标签中可嵌套使用 ul标签 实现列表嵌套\n2.超链接​    使用超链接标签可是将页面跳转到指定页面 或者是当前页面的指定位置\n&lt;!-- \n\t使用a标签 \n\t\t使用属性href 指定跳转的目标 目标可以是指定网站 也可以是服务器内部页面（使用相对路径）\n\t\t超链接是一个行内元素 在a标签内可以嵌套除了自身外的所有标签\n-->\n&lt;a href=\"http://www.baidu.com\">这是一个超链接&lt;/a>\n\n&lt;!--\n\thref 的target属性：\n\t\t_self: 超链接的默认属性 不写也可 效果为在当前网页打开链接\n\t\t_blank: 保留当前页面 在新的页面打开链接\n\t\n\thref的几个常用值：\n\t\t1.javascript:;  -> 此时点击链接什么都不会发生\n\t\t2.#  -> 此时点击链接会自动回到网页顶部\n\t\t3.标签id -> 此时点击链接将跳转到指定id标签的位置 使用标签id时 尽量不要重复id\n-->\n&lt;a href=\"www.baidu.com\" target=\"_blank\">点我在新页面打开链接&lt;/a>\n\n3.图片标签​    使用 img 标签向当前页面引入图片资源（外部图片）img 标签属于替换元素（介于块元素和内联元素之间）\n​    img 标签 默认不会独占一行\n&lt;!-- \n\timg是自结束标签\n\timg 的属性：\n\t\t1.src：用于引入外部图片路径\n\t\t2.alt: 图片的描述 当浏览器加载不到图片时显示alt 搜索引擎使用alt来识别图片\n\t\t3.width: 图片的宽度（px）\n\t\t  height: 图片的高度 当图片的宽度或高度变化时 图片将按等比例缩放图片宽高\n-->\n&lt;img src=\"在这里引入图片路径\" width=\"200px/可不带单位\" alt=\"这是图片的描述\">\n\nsrc的资源路径可以是base64编码字符串\n\n4.内联框架​    使用 iframe 标签 用于在该页面引入其他页面 iframe 元素属于行内元素\n&lt;!--\n\tiframe 属性：\n\t\t1.src：用于引入网页路径\n\t\t2.frameborder：指定内联框架的边框\n-->\n&lt;iframe src=\"https://www.bilibili.com\" width=\"1000\" height=\"600\" frameborder=\"1\">不支持iframe时将显示这行字！&lt;/iframe>\n5.音视频​    使用 audio 标签在页面引用外部音频文件\n&lt;!--\n        属性：\n            controls 是否允许用户控制播放 默认情况下不允许用户自己控制播放停止\n            autoplay 音频文件是否自动播放\n                - 如果设置了autoplay 则音乐在打开页面时会自动播放\n                    但是目前来讲大部分浏览器都不会自动对音乐进行播放 \n            loop 音乐是否循环播放\n\t\t\n\t\t还可通过在标签内使用source标签引入音频资源 这样的好处是可以是浏览器兼容解析合适的文件\n\t\t\t还可以在这里写入浏览器不支持audio标签的提示\n\t\tembed标签为IE8以下的浏览器所解析使用\n\n\t\tsource 和 embed 标签均为自结束标签！ \n\t\tembed 标签内 的type 为map 匹配 文件类型（audio/video）/文件后缀（mp3/mp4）\n-->\n&lt;audio src=\"./source/这里是路径.mp3\" controls autoplay loop>&lt;/audio>\n &lt;audio controls>\n        &lt;source src=\"./source/audio.mp3\">\n        &lt;source src=\"./source/audio.ogg\">\n        &lt;embed src=\"./source/audio.mp3\" type=\"audio/mp3\" width=\"300\" height=\"100\">\n     \t&lt;!--以上资源默认从上往下解析 对不起，您的浏览器不支持播放音频！请升级浏览器！ -->\n &lt;/audio>\n\n&lt;!-- \n        使用video标签来向网页中引入一个视频\n            - 使用方式和audio基本上是一样的\n     -->\n &lt;video controls>\n        &lt;source src=\"./source/flower.webm\">\n        &lt;source src=\"./source/flower.mp4\">\n        &lt;embed src=\"./source/flower.mp4\" type=\"video/mp4\">\n    &lt;/video>\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"002-语义化标签","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/23/002-语义化标签/","content":"1.语义化标签​    在使用html标签时关注标签的语义而不是样式，网页的样式由css文件决定；\n2.块元素​    块元素都是独占一行\n&lt;!-- \n\th1~h6六级标题都是块内元素 （block element）\n\t一般在行元素内不会放块元素\n           -->\n&lt;hgroup>使用该标签可以将标题分组，将同一组标题放入到hgroup中&lt;/hgroup>\n\n&lt;p>\n    p标签也是块元素 在p标签中不使用任何块元素\n&lt;/p>\n\n3.行内元素/内联元素页面中不会独占一行的称为行内元素（inline element）\n&lt;em>斜体标签 用于将选中的文本把变为斜体&lt;/em>\n&lt;strong>用于加粗选中的字体&lt;/strong>\n&lt;blockquote>\n    长引用 使用时会自动将选中的文本缩进且换行\n&lt;/blockquote>\n&lt;q>短引用 将选中的文本加引号强调&lt;/q>\n&lt;br> 换行标签 可连用\n4.结构化语义化标签​    html5新提供的结构化语义标签都属于块元素 效果都和div相同 常使用div标签\n&lt;!-- \n        header 表示网页的头部\n        main 表示网页的主体部分(一个页面中只会有一个main)\n        footer 表示网页的底部\n        nav 表示网页中的导航\n        aside 和主体相关的其他内容（侧边栏）\n        article 表示一个独立的文章\n        section 表示一个独立的区块，上边的标签都不能表示时使用section\n\n        div 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素\n        span 行内元素，没有任何的语义，一般用于在网页中选中文字\n\n      -->\n     &lt;header>头部&lt;/header>\n     &lt;main>主体&lt;/main>\n     &lt;footer>底部&lt;/footer>\n     &lt;nav>导航&lt;/nav>\n     &lt;aside>侧边栏&lt;/aside>\n     &lt;article>文章&lt;/article>\n     &lt;section> 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;/section>\n\n\tdiv和span较常用\n     &lt;div>&lt;/div>\n     &lt;span>&lt;/span>\n注意 若将标签写在根元素之外时 浏览器解析时会自动修改 但不一定会达到想要的效果\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"001-实体-meta标签","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2022/02/23/001-实体-meta标签/","content":"1.HTML结构​    HTML结构可分为以下三部分：\n&lt;html>\n    &lt;head>\n        &lt;!--在这里可以使用meta title标签 -->\n    &lt;/head>\n    &lt;body>\n        \n    &lt;/body>\n&lt;/html>\n2.HTML5的标识​    在html文件开头使用标签来区分html4与5的区别\n​    文档声明用来告诉浏览器当前网页的版本\n​        - html5的文档声明\n &lt;!doctype html>\n\n&lt;!Doctype HTML>\n3.HTML编码字符集​    常见的字符集：\n​        ASCII\n​        ISO88591\n​        GB2312\n​        GBK\n​        UTF-8，在开发时我们使用的字符集都是UTF-8\n4.meta标签​    该标签在主要用于设置一些网页中的元数据，元数据用于网站的搜索引擎检索，可以在此标签内指定网页的编码字符集，如下代码：\n&lt;!-- \n       meta主要用于设置网页中的一些元数据，元数据不是给用户看\n           charset 指定网页的字符集\n           name 指定的数据的名称\n           content 指定的数据的内容\n\n            keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开\n                 \n             description 用于指定网站的描述\n                   \n              网站的描述会显示在搜索引擎的搜索的结果中\n\n               title标签的内容会作为搜索结果的超链接上的文字显示  \n\t&lt;meta name=\"keywords\" content=\"HTML5,前端,CSS3\">\n    \t&lt;meta name=\"description\" content=\"这是一个非常不错的网站\">\n\t&lt;title>这是标题&lt;/title>\n\t&lt;meta> 标签支持 HTML 中的全局属性。\n    -->\n\t\n使用meta标签有http-equiv, name,scheme 属性可选 其对应的content值具体参照文档\n5.实体标签​    在 HTML 中，某些字符是预留的。\n​    在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。\n​    如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。\n使用方法： &amp;需转义的字符;(&amp; ;均是英文符号)\n常用的转义字符：\n\n","categories":["HTML-CSS学习"],"tags":["WEB前端"]},{"title":"计算机网络复习","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/07/08/计网复习/","content":"期末计网复习重点第一章 计算机网络概述1.三网融合的概念从电信网络（向用户提供电话，电报及传真等服务），有线电视网（传送各种电视节目）和计算机网络（在计算机之间传送数据）三种各自分工到将电信网络和有线电视网络融入现代计算机网络，将三种网络融合成一种网络就能提供所有服务。\n2.计算机网络的定义及其分类定义：计算机网络主要是由一些通用的，可编程的硬件互连而成，而这些硬件并非专门用来实现某一特定目标，这些可编程的硬件能够用来传送各种不同类型的数据，并能支持广泛的和日益增长的应用。\n分类：按作用范围可分为：广域网（WAN），城域网（MAN），局域网（LAN），个人区域网（PAN）及无线个人区域网（WPAN）；\n按使用者类型可分为：公用网和专用网；\n3.互连网的定义和组成定义：计算机网络（网络）由若干结点和连接这些结点的链路组成。利用路由器将这些网络互连起来组成的网络叫做互连网（互连网是网络的网络）；\n组成：分为边缘部分和核心部分；\n边缘部分：由所有连接在互连网的主机组成，这部分是用户直接使用的，用来进行通信和资源共享。\n核心部分：由大量的网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的。\n4.客户-服务器通信方式（C/S方式）客户是服务请求方，服务器是服务提供方；（B/S方式是C/S方式的一种特例）这种方式的通信是双向的。\n5.分组交换，电路交换，报文交换路由器是实现分组交换的关键构件，其任务是转发收到的分组。\n交换是按照某种方式动态的分配传输路线的资源。\n通常把要发送的整块数据称为一个报文；\n在发送报文之前，把较长的报文划分为一个个更小的等长数据段，在数据段的前面加上一些由必要的控制信息组成的首部（包头，首部包含了目的地的地址和源地址等重要控制信息）后就构成了一个分组；\n电路交换：建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）；电路交换的用户在通话始终占用端到端的通信资源；\n分组转发采用存储转发技术；\n电路交换：整个报文的比特流连续的从源点直达终点；\n报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。\n分组交换：单个分组（报文的一部分）传送到相邻的结点，存储下来后查找转发表转发到下一个结点。\n若要连续传送大量数据且其传送时间远大于连接建立时间选择电路交换，在传送突发数据时选择报文交换和分组交换，分组交换比报文交换具有更好的灵活性和更低的时延性。\n6.计算机网络性能指标速率：数据的传送速率（数据率、比特率，bit/s）\n带宽：在计算机网络中，网络带宽表示在单位时间内网络中的某信道所能通过的最高数据率（bit/s）；\n吞吐量：表示在单位时间内通过某个网络的实际的数据量。\n时延：指数据从网络的一端到另一端所需的时间。\n​        （1）发送时延：指主机或路由器发送数据帧所需要的时间。发送时延=数据帧长度（bit）/发送速率（bit/s）；\n​        （2）传播时延：电磁波在信道中传播一定距离所花费的时间。传播时延=信道长度(m)/电磁波在信道上的传播速率(m/s)；\n​        （3）处理时延：主机或路由器在收到分组时需要花费一定时间进行处理；\n​        （4）排队时延：分组在经过网络传输时，要经过许多路由器，在进入路由器后要先在输入队列中排队等待处理。\n​        总时延=发送时延+传播时延+处理时延+排队时延\n时延带积宽：时延带积宽=传播时延*带宽\n往返时间RTT：双向交互一次所需的时间；\n信道利用率:指出某信道有百分之几的时间是被利用的；\n网络利用率：全网络的信道利用率的加权平均值；\n信道或网络的利用率过高会产生非常大的时延；\n7.分层、透明分层：相互通信的两个计算机系统必须高度的协调工作，分层可将庞大而复杂的问题转化为若干较小的局部问题，这些较小的问题易于研究和处理。\n透明：指存在但不干预即：计算机中存在的,但对于某些人员而言又不需要了解的东西,这就是计算机所指的透明性.简单的说就是:计算机中存在,但你不需要了解的.使用本层服务的实体只能看见服务而无法看见下面一层的协议。集协议对上层实体是透明的。\n8.网络协议、实体、服务、服务访问点网络协议：为进行网络中的数据交换而建立的规则，标准或约定称为网络协议（协议）；协议是控制两个对等（或对个）实体进行通信规则的集合；在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，要实现本层协议需要使用下面一层的提供的服务。\n实体：表示任何可发送或接受信息的硬件或软件进程；\n服务：协议是水平的，服务是垂直的，服务是由下层向上层通过层间接口提供的，只有那些能被上层实体看见的功能才称为服务；\n服务访问点：在同一系统中相邻两层的实体进行交互的地方；\n9.体系结构计算机网络的各层及其协议的集合就是网络的体系结构，是这个计算机网络及其所有构件所应完成的功能的精确定义。\n\n应用层：直接为用户的应用进程提供服务；通过应用进程间的交互来完成特定网络应用。应用层交互的数据单元称为报文；\n运输层：负责向两台主机中的进程之间的通信提供通用的数据传输服务；\n​                运输层主要使用以下两种协议：\n​                （1）传输控制协议TCP：提供面向连接的，可靠的数据传输服务，其数据传输单位是报文段；\n​                （2）用户数据报协议UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报；\n网络层：负责为分组交换网上的主机提供通信服务；\n数据链路层：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送帧。使每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）；\n物理层：物理层的任务就是透明地传送比特流。为数据端设备提供传送数据的通路；传输数据；在物理层上所传送的数据单位是比特；\n\n\n第二章 物理层1.物理层的四大规程物理层考虑的是怎样在连接各种计算机的传输媒体上传输数据比特流；物理层的协议称为规程，物理层的主要任务是确定与传输媒体的接口有关的一些特性；数据在通信线路（传输媒体）上的传输一般为串行传输；\n机械特性：指明接口所用的接线器的形状和尺寸，引脚数目和排列，固定和锁定装置等；\n电气特性：指明在接口电缆的各条线上出现的电压的范围；\n功能特性：指明某条线上出现的某一电平的电压的意义；\n过程特性：指明对于不同功能的各种可能事件的出现顺序；\n2.通信基础知识数据是运送消息的实体；\n信号是数据的电气或电磁的表现；可分为模拟信号（连续信号，消息的参数的取值是连续的），数字信号（离散信号，消息的参数的取值是离散的）；\n信道：表示向某一个方向传送信息的媒体，一条通信电路往往包含一条发送信道和接受信道；\n调制：数字比特流转换为模拟信号；（基带调制：数字信号到数字信号；带通调制：数字信号到模拟信号）\n解调：模拟信号转换为数字比特流；\n调制方法：调频、调幅、调相；\n从通信双方信息交互的方式可分为：单工通信（电视广播，只有一个方向）、半双工通信（双向交替通信需要两条信道）、全双工通信（双向同时通信需要两条信道）；\n曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1，反过来定义也可以；\n差分曼彻斯特编码：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1；\n基本的带通调制方法\n​    （1）调幅（AM）：载波的振幅随基带数字信号而变化；\n​    （2）调频（FM）：载波的频率随基带数字信号而变化；\n​    （3）调相（PM）：载波的初始相位随基带数字信号而变化；\n3.常见的有线传输介质双绞线：\n​        568a的排线顺序从左到右依次为：白绿、绿、白橙、蓝、白蓝、橙、白棕、棕。 568b则为：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕。​        正线，即直通线 ，标准568B）：两端线序一样，从左至右线序是：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。​        反线，即交叉线 ，（568A）：一端为正线的线序，另一端为从左至右：白绿，绿，白橙，蓝，白蓝，橙，白棕，棕。​        交叉线是指：一端是568a标准，另一端是568b标准的双绞线；​        直连线则指：两端都是568a或都是568b标准的双绞线。​        相同设备用直通线，不同设备用交叉线，除了主机和路由器用交叉线；​        反线也是交叉线；同轴电缆（利用光的全反射）光缆：多模光纤适用于短距离传输、单模光纤使用远距离传输\n4.复用技术复用：上层多个进程可同时使用下面层提供的服务；\n分用：下层将收到的数据分别交付给上层相应的进程；\n频分复用：所有用户在同样的时间内占用不同的带宽资源（频率带宽）；\n时分复用（同步时分复用）：所有用户在不同的时间占用同样的频带宽度；有利于数字信号传输；\n统计时分复用（异步时分复用）：改进的时分复用，提高信道利用率；\n波分复用：光的频分复用（利用光的波长）；\n码分复用（码分多址）：每一个用户可以在同样的时间使用同样的频带进行通信，不同的码型可避免干扰；\n​        将码片（每一个比特时间再划分为m个短的间隔）的0记为**-1，将1记为+1**；\n​        CDMA系统内每个站分配的码片序列各不相同且正交（内积为0）；每个码片与自己本身内积为1；每个码片和自己的反码内积为**-1**；\n5.有线宽带接入技术ADSL技术（非对称数字用户线技术）：是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务；\nHFC网（光纤同轴混合网）：在有线电视的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话，数据和其他宽带交互型业务；\nFTTx技术：为提高居民的上网速率提出FTTH技术（光纤到户技术），从而出现了多种宽带光纤接入技术FTTx，就是把光电转换的地方从用户家向外延伸到离用户家门口有一定距离的地方（从H到x）；\n\n第三章 数据链路层点对点信道：使用一对一的点对点通信方式的信道；\n广播信道：使用一对多的广播方式的信道；\n局域网属于数据链路层范围，在同一个局域网中，分组从一台主机转发到另一台主机不经过路由器转发；\n链路：从一个结点到相邻结点的一段物理线路（有线或无线），中间没有其他交换节点；\n帧：数据链路层的协议数据单元；由帧首部+数据部分（IP数据报）+帧尾部构成；\n数据链路：具有必要的通信协议（控制数据传输）的软硬件构成的链路；常使用网络适配器来实现这些协议；数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出上交到网络层，网络层的协议数据单元是IP数据报（数据报，分组，包）；\n1.数据链路层三个基本问题封装成帧：就是在一段数据的前后分别添加首部和尾部\n​      首部和尾部的一个很重要的作用就是进行帧定界（帧定界符的控制字符SOH(十六进制 01)放在帧的最前面，表示帧的开始，EOT(十六进制 04)放在帧尾，表示帧的结束）此外，首部和尾部还包括许多必要的控制信息。发送帧时从帧首部开始发送；\n透明传输：\n​     “透明”表示某个实际存在的事物看起来却好像不存在一样,在数据链路层透明传送数据表示无论什么样的比特组合的数据，都能够按照原样没有差错的通过数据链路层；\n​      解决透明传输的办法是字节填充（字符填充）：\n​        1.发送端的数据链路层在数据中出现了控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”（其16进制为1B），而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。\n​        2.如果转义字符也出现在数据当中，那么就在转义字符前面插入一个转义字符，当接收端收到两个连续的转义字符时，就删除其中前面的一个。\n差错检测（CRC循环冗余校验）：\n比特差错：在传输过程中可能会产生差错，0变成1或1变成0；\n传输差错：帧丢失，帧重复，帧失序；\n【例子】：除数M为101001 除数P（x）=X3+X2+1 此时除数P=1101\n​    被除数后要补比除数位数少一个0，这里为4-1=3个0\n​    在运算过程中不借位，余数最高位位为1则上1。\n则发送的数据为101001001\n在接收端对收到的每一帧经过CRC检验后，有两种情况：\n​    1.若得出余数为0，则判定这个帧没错，接受\n​    2.若余数不为0，则判定这个帧有差错（但无法确定是哪里出现了差错），丢弃\n注意：CRC不是“可靠传输”，只能做到无差错接受，即“若只在数据链路层使用CRC差错检测技术，凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”；\n2.点对点协议PPPPPP协议是用户计算机和ISP进行通信时所使用的的数据链路层协议；\nPPP协议的特点：\n（1）简单：他提供不可靠的数据包服务，对于数据链路层的帧不需要纠错，不需要序号，也不需要流量控制（只进行CRC检验，正确就收下，错误就抛弃）；\n（2）封装成帧：规定特殊的字符作为帧定界符；将数据报封装成帧；\n（3）透明性：保证数据传输时的透明性；\n（4）多种网络协议：必须能够在同一条物理链路上同时支持多种网络层协议（如IP和IPX）；\n（5）多种类型链路：必须能够在多种链路上运行（串行的，并行的，同步的，异步的等）；\n（6）差错检测：必须能够对接收端收到的帧进行检测，并立即抛弃有差错的帧；\n（7）检测连接状态：必须具有自动检测链路是否处于正常工作状态的机制；\n（8）最大传送单元：必须对每一种类型的点链路设置最大传送单元（MTU）的标准默认值；\n（9）网络层地址协商：必须提供一种使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址的机制；\n（10）数据压缩协商：必须提供一种方法来协商使用数据压缩算法；\nPPP协议的组成：一个将IP数据报封装成串行链路的方法；一个用来建立，配置和测试数据链路连接的链路控制协议LCP；一套网络控制协议NCP；\n3.局域网常见拓扑星型网、环形网、总线网；\n4.网卡的功能计算机与外界局域网的连接是通过通信适配器进行的。在主机箱内插入的一块网络接口板又称为网络接口卡NIC（网卡）；\n适配器的一个重要功能是进行数据串行传输和并行传输的转换。对数据进行缓存，在计算机的操作系统安装设备驱动程序；\n适配器还要能够实现以太网协议；\n5.CSMA/CD在同一时间内只能允许一台计算机发送数据，因此采用一种协调协议CSMA/CD（载波监听多点接入/碰撞检测）;\n工作原理：载波监听（检测信道）；信道忙时停止发送（忙则等待），信道空闲时才进行发送；碰撞检测（边发送边监听，若发生碰撞则暂停）；使用截断二进制指数退避算法确定碰撞后重传时机；发送强干扰信号强化碰撞；\n6.MAC地址、MAC帧格式、无效帧无效帧：凡长度小于64字节的帧都是由于冲突而异常中止的无效帧\nMAC地址：在局域网中，硬件地址又称为物理地址或MAC地址；实际上就是适配器地址或适配器标识符；\nMAC帧格式：两种标准，一种是DIX Ethernet V2标准，一种是IEEE 802.3标准；\n以太网V2的Mac帧由五个字段组成，前两个字段分别为6字节长的目的地址和源地址，第三个字段是2字节的类型字段（标志上一层使用的协议），第四个字段是数据字段，第五个字段是四字节长的帧检验序列FCS；\n\n7.集线器、网桥的工作原理集线器：以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，集线器类似于一个多接口的转发器，集线器工作在物理层，它的每个接口仅仅简单地转发比特；\n网桥的工作原理：多接口的网桥实质就是交换机；网桥对收到的帧根据其MAC帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是根据此帧的目的MAC地址，查找网桥中的地址表，然后确定将该帧转发到哪一个接口，或者是把它丢弃。\n网桥带来的好处：1.过滤通信量；\n​                            2.扩大了物理范围；\n​                            3.提高了可靠性；\n​                            4.可互连不同的物理层、不同的MAC子层和不同速率的局域网；\n8.虚拟局域网的概念、原理虚拟局域网的概念：VLAN是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪个VLAN；\n虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN标记。\n原理：VLAN中的端口成员不是按照物理地址划分的，所以一个VLAN也可以跨越多台物理交换机，这就是VLAN中继(Trunk)功能，在不同的交换机上可以有相同的VLAN，而且不同交换机上相同的VLAN是可以相互通信的，可以把相同的VLAN在不同物理交换机在逻辑上看作存在物理连接，因此自然可以相互通信。\n\n第四章 网络层1.网络层提供的两种服务\n\n\n对比的方面\n虚电路服务\n数据报服务\n\n\n\n思路\n可靠通信应当由网络来保证\n可靠通信应当由用户主机负责\n\n\n连接的建立\n必须有\n不需要\n\n\n重点地址\n仅在建立连接时使用，每个分组使用短的虚电路号\n每个分组都有终点的完整地址\n\n\n分组的转发\n属于同一条虚电路的分组均按照同一路由进行转发\n每个分组独立选择路由进行转发\n\n\n当结点出故障时\n所有通过出故障的结点的虚电路均不能工作\n出故障的结点可能会丢失分组，一些路由可能会发生变化\n\n\n分组的顺序\n总是按发送顺序达到终点\n达到终点的时间不一定按发送顺序\n\n\n端到端的差错处理和流量控制\n可以由网络负责，也可以由用户主机负责\n由用户主机负责\n\n\n2.IP地址IP地址：: :={&lt;网络号&gt;,&lt;主机号&gt;}\nIP地址在全世界范围内是唯一的32位的标识符；一个网络号在整个互联网范围内必须是唯一的；一台主机号在其网络号声明的网络范围内必须是唯一的；\nIP地址是一种分等级的地质结构。IP地址管理机构在分配IP地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号来转发分组。\n分类的IP地址是由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别为指明IP地址的类别。\n一个IP地址在整个互联网范围内是唯一的。分类的IP地址包括A类、B类和C类地址（单播地址），以及D类地址（多播地址）。E类地址未使用。A类    1126    B类128191        C    192223        D    224239        127用于环路测试\n3.ARP协议（地址解析协议）的原理地址解析协议ARP把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。ARP的高速缓存可以大大减少网络上的通信量。\nARP步骤：        1.ARP进程在本局域网上广播发送一个ARP请求分组。\n​        2.在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组。\n​        3.若有主机的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向(发送ARP请求分组的)主机发送ARP相应分组，同时在这个ARP相应分组中写入自己的硬件地址。由于区域的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理财这个ARP请求分组。（注意：ARP请求分组是广播发送，但ARP响应分组是单播的）。\n​        4.(发送ARP请求分组的)主机接收到ARP响应分组后，就在其ARP高速缓存中写入响应主机的IP地址到硬件地址的映射。\n4.IP协议首部格式\n首部的固定部分长度固定为20字节，固定部分后面的是可选字段，长度可变；\n版本：占4位，值IP协议的版本；\n首部长度：占4位，可表示的最大十进制数是15；\n区分服务：占8位，用来获得更好的服务；\n总长度：指首部和数据之和的长度，占16位；可表示的数据报最大长度为65535字节；\n标识：占16位，相同的标识字段的值使分片后的各数据报片最后能正确的重装为原来的数据报；\n标志：占3位，MF=1表示后面还有分片，MF=0表示这是最后一个分片；DF=0表示不能分片，等于0时才能分片；\n片漂移：占13位，片漂移指出较长的分组在分片后某片的在原分组的相对位置；\n5.分组转发算法(1)从数据报的首部提取目的主机的IP地址D,得出目的网络地址为N.\n(2)若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机(这里包括把目的主机地址D转换为具体的硬件 地址，把数据报封装为MAC帧，再发送此帧)；否则就是间接交付，执行(3)。\n(3)若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。\n(4)若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(5)。\n(5)若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。\n(6)报告转发分组出错。\n6.划分子网在IP地址中添加子网号字段，使两级IP地址变为三级IP地址；从主机号借用若干位作为子网号，主机号也相应减少同样的位数；\nIP地址  : :={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}\n\n7.无分类编址CIDR（构造超网）IP地址 : :={&lt;网络前缀&gt;,&lt;主机号&gt;}\n​        无分类域间路由选择CIDR是解决目前IP地址紧缺的一个方法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所占的位数，如（128.14.5.7/20）。前缀用来指明网路，前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”。IP地址的分配都以CIDR地址块为单位；\n​        CIDR的32位地址掩码（子网掩码）由一串1或一串0组成，而1的个数就是前缀的长度。只要把IP地址和地址掩码逐位进行“逻辑与(and)”运算，就很容易得出网络地址。A类地址的默认地址掩码是255.0.0.0。B类地址的默认地址掩码是255.255.0.0。C类地址的默认地址掩码是255.255.255.0；\n8.最长前缀匹配查找路由表时应当从匹配结果中选择具有最长网络前缀的路由；\n9.二叉线索查找路由表先找出对应于每一个IP地址的唯一前缀，通过唯一前缀构造二叉线索；\n10.ICMP（网际控制报文协议）在网际层使用ICMP协议提高IP转发数据报和提高交付成功的机会；ICMP报文是装在IP数据报中，作为其中的数据部分；\nICMP报文分为ICMP差错报告报文和ICMP询问报文；\n\n\n11.IPv6概念及地址长度由于IPv4的地址已耗尽，所以有了IPv6；IPv6的地址使用冒号十六进制记法；IPv6数据报的目的地址可以是一下三种基本类型地址之一：单播，多播，任播。IPv6数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所以的扩展首部和数据；结合起来叫做数据报的有效载荷或净负荷。IPv6主要带来的变化是：1更大的地址空间；2 灵活的首部格式；3 改进的选项；4支持即插即用；5支持资源的预分配；6 IPv6的首部改为8字节对齐。IPv6的地址长度是128位地址（补充IPv4是32位，MAC是48位）；\n12.静态路由、路由选择协议（RIP、OSPF）静态路由选择也叫非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。\n互联网把路由选择协议划分为内部网关协议IGP和外部网关协议EGP；\n内部网关协议RIP（路由信息协议），很少被使用，RIP是一种分布式的基于距离向量的路由选择协议；优点是简单；RIP协议的距离也称为跳数；距离等于16时相当不可达，RIP只适应于小型互联网；\n\nRIP协议特点：\n1仅和相邻的路由器交换信息；\n2交换的信息是当前本路由器所知道的全部信息，即自己的路由表；\n3按固定时间间隔交互信息。\n距离向量算法：1 从相邻的 X 路由器接收发送过来的 RIP（Routing Information Protocol） 报文；2 将该 RIP 报文中的下一跳地址修改为 X，且跳数增加 1；3 对每个项目执行如下步骤；    a.若原路由表没有 RIP 中的目的网络 N，直接添加到原路由表中；    b.若原路由表中有 RIP 中的目的网络 N，但下一跳地址不是 X ，选择跳数少的替换。如果两者跳数一样，则保留原路由表的项。    c.若原路由表中有 RIP 中的目的网络 N，且下一跳地址是 X，使用收到的项替换；4若超过 180s （RIP 默认 180s）还没有收到相邻路由器的更新路由表，则相邻路由器置为不可达，跳数为 16；\n\n内部网关协议OSPF（开放最短路劲优先）\nOSPF：OSPF使用分布式的链路状态协议。OSPF的更新过程收敛的快；特点：\n1.向本自治系统中所有路由器发送信息，采用洪泛法；\n2.发送的信息就是与本路由器相邻的所有路由器的链路状态；\n3.当链路状态发生变化时才回发送信息；\n\nRIP配置过程Router（config）#router ripRouter（config- router）#version 2Router（config- router）#network 192.167.100.0（ip地址）Router（config- router）#network 10.1.1.0Router（config- router）#no auto-summaryOSPF配置过程Router（config）#router ospf 1Router（config- router）#network 10.1.1.0  0.0.0.255  area 0\n\n13.路由器的组成和工作原理路由器结构可划分为两大部分：路由选择部分和分组转发部分；\n路由选择部分也叫做控制部分，其核心构件是路由选择处理机，它的任务是根据路由协议构造，更新和维护路由表；\n分组转发部分又三部分组成：交换结构，一组输入端口和一组输出端口，这里的端口是硬件接口；\n交换结构的任务就是根据转发表对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去；\n14.VPN 的原理，NAT 和 NAPT 的作用专用地址（内部地址）只能用于一个机构的内部通信，不能用于和互联网上的主机通信；\n虚拟专用网VPN：利用共用的互联网作为本机构各专用网之间的通信载体。三个专用地址块：（1）10.0.0.0到10.255.255.255（24位块）（2）172.16.0.0到172.31.255.255（20位块）（3）192.168.0.0到192.168.255.255（16位块）两个专用网之间通过IP隧道进行通信。网络地址转换NAT的作用是：它实现内网的IP地址与公网的地址之间的相互转换，将大量的内网IP地址转换为一个或少量的公网IP地址，减少对公网IP地址的占用。网络地址与端口号转换NAPT（实际上就是使用端口号的NAT）；\n\n第五章 运输层1.运输层的功能运输层向它上面的应用层提供通信服务，运输层为应用进程间提供端到端的逻辑通信；运输层具有复用（发送方不同的应用进程都可以使用同一个运输层协议传送数据）和分用（接收方的运输层在剥去报文的首部后能够把数据正确交付应用进程）功能；\n2.运输层的端口为了在通信中识别主机的应用进程，在运输层使用协议端口号，这是一种软件端口，端口只具有本地意义；\n\n3.UDP的特点、首部格式用户数据报协议UDP的特点：\n1.UDP是无连接的；\n2.UDP使用尽最大努力交付，不保证可靠交付；\n3.UDP是面向报文的；\n4.UDP没有拥塞控制；\n5.UDP支持一对一，一对多，多对一和多对多的交互通信；\n6.UDP的首部开销小只有8字节；\nUPD的首部格式：\n1.源端口：源端口号。在需要对方回信时选用，不需要时全为0；\n2.目的端口：目的端口号，在终点交付报文时使用；\n3.长度：UDP用户数据报的长度，最小值为8；\n4.检验和：检测UDP用户数据报在传输中是否有错，有错就丢弃；\n\n\n4.TCP的特点、可靠传输实现传输控制协议TCP的特点：\n1.TCP是面向连接的运输层协议；\n2.每一条TCP连接只能有两个端点。每一条TCP连接只能是点对点的；\n3.TCP提供可靠交付的服务；\n4.TCP提供全双工通信；\n5.面向字节流；\nTCP连接的端口叫套接字或插口；\n套接字 socket = （IP地址：端口号）\n每一条TCP连接唯一的 被通信两端的两个端点（即两个套接字）所确定；\nTCP连接 : : ={socket1，socket2} = {（IP1：port1），（IP2：port2）}\n可靠传输的实现：停止等待协议，连续ARQ协议；\n\nTCP报文段的首部格式：首部的前20个字节是固定的，所以TCP首部最小长度是20字节；\n\n\n首部固定部分各字段意义如下：\n1） 源端口和目的端口：各占2个字节，分别写入源端口和目的端口。\n2） 序号：占4字节。序号范围是【0，2^32 - 1】，共2^32（即4294967296）个序号。序号增加到2^32-1后，下一个序号就又回到0。也就是说，序号使用mod 2^32运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。\n3） 确认号      占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。\n   总之：若确认号为= N，则表明：到序号N-1为止的所有数据都已正确收到。\n\n4） 数据偏移         占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。\n5） 保留          占6位，保留为今后使用，但目前应置为0 。\n下面有6个控制位，用来说明本报文段的性质。6） 紧急URG（URGent）        当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。\n   当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。\n\n7） 确认ACK（ACKnowledgment）      仅当ACK = 1时确认号字段才有效，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。\n8） 推送 PSH（PuSH）    当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。\n9） 复位RST（ReSeT）       当RST=1时，表名TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。\n10） 同步SYN（SYNchronization）       在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。\n11） 终止FIN（FINis，意思是“完”“终”）          用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。\n12） 窗口             占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。\n  例如，发送了一个报文段，其确认号是701，窗口字段是1000.这就是告诉对方：“从701算起，我（即发送方报文段的一方）的接收缓存空间还可接受1000个字节数据（字节序号是701~1700），你在给我发数据时，必须考虑到这一点。”\n\n  总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。\n\n13） 检验和       占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。\n14） 紧急指针            占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。\n15） 选项       长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。\n   TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie）。注意MSS这个名词含义。MSS是每一个TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。\n\n   为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）才能组装成一个IP数据报。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。\n\n   因此，MSS应尽可能大些，只要在IP层传输时不需要分片就行。由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要的分片的MSS，如果改走另一条路径就可能需要进行分片。因此最佳的MSS是很难确定的。在连接过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传输数据，两个传送方向可以有不同的MSS值。若主机未填写这一项，则MSS的默认值是536字节长。因此，所有在互联网上的主机都应该接受的报文段长度是536+20（固定首部长度）=556字节。\n\n后来又增加了几个选项如窗口扩大选项、时间戳选项等。\n  窗口扩大选项是为了扩大窗口。我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。\n\n   窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2^（16+14）-1=2^30-1。\n\n   窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=0选项，使窗口大小回到16。\n\n时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念：\n  第一、 用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。\n\n   第二、 用于处理TCP序号超过2^32的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加2^32个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。例如，当使用1.5Mbit/s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。\n\n\nTCP可靠传输的实现\n\nTCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。\nTCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。\nTCP 两端的四个窗口经常处于动态变化之中。\nTCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。\n\n1.以字节为单位的滑动窗口技术；\n2.超时重传时间的选择 ；\n3.改进的确认——选择确认(SACK)；\nTCP的流量控制：让发送方的发送速率不要太快，要让接收方来得及接受；（利用滑动窗口来实现）\n5.TCP的拥塞控制拥塞：在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏；\n拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载；这是一个全局性的过程；\nTCP的拥塞控制方法：慢开始，拥塞避免，快重传，快恢复；\n6.随机早期检测算法 RED 算法主动队列管理：当路由器的队列长度达到某个警惕值时主动丢弃到达的分组；（利用RED算法实现）\nRED算法：使路由器维持队列最小门限和最大门限两个参数；按规定计算当前的平均队列长度；\n（1）若平均队列长度小于最小门限，则将新到达的分组放入队列进行排队；\n（2）若平均队列长度大于最大门限，则将新到达的分组丢弃；\n（3）若平均队列长度处于最小门限和最大门限之间，则按某一丢弃概率p丢弃新到达的分组；\n7.TCP连接的管理TCP的运输连接阶段分为：连接建立，数据传送和连接释放；\nTCP的连接建立（三次握手）：\n（1）请求连接：客户端发送SYN=1，seq=x的报文段向服务器请求建立连接（不携带数据）；\n（2）同意连接：服务器收到请求后向客户端发送SYN=1，ACK=1，seq=y，ack=x+1的报文同意建立连接（不携带数据）；\n（3）确认连接：客户端收到同意后想服务器发送ACK=1，seq=x+1，ack=y+1的报文确认连接（可携带数据）；\n\n**TCP的连接释放(四次握手)**：\n\n\n第六章 应用层1.DNS的工作原理域名系统DNS是互联网使用的命名系统；用来把机器名字转换为IP地址；\n域名服务器分四种：（1）    根域名服务器（知道所有顶级域名服务器和IP地址）（2）    顶级域名服务器（3）    权限域名服务器（4）    本地域名服务器\n域名的解析过程分两步第一：主机向本地域名服务器的查询本地服务器用递归查询。第二：本地域名服务器向根域名服务器的查询用迭代查询。\n\n解析顺序\n　　1） 浏览器缓存\n　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；\n　　2） 系统缓存\n　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；\n　　3） 路由器缓存\n　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；\n　　4） ISP（互联网服务提供商）DNS缓存\n　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；\n　　5） 根域名服务器\n　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；\n　　6） 顶级域名服务器\n　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；\n　　7） 主域名服务器\n　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；\n　　8）保存结果至缓存\n　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。\n2.FTP 的工作原理文件传输协议FTP1.FTP的基本工作原理：主进程的工作步骤：(简答题)（1）    打开熟知端口（端口号为21），使客户进程能够连接上。（2）    等待客户进程发出连接请求。（3）    驱动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。（4）    回到等待状态，继续接受其他客户进程发来的请求。\nFTP的客户和服务器之间要建立两个并行的TCP连接：控制连接和数据连接\n3.电子邮件的工作原理1.电子邮件的一些标准：发送邮件的协议：SMTP读取邮件的协议：POP3和IMAP多用途互联网邮件扩展类型：MIME(在邮件首部说明邮件的数据类型如声音……)\n\n   计算机之间发送和接收电子邮件的几个重要步骤：（简答题）（1）    发件人调用计算机中的用户代理撰写和编辑要发送的邮件（2）    发件人点击屏幕上的“发送邮件”按钮，把发送邮件的工作全交给用户代理来完成。（3）    SMTP服务器收到用户代理发来的邮件后，就把邮件临时存放在邮件缓存队列中，等待发送到接受方的邮件服务器（4）    发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP服务器建立TCP连接，然后把邮件缓存队列中的邮件一次发送出去（5）    运行在接受方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取（6）    收件人在打算收信时，就在运行计算机中的用户代理，使用POP3（或IMAP）协议读取发送给自己的邮件\n\n电子邮件地址的格式：TCP/IP体系的电子邮件系统规定电子邮件地址的格式如下： 收件人邮箱名@邮箱所在主机的域名 例子：&#120;&#105;&#x65;&#120;&#x69;&#101;&#x72;&#x65;&#x6e;&#64;&#x74;&#x73;&#105;&#110;&#103;&#104;&#117;&#97;&#x2e;&#x6f;&#114;&#103;&#x2e;&#99;&#x6e;\n\n\n简单邮件传送协议SMTPSMTP通信的三个阶段：（1）    建立连接（主机的SMTP客户与接收主机的SMTP服务器的连接）（2）    邮件的传送（邮件的传送从MAIL命令开始）（3）    连接释放（邮件发送完毕后，SMTP客户发送OUIT命令）\n4.WWW 的四大问题及解决方法（1）怎样标志分布在整个互联网上的万维网文档？使用统一资源定位符URL；\n（2）用什么协议来实现万维网上的各种链接？使用超文本传送协议HTTP；\n（3）怎么使不同作者创造不同风格的万维网文档并显示在主机上？使用超文本标记语言HTML；\n（4）怎么样使用户很方便的查找信息？使用搜索引擎；\n5.DHCP的工作原理动态主机配置协议DHCP\n原理：动态主机设置协定（DHCP）是一种使网络管理员能够集中管理和自动分配IP网络地址的通信协议。在IP网络中，每个连接Internet的设备都需要分配唯一的IP地址。DHCP使网络管理员能从中心结点监控和分配IP地址。当某台计算机移到网络中的其它位置时，能自动收到新的IP地址。\n连接到互联网的计算机的协议软件需要配置的项目：（1）    IP地址；（2）    子网掩码；（3）    默认路由器的IP地址；（4）    域名服务器的IP地址；\n\n习题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["计算机网络复习"],"tags":["计算机网络"]},{"title":"Hexo环境搭建","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/02/21/Hexo环境搭建/","content":"1.1 创建博客项目安装Hexo\nnpm install -g hexo-cli\n初始化博客项目\nhexo init dm-blog\n进入项目文件夹，安装相关依赖\nnpm install\n目录结构\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n打开_config.yml，配置基本信息\n# Site\ntitle: 淡漠Blog\nsubtitle: &#39;&#39;\ndescription: &#39;淡漠DM的博客&#39;\nkeywords:\nauthor: 淡漠DM\nlanguage: zh-CN\ntimezone: &#39;&#39;\n启动项目\nhexo s\n\n\n常用命令介绍\n\n\n\n命令\n简写\n含义\n\n\n\nhexo server\nhexo s\n本地启动\n\n\nhexo generate\nhexo g\n生成静态文件\n\n\nhexo deploy\nhexo d\n部署网站\n\n\nhexo clean\n无\n清除缓存及生成的静态文件\n\n\n1.2 修改主题选择自己喜欢的主题\nhttps://hexo.io/themes/\n这里选择Kaze\n进入themes文件夹，下载主题，并重命名为kaze\ncd themes\ngit clone https:&#x2F;&#x2F;github.com&#x2F;theme-kaze&#x2F;hexo-theme-Kaze.git kaze\n修改配置文件（_config.yml）\ntheme: kaze\n主题名称为文件夹名称，默认为：landscape\n回到项目根目录，启动项目\nhexo clean\nhexo g\nhexo s\n1.3 完善博客项目1.3.1 修改基本信息进入themes/kaze/source ，创建文件夹 img，放入logo图片和作者头像\ntitle: 淡漠Blog\nauthor: 淡漠DM\nlogo_img: &#x2F;img&#x2F;logo.png # put the logo on the $&#123;blog_path&#125;&#x2F;source&#x2F;img&#x2F;$&#123;picname&#125;.png or use urls\nauthor_img: &#x2F;img&#x2F;author.jpg\nauthor_description: 最有趣的编程，莫过于服务生活。\n1.3.2 开启站点访问量统计（默认关闭）footer:\n  statistics:\n    enable: true\n    type: busuanzi # now version only supports busuanzi\n    pv:\n      enable: true\n      style: 本站总访问量&#123;&#125;次 # the style will be shown as $1&#123;pv&#125;$2\n    uv:\n      enable: true\n      style: 本站总访客数&#123;&#125;次\nenable 开启访问量统计（默认关闭）\ntype&#96; 目前仅支持 &#96;busuanzi\npv 访问总量统计\nuv 用户总量统计\n1.3.3 友链links:\n  小R资源:\n    url: https:&#x2F;&#x2F;www.tomyres.com\n    avatar: https:&#x2F;&#x2F;www.tomyres.com&#x2F;static&#x2F;images&#x2F;logo&#x2F;res_logo_1.png\n    description: 小R资源,免费的编程资源在线分享\n1.3.4 文章头部hello-world.md\n---\ntitle: Hello World\nbanner_img: https:&#x2F;&#x2F;www.tomyres.com&#x2F;static&#x2F;images&#x2F;logo&#x2F;res_logo_1.png\ncategory: Hi\ntag: hello\nexcerpt: 这是一段简介\n---\nbanner_img 文章封面\ncategory 分类\ntag 标签\nexcerpt 简介\n1.3.5 代码高亮在md文件写一段JavaScript代码\n​&#96;&#96;&#96;javascript\nconst smoothScrollToTop &#x3D; () &#x3D;&gt; &#123;\n  let yTopValve &#x3D; (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop);\n  if (yTopValve &gt; 1) &#123;\n    window.requestAnimationFrame(smoothScrollToTop);\n    scrollTo(0, Math.floor(yTopValve * 0.85));\n  &#125; else &#123;\n    scrollTo(0, 0);\n  &#125;\n&#125;;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  document.getElementById(&#39;scrollbutton&#39;).onclick &#x3D; smoothScrollToTop;\n&#125;, 0);\n​&#96;&#96;&#96;\n关闭 highlight，开启 prismjs（_config.yml）\nhighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: true\n  line_number: true\n  tab_replace: &#39;&#39;\n设置主题（kaze/_config.yml）\nprism:\n  theme: tomorrow\n1.3.6 评论这里使用 valine 实现评论，官方网 https://leancloud.cn/\n进入控制台后点击左下角创建应用\n应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了\n开启评论功能 kaze/_config.yml\ncomment:\n  enable: true\n  type: valine # valine | gitalk | livere | disqus | we recommend valine\n  # gitalk config details can see in https:&#x2F;&#x2F;github.com&#x2F;gitalk&#x2F;gitalk&#x2F;blob&#x2F;master&#x2F;readme-cn.md\n  valine:\n    appId: 你的appId\n    appKey: 你的appKey\n1.4 部署gitee创建一个公开的仓库，仓库名称需要和个人空间地址相同\n个人空间地址查看方式：设置——&gt;基本设置——&gt;个人资料\n初始化\ngit init\ngit remote add origin git@gitee.com:个人空间地址&#x2F;仓库名称.git\ngit pull origin master\n提交项目\ngit add .\ngit commit -m &#39;我的第一个博客项目&#39;\ngit push origin master\n第一次提交时，确保仓库没有文件，因为如果仓库有文件，且文件名字正好和本地项目的某个文件名相同，会导致提交失败\n修改配置文件\ndeploy:\n  type: git\n  repo: git@gitee.com:个人空间地址&#x2F;仓库名称.git\n  branch: master\n部署到gitee\nnpm install --save hexo-deployer-git\nhexo clean\nhexo g\nhexo d\n选择强制使用https\n部署后会显示网站地址，直接访问即可。\n项目每一次更新提交到gitee之后，需要更新部署\n注意：\n如果更新部署后访问项目没有变化，可以尝试 CTRL+F5 强制刷新，或清除浏览器缓存。\n","categories":["Hexo环境搭建"],"tags":["Hexo"]},{"title":"Hello Hexo","url":"https://gitee.com/LkGiteeCoder/LkGiteeCoder.git/2021/02/20/hello-world/","content":"const smoothScrollToTop = () => &#123;\n  let yTopValve = (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop);\n  if (yTopValve > 1) &#123;\n    window.requestAnimationFrame(smoothScrollToTop);\n    scrollTo(0, Math.floor(yTopValve * 0.85));\n  &#125; else &#123;\n    scrollTo(0, 0);\n  &#125;\n&#125;;\n\nsetTimeout(() => &#123;\n  document.getElementById('scrollbutton').onclick = smoothScrollToTop;\n&#125;, 0);\n","categories":["Hexo文章测试"],"tags":["Hexo"]}]